<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kafka-3:分区</title>
      <link href="2020/11/14/kafka-3-%E5%88%86%E5%8C%BA/"/>
      <url>2020/11/14/kafka-3-%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p> <img src="/2020/11/14/kafka-3-%E5%88%86%E5%8C%BA/1.png" alt="1"></p><p>分区，其实就是kafka的负载均衡方案，类似mongo的分片</p><p>不同分区放到不同机器节点，每节点独立执行格子分区请求，通过添加新的节点提升吞吐量</p><p>但是目前如果要保证消息的绝对顺序，就不能分区</p><p>但是对于不同的业务来说，不一定保证所有的消息都是顺序的， 只需要关联消息的顺序性，比如当前工作中送礼用户的id，原来工作中的单号</p><hr><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><ol><li><p>轮询：顺序分配，是 Kafka Java 生产者 API 默认提供的分区策略（未指定partitioner.class参数前提下），<strong>默认情况下它是最合理的分区策略</strong></p><p><img src="/2020/11/14/kafka-3-%E5%88%86%E5%8C%BA/2.png" alt="1"></p></li><li><p>随机：基本淘汰了</p></li><li><p>消息建：Key-ordering，简单来说就是根据 key进行hash放到对应分区，从而<strong>达到相同key（关联业务）放到一个分区，从而保证业务顺序性</strong>！！！！！！！！<br><img src="/2020/11/14/kafka-3-%E5%88%86%E5%8C%BA/3.png" alt="1"></p></li><li><p>地理位置分区</p></li></ol><p>总结：Java客户端默认的生产者分区策略的实现类为<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>。<br>默认策略为：<strong>如果指定了partition就直接发送到该分区；如果没有指定分区但是指定了key，就按照key的hash值选择分区；如果partition和key都没有指定就使用轮询策略</strong>。<br>而且如果key不为null，那么计算得到的分区号会是所有分区中的任意一个；如果key为null并且有可用分区时，那么计算得到的分区号仅为可用分区中的任意一个</p><hr><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>根据key分区有必要吗？具体案例？</li></ol><p>案例：之前做车辆实时定位(汽车每10s上传一次报文)显示的时候，发现地图显示车辆会突然退回去，开始排查怀疑是后端处理的逻辑问题导致的，但是后台保证了一台车只被一个线程处理，理论上不会出现这种情况；于是猜测是不是程序接收到消息的时候时间序就已经乱了，查阅了kafka相关资料，发现kafka同一个topic是无法保证数据的顺序性的，但是同一个partition中的数据是有顺序的；根据这个查看了接入端的代码(也就是kafka的生产者)，发现是按照kafka的默认分区策略(topic有10个分区，3个副本)发送的；于是将此处发送策略改为按照key(车辆VIN码)进行分区，后面车辆的定位显示就正常了。</p><ol start="2"><li>如果kafka搭了集群，有三个broker：123。这时候我对名称为test的topic发送消息，key设置为A，消息会随机发送到三个broker上去吗?</li></ol><p>会被发送到某个分区的leader副本上。这个分区的leader副本只能存在于3个broker中的一个，但是如果test的副本数是3，那么一条消息也会被备份到其他两个broker上。只是只有leader副本对外提供服务，因此没有顺序乱的情况出现。</p><ol start="3"><li>两个生产者，这时候消息如何确定消息的顺序呢?</li></ol><p>两个生产者生产的消息无法保证顺序，因为它们本身就没有前后之分，它们是并发的关系。除非业务处理</p><ol start="4"><li>一个生产者，发两次消息，但是网络原因，消息到达的顺序和消息发送的顺序不一致怎么办？</li></ol><p>设置max.in.flight.requests.per.connection=1来保证</p><ol start="5"><li>一台机器多个分区也会有负载均衡效果？也会提高吞吐量？</li></ol><p>通常1台broker上有多个分区依然能提升TPS，毕竟单个分区消耗不掉大部分的系统资源。</p><ol start="6"><li>key在哪指定，怎么指定啊</li></ol><p>Producer发送消息的时候可以直接指定key，比如producer.send(new ProducerRecord(“my-topic”, “key”, “value”));</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka-2:集群配置参数</title>
      <link href="2020/10/29/kafka-2-%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
      <url>2020/10/29/kafka-2-%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Broker-端参数"><a href="#Broker-端参数" class="headerlink" title="Broker 端参数"></a>Broker 端参数</h2><p>就是指的server.properties</p><ul><li><p><code>log.dirs</code>：指定了 <code>Broker</code> 需要使用的若干个文件目录路径（必须手动指定），<font color="red">生产环境中一定要为log.dirs配置多个路径</font>，例如<code>/home/kafka1,/home/kafka2,/home/kafka3</code>。最好挂载到不同的物理磁盘上—提升读写性能：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量 &amp;&amp; 实现故障转移：坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且 <code>Broker</code> 还能正常工作</p></li><li><p><code>listeners</code>：监听器，&lt;协议，主机名，端口&gt;，协议名比如 <code>PLAINTEXT</code> 表示明文传输、<code>SSL</code> 表示使用 <code>SSL</code> 或 <code>TLS</code> 加密传输等，自己定义的协议名字，比如<code>CONTROLLER: //localhost:9092</code>。必须还要指定<code>listener.security.protocol.map</code>参数告诉这个协议底层使用了哪种安全协议，比如指定<code>listener.security.protocol.map=CONTROLLER:PLAINTEXT</code>表示<code>CONTROLLER</code>这个自定义协议底层使用明文不加密传输数据。主机名，用ip也行，但用ip可能出现无法连接情况，</p></li><li><p>advertised.listeners：对外监听,主要是为外网访问用的。如果clients在内网环境访问Kafka不需要配置这个参数。<br>常见的玩法是：你的Kafka Broker机器上配置了双网卡，一块网卡用于内网访问（即我们常说的内网IP）；另一个块用于外网访问。那么你可以配置<code>listeners</code>为内网IP，<code>advertised.listeners</code>为外网IP。</p></li><li><p><code>auto.create.topics.enable</code>:是否允许自动生成topic,最好设置为false，不然代码写错了topic，就会自动生成错误的topic，管理混乱</p></li><li><p><code>unclean.leader.election.enable</code>:是否允许 Unclean Leader 选举,建议设置成false,比如当前分区leader副本挂了，同时几个数据比较多的追随者副本也挂了，只剩下一个一条数据的副本，要是让他当了leader会出现丢数据情况，所以宁可让这个分区失效，也不应该让他当领导。如果设置为true，就要做好丢数据的准备</p></li><li><p><code>auto.leader.rebalance.enable</code>：是否允许 Kafka 定期地对一些 Topic 分区进行 Leader 重选。建议false。参数<code>leader.imbalance.per.broker.percentage</code>控制触发比例，默认是10%。举个例子，如果一个broker上有10个分区，有2个分区的leader不是preferred leader，那么就会触发</p></li><li><p><code>message.max.bytes</code>:接受消息数据最大字节</p></li></ul><hr><h2 id="Topic-级别参数"><a href="#Topic-级别参数" class="headerlink" title="Topic 级别参数"></a>Topic 级别参数</h2><p>Topic 级别参数会覆盖全局 Broker 参数的值，而每个 Topic 都能设置自己的参数值，这就是所谓的 Topic 级别参数</p><p>例如Topic 根据自身业务需要，设置自己的留存时间，会覆盖broker的最长时间参数</p><ul><li><p>retention.ms ： 消息保存最长时间</p></li><li><p>retention.bytes： 可以使用多大磁盘空间，默认-1，无限使用磁盘空间</p></li><li><p>max.message.bytes：同broker一样</p></li></ul><p>使用参数创建实例：<br><code>bin/kafka-topics.sh--bootstrap-serverlocalhost:9092--create--topictransaction--partitions1--replication-factor1--configretention.ms=15552000000--configmax.message.bytes=5242880</code></p><p>修改示例：<br><code>bin/kafka-configs.sh--zookeeperlocalhost:2181--entity-typetopics--entity-nametransaction--alter--add-configmax.message.bytes=10485760</code></p><hr><h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><ul><li>如果 Broker 所在机器的 CPU 资源非常充裕，建议使用 CMS 收集器。启用方法是指定-XX:+UseCurrentMarkSweepGC。</li><li>使用吞吐量收集器。开启方法是指定-XX:+UseParallelGC</li><li>已经在使用 Java 9 了，那么就用默认的 G1 收集器就好了。在没有任何调优的情况下，G1 表现得要比 CMS 出色，主要体现在更少的 Full GC，需要调整的参数更少等，所以使用 G1 就好了。</li></ul><p>注：需要再启动的时候指定</p><p>ulimit -n：随便往大了设置下，如果不设置，单机在Centos7上几百的并发就报“Too many open files”，如ulimit -n 1000000（任何一个 Java 项目最好都调整下这个值）</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka-1:简介</title>
      <link href="2020/10/24/kafka-1-%E7%AE%80%E4%BB%8B/"/>
      <url>2020/10/24/kafka-1-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是kafka"><a href="#什么是kafka" class="headerlink" title="什么是kafka?"></a>什么是kafka?</h2><p>中间件？一个分布式流处理平台？消息队列？消息引擎系统？都是</p><h2 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h2><p>发布订阅的对象</p><p>每个业务、每个应用甚至是每类数据都创建专属的主题</p><p>向主题发布消息的客户端称为生产者<br>订阅主题消息的客户端应用程序就为消费者</p><p>一个 Kafka 集群由多个 <code>Broker</code> 组成，<code>Broker</code> 负责接收和处理客户端发送过来的请求，及对消息进行持久化。<br>常见的做法是将不同的 Broker 分散运行在不同的机器上，防止都在一台，服务器挂了就都废了</p><p>客户端 = 生产 + 消费<br>服务端 = <code>Broker</code> 服务进程， 一个 Kafka 集群由多个 <code>Broker</code> 组成</p><h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p>相同的数据拷贝到多台机器上</p><p>领导者副本（Leader Replica）：对外提供服务<br>追随者副本（Follower Replica）：被动地追随领导者副本，<font color="red">不能与外界进行交互（不像mysql、redis等）</font>，向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步</p><ul><li>为什么不想mysql一样，追随者也可以对外提供读服务？</li></ul><p>如果允许follower副本对外提供读服务（主写从读），首先会存在<strong>数据一致性</strong>的问题，消息从主节点同步到从节点需要时间，可能造成主从节点的数据不一致。</p><p>主写从读无非就是为了减轻leader节点的压力，将读请求的负载均衡到follower节点，如果<strong>Kafka的分区相对均匀地分散到各个broker上，同样可以达到负载均衡的效果</strong></p><p>mysql一般部署在不同的机器上一台机器读写会遇到瓶颈，Kafka中的领导者副本一般均匀分布在不同的broker中，已经起到了负载的作用。即：同一个topic的已经通过分区的形式负载到不同的broker上了，读写的时候针对的领导者副本，但是量相比mysql一个还实例少太多，个人觉得没有必要在提供度读服务了。（如果量大还可以使用更多的副本，让每一个副本本身都不太大）</p><p>Kafka也<strong>不属于典型的读多写少场景</strong>，主从分离的优势不明显</p><ul><li>领导者副本积累了太多的数据，单台 Broker 机器都无法容纳怎么办？—伸缩性问题：分区</li></ul><h2 id="分区（Partition）"><a href="#分区（Partition）" class="headerlink" title="分区（Partition）"></a>分区（Partition）</h2><p>将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。<br>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。<br>（副本是在分区这个层级定义的。每个分区下可以配置 1领导 + n 追随）</p><p>生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。分区位移总是从 0 开始</p><p>多个分区多个领导者，实现负载。</p><p>但是目前kafka设计多个分区的话无法保证全局的消息顺序。如果一定要实现全局的消息顺序，只能单分区</p><p>1个主题有2个分区，消费者组有3个消费者：有一个消费者将无法分配到任何分区，处于idle状态</p><p> Kafka 的三层消息架构：</p><ul><li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li><li>最后，客户端程序只能与分区的领导者副本进行交互。</li></ul><hr><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><p>分为点对点和发布订阅<br>点对点主要就是消费者组实现（group）<br>消费者组：多个消费者实例(进程、线程)共同组成一个组来消费一组主题,这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它<br>提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量<br>消费者组里面的所有消费者实例之间不但会竞争“消息资源”，还会彼此协作—重平衡（Rebalance）</p><p>重平衡（Rebalance）：组内某个实例挂掉了，Kafka自动检测到，把这个 Failed 实例之前负责的分区转移给其他活着的消费者</p><p>使用standalone consumer就完全避免rebalance了。事实上很多主流大数据流处理框架（Spark、Flink）都是这么使用的</p><h2 id="位移和消息位移"><a href="#位移和消息位移" class="headerlink" title="位移和消息位移"></a>位移和消息位移</h2><p>消费者位移（Consumer Offset）：每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上</p><p>位移（Offset）：每条消息在分区中的位置信息</p><p>区别：<br>“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了，针对的消息</p><p>“消费者位移”是随时变化的，毕竟它是消费者消费进度的指示器。另外每个消费者有着自己的消费者位移，消费完消息后使用一定策略更新自己的位移，针对的是消费者</p><p> <img src="/2020/10/24/kafka-1-%E7%AE%80%E4%BB%8B/1.png" alt="1"></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>消息日志保存数据，只能追加写，顺序I/O,不能随机I.O，保证了高吞吐量，<br>日志删除：为了避免日志堆积过多，提出日志段，旧的日志段写满了之后会再创建新的日志段，旧的日志段封存，定时任务扫描老的日志段是否能够删除</p><hr><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>mq和rpc调用的区别是什么呢?</li></ul><p>mq和rpc的区别往大了说属于数据流模式（dataflow mode）的问题。我们常见的数据流有三种：1. 通过数据库；2. 通过服务调用（REST/RPC）; 3. 通过异步消息传递（消息引擎，如Kafka）<br>RPC和MQ是有相似之处的，毕竟我们远程调用一个服务也可以看做是一个事件，但不同之处在于：</p><ol><li>MQ有自己的buffer，能够对抗过载（overloaded）和不可用场景</li><li>MQ支持重试</li><li>允许发布/订阅模式<br>当然它们还有其他区别。应该这样说RPC是介于通过数据库和通过MQ之间的数据流模式。</li></ol><ul><li>进程件通信的方式</li></ul><p>两个进程进行数据流交互的方式一般有三种：</p><ol><li>通过数据库：进程1写入数据库；进程2读取数据库（或者文件库）</li><li>通过服务调用：比如REST或RPC，而HTTP协议通常就作为REST方式的底层通讯协议</li><li>通过消息传递的方式：进程1发送消息给名为broker的中间件，然后进程2从该broker中读取消息。消息传输协议属于这种模式</li></ol><ul><li>为什么不直接通讯</li></ul><ol><li>削峰填谷：缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统，保护了下游</li><li>下游服务多，需要都发送吗？费劲，降低耦合，易扩展</li></ol><ul><li>Kafka 提供高可用有哪些手段</li></ul><ol><li>Broker 分散运行在不同的机器上，某台服务器所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务</li><li>备份机制</li></ol><ul><li>java写的kafka为什么都是部署在linux上？</li></ul><ol><li>I/O: Kafka 客户端底层使用了 Java 的 selector，selector 在 Linux 上的实现机制是 epoll，而在 Windows 平台上的实现机制是 select,性能低</li><li>网络传输： Linux 部署 Kafka 能够享受到零拷贝技术所带来的快速数据传输特性。Windows 平台上必须要等到 Java 8 的 60 更新版本才行</li></ol><ul><li>需要固态硬盘吗？</li></ul><ol><li><p>多是顺序读写操作，一定程度上规避了机械磁盘最大的劣势，即随机读写操作慢。从这一点上来说，使用 SSD 似乎并没有太大的性能优势</p></li><li><p>使用磁盘阵列（RAID）：提供冗余的磁盘存储空间，提供负载均衡（但是kafka不太需要，自己就有高可用+负载均衡，有钱随便）</p><p><img src="/2020/10/24/kafka-1-%E7%AE%80%E4%BB%8B/1.png" alt="1"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis13-慢redis总结</title>
      <link href="2020/10/14/redis13-%E6%85%A2redis%E6%80%BB%E7%BB%93/"/>
      <url>2020/10/14/redis13-%E6%85%A2redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="慢redis总结"><a href="#慢redis总结" class="headerlink" title="慢redis总结"></a>慢redis总结</h1><h2 id="判断是否真的慢"><a href="#判断是否真的慢" class="headerlink" title="判断是否真的慢"></a>判断是否真的慢</h2><p>通过链路追踪，redis出入口的响应延时定位是否为redis服务延时长<br>排查是否为网络问题，是否有丢包的现象<br>最终进行性能测试</p><p>基准性能：不同机器性能不同，但是一样的服务器配置，有个实例明显比其他通配置实例慢，那就应该有问题</p><ul><li>查看60秒内最大延时：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60</span><br><span class="line">Max latency so far: 32 microseconds.</span><br><span class="line">Max latency so far: 59 microseconds.</span><br><span class="line">Max latency so far: 72 microseconds.</span><br></pre></td></tr></table></figure><p>结果60秒内最大延时72毫秒</p><ul><li>一段时间内 Redis 的最小、最大、平均访问延迟</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1</span><br><span class="line">min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds range</span><br></pre></td></tr></table></figure><p>结果每间隔 1 秒，采样 Redis 的平均操作耗时，其结果分布在 0.08 ~ 0.13 毫秒之间</p><p>找一个正常的和你觉得慢的对比下上面这些参数，如果差距明显就确诊了，确诊后进一步确定问题原因</p><h2 id="高复杂度命令"><a href="#高复杂度命令" class="headerlink" title="高复杂度命令"></a>高复杂度命令</h2><p>根据redis慢日志（slowlog），查看只是时间长的命令</p><ul><li>慢日志阈值等配置：<br>eg：阈值5 毫秒，最近 500 条</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></table></figure><ul><li>查询慢日志：SLOWLOG get 5</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 5</span><br><span class="line">1) 1) (integer) 32693       # 慢日志ID</span><br><span class="line">   2) (integer) 1593763337  # 执行时间戳</span><br><span class="line">   3) (integer) 5299        # 执行耗时(微秒)</span><br><span class="line">   4) 1) &quot;LRANGE&quot;           # 具体执行的命令和参数</span><br><span class="line">      2) &quot;user_list:2000&quot;</span><br><span class="line">      3) &quot;0&quot;</span><br><span class="line">      4) &quot;-1&quot;</span><br><span class="line">2) 1) (integer) 32692</span><br><span class="line">   2) (integer) 1593763337</span><br><span class="line">   3) (integer) 5044</span><br><span class="line">   4) 1) &quot;GET&quot;</span><br><span class="line">      2) &quot;user_info:1000&quot;...</span><br></pre></td></tr></table></figure><ul><li>常见的慢命令</li></ul><h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a>bigkey</h2><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><h2 id="内存上限"><a href="#内存上限" class="headerlink" title="内存上限"></a>内存上限</h2><h2 id="fork进程"><a href="#fork进程" class="headerlink" title="fork进程"></a>fork进程</h2><h2 id="内存大页"><a href="#内存大页" class="headerlink" title="内存大页"></a>内存大页</h2><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h2 id="绑定cpu"><a href="#绑定cpu" class="headerlink" title="绑定cpu"></a>绑定cpu</h2><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><h2 id="网络带宽"><a href="#网络带宽" class="headerlink" title="网络带宽"></a>网络带宽</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis12-阻塞总结</title>
      <link href="2020/09/29/redis12-%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/"/>
      <url>2020/09/29/redis12-%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="redis阻塞"><a href="#redis阻塞" class="headerlink" title="redis阻塞"></a>redis阻塞</h1><p>客户端：网络 IO，键值对增删改查操作，数据库操作<br>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写<br>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件<br>切片集群实例：向其他实例传输哈希槽信息，数据迁移</p><p><img src="/2020/09/29/redis12-%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/18.jpg" alt="导入"></p><h2 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h2><p>网络IO不是主要因素：redis使用IO多路复用，避免主线程一直等待网络连接</p><p>复杂度高的键值对增删改查：O(N)，例如集合全量查询和聚合操作，bigKey删除<br><img src="/2020/09/29/redis12-%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/19.jpg" alt="导入"></p><ol><li>当元素数量从 10 万增加到 100 万时，4 大集合类型的删除时间的增长幅度从 5 倍上升到了近 20 倍；</li><li>集合元素越大，删除所花费的时间就越长；</li><li>当删除有 100 万个元素的集合时，最大的删除时间接近2秒！！！（Hash 类型）。Redis 的响应时间一般在微秒级别，所以。。</li></ol><h2 id="磁盘交互"><a href="#磁盘交互" class="headerlink" title="磁盘交互"></a>磁盘交互</h2><p>AOF写回策略如果是always。。。。<strong>写回是主线程，重写是子线程</strong></p><p>一个同步写磁盘的操作的耗时大约是 1～2ms，如果有大量的写操作需要记录在 AOF 日志中，并同步写回的话…</p><p>虽然子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。慢速的磁盘 IO 就不会阻塞主线程了。<br>但是fork这个瞬间一定是会阻塞主线程的</p><h2 id="主从交互"><a href="#主从交互" class="headerlink" title="主从交互"></a>主从交互</h2><p>从库在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库（更大的删除bigkey操作）<br>从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢–阻塞</p><h2 id="切片集群实例交互"><a href="#切片集群实例交互" class="headerlink" title="切片集群实例交互"></a>切片集群实例交互</h2><p>每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。<br>如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。<br>只需要知道，当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>五个阻塞点：集合全量查询和聚合操作；bigkey 删除；清空数据库；AOF 日志同步写；从库加载 RDB 文件</p><p>这五个可以异步操作吗？<br>集合全量查询和聚合操作              从库加载 RDB 文件      不可以 剩下的都可以</p><h2 id="redis异步子线程机制"><a href="#redis异步子线程机制" class="headerlink" title="redis异步子线程机制"></a>redis异步子线程机制</h2><p>主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，<strong>分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行</strong>。</p><p><strong>主线程通过一个链表形式的任务队列和子线程进行交互</strong>。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。</p><p>等到后台子线程从任务队列中读取任务后，开始删除并释放内存空间。—-<strong>惰性删除</strong>（lazy free）。删除或清空操作不会阻塞主线程</p><p>当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。</p><p><img src="/2020/09/29/redis12-%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/20.jpg" alt="导入"></p><p>异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作。键值对删除：当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，我建议你使用 UNLINK 命令。清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FLUSHDB ASYNC</span><br><span class="line">FLUSHALL AYSNC</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis11-和cpu的关系</title>
      <link href="2020/09/26/redis11-%E5%92%8Ccpu%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>2020/09/26/redis11-%E5%92%8Ccpu%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="cpu对redis的影响"><a href="#cpu对redis的影响" class="headerlink" title="cpu对redis的影响"></a>cpu对redis的影响</h1><p>cpu颗数:<code>cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l</code><br>cpu物理核数：<code>cat /proc/cpuinfo |grep &quot;cores&quot;|uniq|awk &#39;&#123;print $4&#125;&#39;</code><br>cpu逻辑核数：<code>cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</code>   ps:生产单颗、4物理、8逻辑<br>或者直接<code>lscpu</code>能查看全部信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Architecture:          x86_64 #架构</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8 #逻辑cpu</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    2 #每个物理核超线程数（逻辑核）</span><br><span class="line">Core(s) per socket:    4 #cpu插槽数（物理核）</span><br><span class="line">Socket(s):             1 #物理cpu（插槽数）</span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 85</span><br><span class="line">Model name:            Intel(R) Xeon(R) Platinum 8124M CPU @ 3.00GHz</span><br><span class="line">Stepping:              4</span><br><span class="line">CPU MHz:               3000.000</span><br><span class="line">BogoMIPS:              6000.00</span><br><span class="line">Hypervisor vendor:     KVM</span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              1024K #二级缓存</span><br><span class="line">L3 cache:              25344K #三级缓存</span><br><span class="line">NUMA node0 CPU(s):     0-7</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 ida arat pku ospke</span><br></pre></td></tr></table></figure><h2 id="主流的-CPU-架构"><a href="#主流的-CPU-架构" class="headerlink" title="主流的 CPU 架构"></a>主流的 CPU 架构</h2><p>cpu多核，每个物理核都可以运行应用程序。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。</p><p>所以，当数据或指令保存在 L1、L2 缓存时，物理核访问它们的延迟不超过 10 纳秒</p><p>L1 和 L2 缓存的大小受限于处理器的制造技术，一般只有 KB 级别</p><p>如果 L1、L2 缓存中没有所需的数据，需要访问内存来获取数据。比一、二级缓存慢了近10倍</p><p>不同的物理核还会共享一个共同的三级缓存，L3 一般比较大，能达到几 MB 到几十 MB</p><p>当 L1、L2 缓存中没有数据缓存时，可以访问 L3，尽可能避免访问内存。</p><p>主流的 CPU 处理器中，每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存。</p><p> <img src="/2020/09/26/redis11-%E5%92%8Ccpu%E7%9A%84%E5%85%B3%E7%B3%BB/cpu%E6%A0%B8.png" alt="1"></p><p> 在主流的服务器上，一个 CPU 处理器会有 10 到 20 多个物理核。同时，为了提升服务器的处理能力，服务器上通常还会有多个 CPU 处理器（也称为多 CPU Socket），每个处理器有自己的物理核（包括 L1、L2 缓存），L3 缓存，以及连接的内存，同时，不同处理器间通过总线连接。</p><p>如图：多颗cpu的服务器</p><p> <img src="/2020/09/26/redis11-%E5%92%8Ccpu%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%A4%9A%E9%A2%97cpu.png" alt="1"></p><p>多 CPU 架构上，应用程序可以在不同的处理器上运行。在刚才的图中，Redis 可以先在 Socket 1 上运行一段时间，然后再被调度到 Socket 2 上运行。<br>属于<strong>远端内存访问</strong>。和访问 Socket 直接连接的内存相比，<strong>远端内存访问会增加应用程序的延迟</strong>。</p><h2 id="CPU-多核对-Redis-性能的影响"><a href="#CPU-多核对-Redis-性能的影响" class="headerlink" title="CPU 多核对 Redis 性能的影响"></a>CPU 多核对 Redis 性能的影响</h2><p>在一个 CPU 核上运行时，应用程序需要记录自身使用的软硬件资源信息（例如栈指针、CPU 核的寄存器值等），我们把这些信息称为运行时信息。同时，应用程序访问最频繁的指令和数据还会被缓存到 L1、L2 缓存上，以便提升执行速度。<br>但是，在多核 CPU 的场景下，一旦应用程序需要在一个新的 CPU 核上运行，那么，运行时信息就需要重新加载到新的 CPU 核上。而且，新的 CPU 核的 L1、L2 缓存也需要重新加载数据和指令，这会导致程序的运行时间增加。</p><p>context switch 是指线程的上下文切换，这里的上下文就是线程的运行时信息。在 CPU 多核的环境中，一个线程先在一个 CPU 核上运行，之后又切换到另一个 CPU 核上运行，这时就会发生 context switch。<br>当 context switch 发生后，Redis 主线程的运行时信息需要被重新加载到另一个 CPU 核上，而且，此时，另一个 CPU 核上的 L1、L2 缓存中，并没有 Redis 实例之前运行时频繁访问的指令和数据，所以，这些指令和数据都需要重新从 L3 缓存，甚至是内存中加载。</p><p>这个重新加载的过程是需要花费一定时间的。而且，Redis 实例需要等待这个重新加载的过程完成后，才能开始处理请求，所以，这也会导致一些请求的处理时间增加。<br>如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，那么，对 Redis 实例的请求处理时间影响就更大了。<br>每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。<br>所以，我们要避免 Redis 总是在不同 CPU 核上来回调度执行。<br>尝试着把 Redis 实例和 CPU 核绑定，让一个 Redis 实例固定运行在一个 CPU 核上。我们可以使用 taskset 命令把一个程序绑定在一个核上运行。比如说，我们执行下面的命令，就把 Redis 实例绑在了 0 号核上，其中，“-c”选项用于设置要绑定的核编号。</p><p><code>taskset -c 0 ./redis-server</code></p><p>当然，绑核不仅对降低尾延迟有好处，同样也能降低平均延迟、提升吞吐率，进而提升 Redis 性能。接下来，我们再来看看多 CPU 架构，也就是 NUMA 架构，对 Redis 性能的影响。</p><h2 id="NUMA-架构对-Redis-性能的影响"><a href="#NUMA-架构对-Redis-性能的影响" class="headerlink" title="NUMA 架构对 Redis 性能的影响"></a>NUMA 架构对 Redis 性能的影响</h2><p>经常看到一种做法，为了提升 Redis 的网络性能，把操作系统的<strong>网络中断处理程序</strong>和 CPU 核绑定。这个做法可以避免网络中断处理程序在不同核上来回调度执行，的确能有效提升 Redis 的网络处理性能。</p><p>先来看下 Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间</p><p>在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个潜在的风险：<strong>如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存</strong>，这个过程会花费较多时间。</p><p> <img src="/2020/09/26/redis11-%E5%92%8Ccpu%E7%9A%84%E5%85%B3%E7%B3%BB/redis%E5%92%8C%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E8%B7%A8cpu.png" alt="1"></p><p>跨 CPU Socket 的内存访问延迟增加了 18%，这自然会导致 Redis 处理请求的延迟增加</p><p>在 CPU 多核的场景下，用 taskset 命令把 Redis 实例和一个核绑定，可以减少 Redis 实例在不同核上被来回调度执行的开销，避免较高的尾延迟；在多 CPU 的 NUMA 架构下，如果你对网络中断程序做了绑核操作，建议你同时把 Redis 实例和网络中断程序绑在同一个 CPU Socket 的不同核上，这样可以避免 Redis 跨 Socket 访问内存中的网络数据的时间开销（注意：<strong>NUMA 架构下 CPU 核的编号方法，这样才不会绑错核</strong>。）</p><h2 id="绑核的风险"><a href="#绑核的风险" class="headerlink" title="绑核的风险"></a>绑核的风险</h2><p>Redis 除了主线程以外，还有用于 RDB 生成和 AOF 重写的子进程还有Redis 的后台线程 会和主线程 竞争 CPU 资源</p><p>一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加</p><p>解决方法：</p><ol><li><p>一个 Redis 实例对应绑一个物理核，而不是逻辑核<br><code>taskset -c 0,1 ./redis-server</code><br>和只绑一个逻辑核相比，把 Redis 实例和物理核绑定，可以让主线程、子进程、后台线程共享使用 2 个逻辑核，可以在一定程度上缓解 CPU 资源竞争。但是，因为只用了 2 个逻辑核，它们相互之间的 CPU 竞争仍然还会存在。</p></li><li><p>优化 Redis 源码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis9-消息队列</title>
      <link href="2020/09/25/redis9-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>2020/09/25/redis9-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="redis消息队列"><a href="#redis消息队列" class="headerlink" title="redis消息队列"></a>redis消息队列</h1><h2 id="基于list"><a href="#基于list" class="headerlink" title="基于list"></a>基于list</h2><p>最常见生产者先用 LPUSH 写入了两条库存消息，分别是 5 和 3，表示要把库存更新为 5 和 3；消费者则用 RPOP 把两条消息依次读出</p><ul><li>风险一：List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令（比如while(1) 循环）。<br>如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。<strong>CPU 一直消耗在执行 RPOP 命令上</strong></li></ul><p><strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong></p><ul><li><p>风险二：redis如何保证重复消费<br>虽然redis单线程，pop都是原子性操作，但是因为业务等原因，还是要做重复判断，防止重复消费<br>比如每个消息添加一个全局id保证唯一，消费者收到了之后再判断下这个id是否已经消费过了</p></li><li><p>风险三：如何保证宕机消息不丢失<br>持久化的基础上<strong>使用List 类型提供的</strong> <code>BRPOPLPUSH</code> <strong>命令</strong></p></li></ul><p>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。<br><strong>消费者成功消费取出的消息后，最好把备份队列中的消息删除，防止备份队列存储过多无用的数据，导致内存浪费。</strong></p><ul><li>风险四：生产消费能力不匹配，导致list内存积压<br>只能使用多线程不支持消费组</li></ul><h2 id="Streams-数据类型"><a href="#Streams-数据类型" class="headerlink" title="Streams 数据类型"></a>Streams 数据类型</h2><p>redis5.0之后的版本提供，专门实现消息队列的数据类型<br>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</span><br><span class="line">XREAD：用于读取消息，可以按 ID 读取数据；</span><br><span class="line">XREADGROUP：按消费组形式读取消息；</span><br><span class="line">XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">xadd可以自动生成全局唯一 ID；</span><br><span class="line">XRAED可以指定从某个id之后开始读取，也能指定block配置，实现阻塞读取</span><br><span class="line">命令最后的“$”符号表示读取最新的消息，同时，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后，消息队列 mqstream 中一直没有消息，所以，XREAD 在 10 秒后返回空值（nil）。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;code</span><br><span class="line">XREAD block 10000 streams mqstream $</span><br></pre></td></tr></table></figure><p>Streams则是采用ack的方式，保证消息成功消费</p><p><img src="/2020/09/25/redis9-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/17.jpg" alt="导入"></p><p>起始还有redis的pub、sub发布订阅，但是已经基本淘汰了，除了哨兵用<br>因为消息不可靠，不能持久化（ Pub/Sub 没有基于任何数据类型实现），宕机无法恢复<br>消息积压就会强制消费者下线（消费者下线消息就直接丢了）</p><p>总结：但是终究不是专业的消息中间件<br>Redis 在以下 2 个场景下，都会导致数据丢失：</p><ol><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）</li></ol><p>还有：面对消息积压，Redis 内存资源紧张，一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上</p><p>适用场景：不是绝对一致，且体量小的业务</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis10-内存碎片</title>
      <link href="2020/09/25/redis10-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/"/>
      <url>2020/09/25/redis10-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><p>Redis 可以使用 libc、jemalloc、tcmalloc 多种内存分配器来分配内存，默认使用 jemalloc</p><p>jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间。</p><p>判断内存碎片</p><p><code>INFO memory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">used_memory:1073741736</span><br><span class="line">used_memory_human:1024.00M</span><br><span class="line">used_memory_rss:1997159792</span><br><span class="line">used_memory_rss_human:1.86G</span><br><span class="line">…</span><br><span class="line">mem_fragmentation_ratio:1.86</span><br></pre></td></tr></table></figure><p><code>mem_fragmentation_ratio = used_memory_rss/ used_memory</code></p><p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间。</p><p>经验阈值：<br>mem_fragmentation_ratio 大于 1 但小于 1.5。合理。内存分配器是一定要使用的，分配策略都是通用的。mem_fragmentation_ratio 大于 1.5 。内存碎片率已经超过了 50%。一般情况下需要采取一些措施来降低内存碎片率了。</p><p>如何清理内存碎片？</p><ol><li>重启：代价太大</li><li>4.0后可配置自动清理：类似jvm的复制算法不过不需要分成两块空间</li></ol><p>Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：</p><p><code>config set activedefrag yes</code></p><p>两个参数分别设置了触发内存清理的一个条件，如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理。<br><code>active-defrag-ignore-bytes 100mb</code></p><p>表示内存碎片的字节数达到 100MB 时，开始清理</p><p><code>active-defrag-threshold-lower 10</code></p><p>表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理</p><p>为了尽可能减少碎片清理对 Redis 正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的 CPU 时间，而且还设置了两个参数，分别用于控制清理操作占用的 CPU 时间比例的上、下限，既保证清理工作能正常进行，又避免了降低 Redis 性能。</p><p><code>active-defrag-cycle-min 25</code><br>表示自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展；</p><p><code>active-defrag-cycle-max 75</code><br>表示自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis8-统计，三种扩展数据类型</title>
      <link href="2020/09/22/redis8-%E7%BB%9F%E8%AE%A1%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/09/22/redis8-%E7%BB%9F%E8%AE%A1%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="统计，三种扩展数据类型"><a href="#统计，三种扩展数据类型" class="headerlink" title="统计，三种扩展数据类型"></a>统计，三种扩展数据类型</h1><h2 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h2><p>交集<br>并集<br>差集</p><p>例如<br>统计手机 App 每天的新增用户数和第二天的留存用户数<br>key : userid  记录所有用户uid<br>key : userid20210604 记录20210604登陆的用户</p><p>差集：计算20210604新增的用户，并放到新的set usernew 里面<br><code>SDIFFSTORE usernew userid20210604 userid</code><br>并集：新增用户加到所有用户里面<br><code>SUNIONSTORE userid userid userid20210604</code><br>交集：计算0603和0604都登陆的用户<br><code>SINTERSTORE useridRem userid20210603 userid20210604</code><br><strong>对多个集合进行聚合计算时，Set 类型会是一个非常不错的选择</strong></p><h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><p>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。所以，我给你分享一个小建议：你可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p><h2 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h2><p>list和zset都能排序，但是一般用zset<br>比如用list排序，分页的话第一页展示完，请求第二页时插入了新的数据，第二页就会出现第一页展示过的数据，zset可以根据权重排序</p><h2 id="二值状态统计Bitmap"><a href="#二值状态统计Bitmap" class="headerlink" title="二值状态统计Bitmap"></a>二值状态统计Bitmap</h2><p>记录签到（1）或未签到（0）</p><p>奖励发放（1）或未发放（0）</p><p><strong>Bitmap</strong><br>Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写（从0开始）<br>BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。<br>列如记录id为3000的用户在8月3号签到信息<br>key : uidsign3000:202008        offset : 2<br><code>SETBIT uidsign3000:202008 2 1</code><br>检查该用户 8 月 3 日是否签到<br><code>GETBIT uid:sign:3000:202008 2</code><br>统计该用户在 8 月份的签到次数。<br><code>BITCOUNT uid:sign:3000:202008</code></p><p>Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中<br><img src="/2020/09/22/redis8-%E7%BB%9F%E8%AE%A1%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/15.jpg" alt="导入"><br>例如统计1亿用户连续十天签到情况<br>可以日期为key 对应的uid签到的设置为1<br>十个key取<strong>与</strong>操作，放到新的bitmap里面，新的对应是1的才是10天都签到的<br>然后bitcount就是签到总数</p><p>1 个 1 亿位的 Bitmap，大约占 12MB</p><h2 id="基数统计HyperLogLog"><a href="#基数统计HyperLogLog" class="headerlink" title="基数统计HyperLogLog"></a>基数统计HyperLogLog</h2><p>比如多少人完成了活动<br>多少人访问了页面</p><p>可以用zset去重添加用户id，最后zcard或者hash，判断存在不存在不存在再添加，最后再HLEN<br>但是活动时每天的数据统计，或者页面几百几千万<br>太费内存了</p><p>HyperLogLog<br>每个 HyperLogLog 只需要花费 12 KB 内存<br>可以计算接近 2^64 个元素的基数<br>key ：page1Uv<br><code>PFADD page1Uv uid1 uid2 uid3 uid4 uid5 uid1 uid1 uid1 uid1 uid1 uid1 uid1 uid1 uid1</code><br>PFCOUNT 命令直接获得基数<br><code>pfcount page1Uv</code><br>如上输出5</p><p><strong>HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</strong><br><img src="/2020/09/22/redis8-%E7%BB%9F%E8%AE%A1%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/16.jpg" alt="导入"></p><h2 id="GEO经纬度"><a href="#GEO经纬度" class="headerlink" title="GEO经纬度"></a>GEO经纬度</h2><p>每个车对应一个经纬度<br>如果用hash，存储所有车辆位置信息，可实现<br>但是如果用户搜索附近的车，不支持根据经纬度范围查询（hashcode随机）</p><p>如果用zset，socre有范围</p><p>GEO:底层用zset，根据GEOHash编码（就是分别对经纬度左右二分法，左1，又0，分别将经纬度转换成1001111这种类型的数据，然后，偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值，合到一起）<br>将经纬度信息变成10组合形成的score分数<br>eg：存33号车经纬度<br><code>GEOADD carsInfo 116.034579 39.030452 33</code><br>eg:根据用户经纬度查找5公里范围的10个车<br><code>GEORADIUS carsInfo 116.054579 39.030452 5 km ASC COUNT 10</code><br><a href="https://time.geekbang.org/column/article/281745">https://time.geekbang.org/column/article/281745</a></p><h2 id="redis数据类型扩展"><a href="#redis数据类型扩展" class="headerlink" title="redis数据类型扩展"></a>redis数据类型扩展</h2><p>基于Redis实现的布隆过滤器，其底层实现利用的是String数据结构和位运算，可以解决业务层缓存穿透的问题，而且内存占用非常小，操作非常高效。</p><p>Redis提供的PubSub，可以支持多个消费者进行消费，生产者发布一条消息，多个消费者同时订阅消费。但是它的缺点是，如果任意一个消费者挂了，等恢复过来后，在这期间的生产者的数据就丢失了。PubSub只把数据发给在线的消费者，消费者一旦下线，就会丢弃数据。另一个缺点是，PubSub中的数据不支持数据持久化，当Redis宕机恢复后，其他类型的数据都可以从RDB和AOF中恢复回来，但PubSub不行，它就是简单的基于内存的多播机制。</p><p>Redis 5.0推出了Stream数据结构，它借鉴了Kafka的设计思想，弥补了List和PubSub的不足。Stream类型数据可以持久化、支持ack机制、支持多个消费者、支持回溯消费，基本上实现了队列中间件大部分功能，比List和PubSub更可靠。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis7-省内存</title>
      <link href="2020/09/18/redis7-%E7%9C%81%E5%86%85%E5%AD%98/"/>
      <url>2020/09/18/redis7-%E7%9C%81%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="省内存"><a href="#省内存" class="headerlink" title="省内存"></a>省内存</h1><h2 id="为什么-String-类型内存开销大？"><a href="#为什么-String-类型内存开销大？" class="headerlink" title="为什么 String 类型内存开销大？"></a>为什么 String 类型内存开销大？</h2><p>photo_id: 1101000051<br>photo_obj_id: 3301000051<br>我们保存了 1 亿张图片的信息，用了约 6.4GB 的内存，一个图片 ID 和图片存储对象 ID 的记录平均用了 64 字节。<br>但问题是，一组图片 ID 及其存储对象 ID 的记录，实际只需要 16 字节就可以了。</p><p>除了记录实际数据，<strong>String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据</strong>。<strong>当实际保存的数据较小时，元数据的空间开销就显得比较大了，有点“喧宾夺主”的意思。</strong></p><h3 id="String-类型具体是怎么保存数据"><a href="#String-类型具体是怎么保存数据" class="headerlink" title="String 类型具体是怎么保存数据"></a>String 类型具体是怎么保存数据</h3><p>当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。<br>但是<br><strong>当你保存的数据中包含字符时，String 类型就会用简单动态字符串</strong>（Simple Dynamic String，SDS）结构体来保存<br><img src="/2020/09/18/redis7-%E7%9C%81%E5%86%85%E5%AD%98/13.jpg" alt="导入"></p><p>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。<br>len：占 4 个字节，表示 buf 的已用长度。<br>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</p><p>对于 String 类型来说，<strong>除了 SDS 的额外开销，还有一个来自于 RedisObject 结构体的开销。</strong></p><p>因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在</p><p>Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。<br>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。<br><strong>另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。</strong></p><p><strong>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。</strong><br><img src="/2020/09/18/redis7-%E7%9C%81%E5%86%85%E5%AD%98/14.jpg" alt="导入"></p><p>因为 10 位数的图片 ID 和图片存储对象 ID 是 Long 类型整数，所以可以直接用 int 编码的 RedisObject 保存。每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了。此时，每个 ID 会使用 16 字节，加起来一共是 32 字节,还少32个字节<br>Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节，为什么会占用了 32 字节呢？这就要提到 Redis 使用的内存分配库 jemalloc 了。<br>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p><h2 id="用什么数据结构可以节省内存"><a href="#用什么数据结构可以节省内存" class="headerlink" title="用什么数据结构可以节省内存"></a>用什么数据结构可以节省内存</h2><p>压缩列表<br>头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。<br>它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。</p><ul><li>prev_len：表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。</li><li>len：表示自身长度，4 字节；</li><li>encoding：表示编码方式，1 字节；</li><li>content：保存实际数据。<br>entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接<br>一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8=14），实际分配 16 字节。<br>Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</li></ul><h2 id="如何用集合类型保存单值的键值对？"><a href="#如何用集合类型保存单值的键值对？" class="headerlink" title="如何用集合类型保存单值的键值对？"></a>如何用集合类型保存单值的键值对？</h2><p>基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value</p><p>以图片 ID 1101000060<br>图片存储对象 ID 3302000080 为例，<br>我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。<br>以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。</p><p><code>hset 1101000 060 3302000080</code></p><p>这样以1101000开头的1000个id用一个key ，但是hash的key不同</p><p>Hash 类型底层结构什么时候使用压缩列表，什么时候使用哈希表呢？其实，Hash 类型设置了用压缩列表保存数据时的两个阈值</p><p><code>hash-max-ziplist-entries</code>：表示用压缩列表保存时哈希集合中的最大元素个数。<br><code>hash-max-ziplist-value</code>：表示用压缩列表保存时哈希集合中单个元素的最大长度。</p><p>如果我们往 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。</p><p>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了</p><p>保存图片的例子，除了用String和Hash存储之外，还可以用Sorted Set存储（勉强）。</p><p>Sorted Set与Hash类似，当元素数量少于zset-max-ziplist-entries，并且每个元素内存占用小于zset-max-ziplist-value时，默认也采用ziplist结构存储。我们可以把zset-max-ziplist-entries参数设置为1000，这样Sorted Set默认就会使用ziplist存储了，member和score也会紧凑排列存储，可以节省内存空间。</p><p>使用zadd 1101000 3302000080 060命令存储图片ID和对象ID的映射关系，查询时使用zscore 1101000 060获取结果。</p><p>但是Sorted Set使用ziplist存储时的缺点是，这个ziplist是需要按照score排序的（为了方便zrange和zrevrange命令的使用），所以在插入一个元素时，需要先根据score找到对应的位置，然后把member和score插入进去，这也意味着Sorted Set插入元素的性能没有Hash高（这也是前面说勉强能用Sorte Set存储的原因）。而Hash在插入元素时，只需要将新的元素插入到ziplist的尾部即可，不需要定位到指定位置。</p><p>不管是使用Hash还是Sorted Set，当采用ziplist方式存储时，虽然可以节省内存空间，但是在查询指定元素时，都要遍历整个ziplist，找到指定的元素。所以使用ziplist方式存储时，虽然可以利用CPU高速缓存，但也不适合存储过多的数据</p><p>当使用ziplist存储时，我们尽量存储int数据，ziplist在设计时每个entry都进行了优化，针对要存储的数据，会尽量选择占用内存小的方式存储（整数比字符串在存储时占用内存更小），这也有利于我们节省Redis的内存。还有，因为ziplist是每个元素紧凑排列，而且每个元素存储了上一个元素的长度，所以当修改其中一个元素超过一定大小时，会引发多个元素的级联调整（前面一个元素发生大的变动，后面的元素都要重新排列位置，重新分配内存），这也会引发性能问题，需要注意。</p><p>另外，使用Hash和Sorted Set存储时，虽然节省了内存空间，但是设置过期变得困难（无法控制每个元素的过期，只能整个key设置过期，或者业务层单独维护每个元素过期删除的逻辑，但比较复杂）。而使用String虽然占用内存多，但是每个key都可以单独设置过期时间，还可以设置maxmemory和淘汰策略，以这种方式控制整个实例的内存上限。</p><p>所以在选用Hash和Sorted Set存储时，意味着把Redis当做数据库使用，这样就需要务必保证Redis的可靠性（做好备份、主从副本），防止实例宕机引发数据丢失的风险。而采用String存储时，可以把Redis当做缓存使用，每个key设置过期时间，同时设置maxmemory和淘汰策略，控制整个实例的内存上限，这种方案需要在数据库层（例如MySQL）也存储一份映射关系，当Redis中的缓存过期或被淘汰时，需要从数据库中重新查询重建缓存，同时需要保证数据库和缓存的一致性，这些逻辑也需要编写业务代码实现。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原则</title>
      <link href="2020/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99/"/>
      <url>2020/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="单一职责（SRP）"><a href="#单一职责（SRP）" class="headerlink" title="单一职责（SRP）"></a>单一职责（SRP）</h2><p><strong>一个类或者模块只负责完成一个职责</strong>，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><h3 id="如何判断类的职责是否足够单一？"><a href="#如何判断类的职责是否足够单一？" class="headerlink" title="如何判断类的职责是否足够单一？"></a>如何判断类的职责是否足够单一？</h3><p>不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的<br>比如业务简单就是要展示用户信息，所以省市区等字段都写到userinfo都没事<br>但是后面业务扩展多了电商物流等业务，可能就要把地址拆分成单独的，需求变了，单一的定义也就变了<br>虽然一开始就拆容易拓展但也有问题：一条数据库信息要创建多个类，如果数据库也拆了就要做多次数据库操作</p><p><strong>可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类</strong>。这就是所谓的持续重构</p><p>判断单一的几条参考原则：</p><ol><li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分</li><li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分</li><li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性</li><li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰</li><li>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li></ol><h3 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h3><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h2><p>怎样的代码改动才被定义为‘扩展’？<br>怎样的代码改动才被定义为‘修改’？<br>怎么才算满足或违反‘开闭原则’？<br>修改代码就一定意味着违反‘开闭原则’吗？”</p><p>扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则！</p><h3 id="怎么理解开闭原则？"><a href="#怎么理解开闭原则？" class="headerlink" title="怎么理解开闭原则？"></a>怎么理解开闭原则？</h3><p>我写的你别改，要加功能自己整—添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码</p><h3 id="如何做到“对扩展开放、修改关闭”？"><a href="#如何做到“对扩展开放、修改关闭”？" class="headerlink" title="如何做到“对扩展开放、修改关闭”？"></a>如何做到“对扩展开放、修改关闭”？</h3><p>具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。<br>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。<br>最常用来提高代码扩展性的方法有：<strong>多态、依赖注入、基于接口而非实现编程</strong>，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><p>对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！不然新增功能可能老代码都要测试</p><p>现在公司代码反思：<br>入参出参全是map，和oop不沾边，虽然接口复制粘贴改动小，但是数据不明确,一行一行看实现才能看出具体代码，校验逻辑及其数据转换贼墨迹，尤其强转</p><h2 id="里式替换（LSP）"><a href="#里式替换（LSP）" class="headerlink" title="里式替换（LSP）"></a>里式替换（LSP）</h2><h3 id="如何理解“里式替换原则”？"><a href="#如何理解“里式替换原则”？" class="headerlink" title="如何理解“里式替换原则”？"></a>如何理解“里式替换原则”？</h3><p>子类对象能够替换父类对象出现的任何地方，并保证原有逻辑正确。</p><h3 id="哪些代码明显违背了-LSP？"><a href="#哪些代码明显违背了-LSP？" class="headerlink" title="哪些代码明显违背了 LSP？"></a>哪些代码明显违背了 LSP？</h3>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis6-哨兵</title>
      <link href="2020/09/14/redis6-%E5%93%A8%E5%85%B5/"/>
      <url>2020/09/14/redis6-%E5%93%A8%E5%85%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p><p>监控主库运行状态，并判断主库是否客观下线；在主库客观下线后，选取新主库；选出新主库后，通知从库和客户端。</p><p><img src="/2020/09/14/redis6-%E5%93%A8%E5%85%B5/12.jpg" alt="导入"></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>主管下线，客观下线<br>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。<br>从库下了无所谓，主的不行</p><p>客观下线：<br>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断<br>当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”<br>也可以设置多少哨兵同意数量</p><h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><ol><li>除了要检查从库的当前在线状态，</li><li>还要判断它之前的网络连接状态<br>总是和主库断连，而且断连次数超出了一定的阈值 pass</li></ol><p><code>down-after-milliseconds * 10</code>。其中，<code>down-after-milliseconds</code> 是我们认定主从库断连的最大连接超时时间。如果在 <code>down-after-milliseconds</code> 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好<br>3. 优先级最高的从库得分高<br>通过 slave-priority 配置项，给不同的从库设置不同优先级(给配置好的设置优先级)<br>4. 和旧主库同步程度最接近的从库得分高。<br>主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。<br>slave_repl_offset 需要最接近 master_repl_offset<br>5. ID 号小的从库得分高</p><h2 id="哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？"><a href="#哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？" class="headerlink" title="哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？"></a>哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？</h2><p>如果客户端使用了读写分离，那么读请求可以在从库上正常执行，不会受到影响。但是由于此时主库已经挂了，而且哨兵还没有选出新的主库，所以在这期间写请求会失败，失败持续的时间 = 哨兵切换主从的时间 + 客户端感知到新主库 的时间。</p><p>如果不想让业务感知到异常，客户端只能把写失败的请求先缓存起来或写入消息队列中间件中，等哨兵切换完主从后，再把这些写请求发给新的主库，但这种场景只适合对写入请求返回值不敏感的业务，而且还需要业务层做适配，另外主从切换时间过长，也会导致客户端或消息队列中间件缓存写请求过多，切换完成之后重放这些请求的时间变长。</p><h2 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h2><p>配置哨兵的信息时，我们只需要用到下面的这个配置项，<br><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code><br>设置主库的 IP 和端口，并没有配置其他哨兵的连接信息。sentinel monitor<br>哨兵实例既然都不知道彼此的地址，又是怎么组成集群的呢?</p><p><strong>基于 pub/sub 机制的哨兵集群组成</strong><br><strong>哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。</strong><br>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。<br>Redis 会以频道的形式，对这些消息进行分门别类的管理<br>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</p><p><strong>哨兵是如何知道从库的 IP 地址和端口的呢？</strong><br>哨兵向主库发送 INFO 命令<br>主库接受到这个命令后，就会把从库列表返回给哨兵</p><p><strong>基于 pub/sub 机制的客户端事件通知</strong><br><strong>由哪个哨兵执行主从切换？</strong><br>“Leader 选举”<br>满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值</p><p>：要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds。我们曾经就踩过一个“坑”。当时，在我们的项目中，因为这个值在不同的哨兵实例上配置不一致，导致哨兵集群一直没有对有故障的主库形成共识，也就没有及时切换主库，最终的结果就是集群服务不稳定。所以，你一定不要忽略这条看似简单的经验。</p><p><strong>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</strong></p><p>经过实际测试，我的结论如下：</p><p>1、哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，哨兵集群可以判定主库为“客观下线”。</p><p>2、但哨兵不能完成主从切换。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到多数选票的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis5-主从</title>
      <link href="2020/09/12/redis5-%E4%B8%BB%E4%BB%8E/"/>
      <url>2020/09/12/redis5-%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h1><p>redis为什么可靠？一是数据尽量少丢失，二是服务尽量少中断。<br>AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是增加副本冗余量，将一份数据同时保存在多个实例上</p><p>Redis 提供了主从库模式，以保证数据副本的一致，<br>主从库之间采用的是<strong>读写分离的方式</strong>。</p><p>读操作：主库、从库都可以接收；<br>写操作：首先到主库执行，然后，主库将写操作同步给从库。</p><p><img src="/2020/09/12/redis5-%E4%B8%BB%E4%BB%8E/10.jpg" alt="导入"></p><p>为什么读写分离？<br>不分离，同一数据，一个实例写一次，怎么保证一致？加锁？开销大</p><h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><p>实例1执行replicaof<br><code>replicaof 172.16.19.3 6379</code><br>就会成为实例2（172.16.19.3） 的从库，主从<br><img src="/2020/09/12/redis5-%E4%B8%BB%E4%BB%8E/11.jpg" alt="导入"></p><ol><li>建立连接、协商同步的过程</li></ol><p>主要是为全量复制做准备。在这一步，<strong>从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</strong><br>从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。<strong>psync 命令包含了主库的 runID 和复制进度 offset</strong>。<br>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。<br>offset，此时设为 -1，表示第一次复制。<br>主库收到 psync 命令后，会用 <code>FULLRESYNC</code> 响应命令带上两个参数：主库 <code>runID</code> 和主库目前的复制进度 <code>offset</code>，返回给从库。从库收到响应后，会记录下这两个参数。<br><code>FULLRESYNC</code> <strong>响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库</strong>。</p><ol start="2"><li>RDB同步</li></ol><p>在第二阶段，<strong>主库将所有数据同步给从库。从库收到数据后会先清空当前数据库！！！！，然后在本地完成数据加载</strong>。这个过程依赖于内存快照生成的 RDB 文件。</p><ol start="3"><li>追加新的写命令</li></ol><p>在主库将数据<strong>同步给从库的过程中，主库不会被阻塞</strong>，仍然可以正常接收请求。<br>期间的写操作会记录到内存中专用的<code>replication buffer</code>中<br>主库完成 RDB 文件发送后，就会把此时 <code>replication buffer</code> 中的修改操作发给从库</p><p>同步完成</p><p>注： psync 这个动作 执行 RDB 全量数据，是直接传输到从库上，还是先落到主redis 磁盘上？<br>Redis在全量复制时，既支持先生成RDB文件，再把RDB文件传给从库，也支持在主库上直接通过socket把数据传给从库，这称为无盘复制。<br>如果运行主库的机器磁盘性能不太好，但是网络性能不错的话，可以考虑无盘复制。</p><h2 id="主从级联模式"><a href="#主从级联模式" class="headerlink" title="主从级联模式"></a>主从级联模式</h2><p>从库多了，主库不用干别的，一直忙着fork和传rdb文件了<br>可以主-从=从</p><h2 id="主从断网"><a href="#主从断网" class="headerlink" title="主从断网"></a>主从断网</h2><p>为了避免连接开销<br>主从都是长链接的<br>万一断网，从库不更新，读到从库旧数据怎么办？<br>2.8之前，只要断了从新连上之后就会全量复制<br>2.8之后：增量，把主从库网络断连期间主库收到的命令，同步给从库。<br>当主从库断连后，主库会把断连期间收到的写操作命令，写入 <code>replication buffer</code>，同时也会把这些操作命令也写入<code>repl_backlog_buffer</code> 这个缓冲区。<br><code>repl_backlog_buffer</code> 是<strong>一个环形缓冲区</strong>，<font color="red/">主库会记录自己写到的位置，从库则会记录自己已经读到的位置。<br>主库偏移量 <code>master_repl_offset</code>，从库已复制的偏移量 <code>slave_repl_offset</code><br>主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。<br><strong>repl_backlog_buffer是所有从库共享的</strong>，slave_repl_offset是由从库自己记录的，这也是因为每个从库的复制进度不一定相同。</font></p><p>注意：<br><code>repl_backlog_buffer</code> 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，<br>此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。（可以调整 repl_backlog_size 这个参数）<br>缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小<br>举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。</p><p>不过再大也可能完犊子，万一停机一天的从库连上来呢？</p><p>其实从库正常情况下会每秒给主库发送一个<code>replconf ack</code>命令，主库会根据这个命令的达到时间判断和从库的连网情况。如果距离最后一次ack命令收到的时间已经超过了repl_timeout时间，就会和从库断开连接了。</p><p>从库再和主库连接时，通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，如果要复制内容在缓冲区中已经被覆盖了，那么就不再做增量复制了，而是进行<strong>全量复制</strong>。</p><p>主从库同步的基本原理，总结来说，有三种模式：全量复制、基于长连接的命令传播，以及增量复制。</p><h2 id="主从库间的复制不使用-AOF"><a href="#主从库间的复制不使用-AOF" class="headerlink" title="主从库间的复制不使用 AOF"></a>主从库间的复制不使用 AOF</h2><p>1、RDB文件内容是经过压缩的二进制数据，文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。<br>2、假设要使用AOF做全量同步，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量同步数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。</p><h2 id="repl-backlog-buffer和replication-buffer理解"><a href="#repl-backlog-buffer和replication-buffer理解" class="headerlink" title="repl_backlog_buffer和replication buffer理解"></a>repl_backlog_buffer和replication buffer理解</h2><p>1、repl_backlog_buffer：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久，<code>repl_backlog_buffer</code>环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以<code>repl_backlog_buffer</code>配置尽量大一些，可以降低主从断开后全量同步的概率。而在<code>repl_backlog_buffer</code>中找主从差异的数据后，如何发给从库呢？这就用到了<code>replication buffer</code>。</p><p>2、replication buffer：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做<code>replication buffer</code>。</p><p>既然有这个内存buffer存在，那么这个buffer有没有限制呢？如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个buffer就会持续增长，消耗大量的内存资源，甚至OOM。所以Redis提供了<code>client-output-buffer-limit</code>参数限制这个buffer的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果<strong>从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java一些基础巩固</title>
      <link href="2020/09/09/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
      <url>2020/09/09/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 编译器自动优化成：不然会创建&quot;ab&quot;、&quot;cd&quot;、&quot;ef&quot;、&quot;abce&quot;、“abcdef”多个</span></span><br><span class="line">String str= <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span> + <span class="string">&quot;ef&quot;</span>;</span><br><span class="line">String str= <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">      str = str + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器自动优化成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">       str = (<span class="keyword">new</span> StringBuilder(String.valueOf(str))).append(i).toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么编译器提示循环里面的字符串最好用stringBuilder?即使不显示的创建，编译器也会在循环里面创建，但是里面会创建1000次stringBuilder，不如自己在外面定义一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// intern可以避免内存浪费，如果常量池存在&quot;abc&quot;，并不会创建b,而是将b创建的堆内存当垃圾回收,b指向的还是常量池中的“abc”和一样</span></span><br><span class="line">String a =<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line">System.out.print(a==b); <span class="comment">//结果是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.7之前string :char 数组、偏移量 offset、字符数量 count、哈希值 hash</span></span><br><span class="line"><span class="comment">// 1.7-1.8 :不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。</span></span><br><span class="line"><span class="comment">// 1.9 : char[] 字段改为了 byte[] 字段，又维护了一个新的属性 coder,降低了内存（char 字符占 16 位，2 个字节。byte占 8 位，1 个字节  ）</span></span><br></pre></td></tr></table></figure><ul><li>不可变的好处：</li></ul><ol><li>安全性，防止恶意篡改</li><li>hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。</li><li>实现字符串常量池：减少同一个值的字符串对象的重复创建，节约内存。</li></ol><ul><li>慎用Split+正则：回溯问题，避免回溯的方法就是：使用懒惰模式（正则加“?”）和独占模式(正则加”+”号)。</li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ol><li><p>对象数组 elementData 使用了 transient 修饰，却又实现了 Serializable 接口为什么？<br>如果采用外部序列化法实现数组的序列化，会序列化整个数组。ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法 writeObject 以及 readObject 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 对象数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>同理LinkedList :序列化的时候不会只对头尾进行序列化，所以 LinkedList 也是自行实现 readObject 和 writeObject 进行序列化与反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></li><li><p>ArrayList添加操作慢？<br>在没有扩容的情况下，ArrayList 的效率要高于 LinkedList。这是因为 ArrayList 在添加元素到尾部的时候，不需要复制重排数据，效率非常高。而 LinkedList 虽然也不用循环查找元素，但 LinkedList 中多了 new 对象以及变换指针指向对象的过程，所以效率要低于 ArrayList。（删除同理）</p></li><li><p>遍历选择：<br>LinkedList 切忌使用 for ：太慢，每次都是从头找，使用迭代器</p></li><li><p>ArrayList删除注意：</p><p>错误写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (String s : list)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (s.equals(<span class="string">&quot;b&quot;</span>)) </span><br><span class="line">         &#123;</span><br><span class="line">             list.remove(s);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">         String str = it.next();</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (str.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line">             it.remove();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>for(:)循环[这里指的不是for(;;)]是一个语法糖，这里会被解释为迭代器，在使用迭代器遍历时，<code>ArrayList</code>内部创建了一个内部迭代器<code>iterator</code>，在使用<code>next()</code>方法来取下一个元素时，会使用<code>ArrayList</code>里保存的一个用来记录<code>List</code>修改次数的变量<code>modCount</code>，与<code>iterator</code>保存了一个<code>expectedModCount</code>来表示期望的修改次数进行比较，如果不相等则会抛出异常；</p></li></ol><p>而在在<code>foreach</code>循环中调用<code>list</code>中的<code>remove()</code>方法，会走到<code>fastRemove()</code>方法，该方法不是<code>iterator</code>中的方法，而是<code>ArrayList</code>中的方法，在该方法只做了<code>modCount++</code>，而没有同步到<code>expectedModCount</code>。</p><p>当再次遍历时，会先调用内部类<code>iteator</code>中的<code>hasNext()</code>,再调用<code>next()</code>,在调用<code>next()</code>方法时，会对<code>modCount</code>和<code>expectedModCount</code>进行比较，此时两者不一致，就抛出了<code>ConcurrentModificationException</code>异常。</p><p>所以关键是用<code>ArrayList</code>的<code>remove</code>还是<code>iterator</code>中的<code>remove</code>。</p><p>ArrayList 是非线程安全容器，在并发场景下使用很可能会导致线程安全问题。这时，我们就可以考虑使用 Java 在并发编程中提供的线程安全数组，包括 Vector 和 CopyOnWriteArrayList。</p><p>Vector 也是基于 Synchronized 同步锁实现的线程安全，Synchronized 关键字几乎修饰了所有对外暴露的方法，所以在读远大于写的操作场景中，Vector 将会发生大量锁竞争，从而给系统带来性能开销。</p><p>相比之下，CopyOnWriteArrayList 是 java.util.concurrent 包提供的方法，它实现了读操作无锁，写操作则通过操作底层数组的新副本来实现，是一种读写分离的并发策略</p><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><ol><li><p>设置初始容量，一般得是 2 的整数次幂?<br>就是减少哈希冲突，均匀分布元素。<br>通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；<br>如果 length 为 2 的次幂，则 length-1 转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费<br>2的幂次方减1后每一位都是1，让数组每一个位置都能添加到元素。<br>例如十进制8，对应二进制1000，减1是0111，这样在&amp;hash值使数组每个位置都是可以添加到元素的，如果有一个位置为0，那么无论hash值是多少那一位总是0，例如0101，&amp;hash后第二位总是0，也就是说数组中下标为2的位置总是空的。</p></li><li><p>为什么JDK1.8之前，链表元素增加采用的是头插法，1.8之后改成尾插法了<br>JDK1.7是考虑新增数据大多数是热点数据，所以考虑放在链表头位置，也就是数组中，这样可以提高查询效率，但这种方式会出现插入数据是逆序的。在JDK1.8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多，相比头插法而言，尾插法操作额外的遍历消耗已经小很多了。</p></li><li><p>为什么阈值是8？链表长度超过8一定会转红黑树吗？<br>根据时间复杂度，为8时链表和红黑树都是一样的，超过8红黑树复杂度更低<br>还有个要求，元素数量超过64（<code>MIN_TREEIFY_CAPACITY</code>）</p></li><li><p>为什么红黑树退化链表的阈值是6不是7？<br>防止来回在红黑树和链表之间转换，避免频繁转换的开销（树的左旋右旋）</p></li></ol><p>线程安全的：如果对数据有强一致要求，则需使用 Hashtable；在大部分场景通常都是弱一致性的情况下，使用 ConcurrentHashMap 即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用 ConcurrentSkipListMap。</p><p>ConcurrentHashMap有些方法是没有锁的，例如get 方法。假设A修改了数据，而B后于A一瞬间去获取数据，有可能拿到的数据是A修改之前的数据。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li><p>Java 发布了 NIO 的升级包 NIO2，也就是 AIO。AIO 实现了真正意义上的异步 I/O，它是直接将 I/O 操作交给操作系统进行异步处理。这也是对 I/O 操作的一种优化，那为什么现在很多容器的通信框架都还是使用 NIO 呢？</p><p> 异步I/O模型在Linux内核中没有实现</p></li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton singleInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleInstance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码问题：序列化会通过反射调用无参构造器返回一个新对象，破坏单例模式。<br>解决方法是添加readResolve()方法，自定义返回对象策略。</p><p>java序列化： 仅对对象的非 transient 的实例变量进行序列化，而不会序列化对象的 transient 的实例变量，也不会序列化静态变量。<br>在实现了 Serializable 接口的类的对象中，会生成一个 serialVersionUID 的版本号,它会在反序列化过程中来验证序列化对象是否加载了反序列化的类，如果是具有相同类名的不同版本号的类，在反序列化中是无法获取对象的。具体实现序列化的是 writeObject 和 readObject，通常这两个方法是默认的，当然我们也可以在实现 Serializable 接口的类中对其进行重写，定制一套属于自己的序列化与反序列化机制。另外，Java 序列化的类中还定义了两个重写方法：writeReplace() 和 readResolve()，前者是用来在序列化之前替换序列化对象的，后者是用来在反序列化之后对返回对象进行处理的。</p><ul><li>Java 序列化的缺陷<ol><li>无法跨语言: Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议</li><li>易被攻击</li><li>性能差</li></ol></li><li>代替：<br>SpringCloud 用的是 Json 序列化<br>近两年比较火的 Protobuf 序列化<br>Dubbo+Protobuf 序列化</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><img src="/2020/09/09/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E9%94%81.png" alt="1"></p><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的 Java 对象头实现了锁升级功能。</p><p>当 Java 对象被 Synchronized 关键字修饰成为同步锁后，围绕这个锁的一系列升级操作都将和 Java 对象头有关。</p><p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，Synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</p><ol><li>偏向锁<br>偏向锁的作用就是，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头的 Mark Word 中去判断一下是否有偏向锁指向它的 ID，无需再进入 Monitor 去竞争对象了。当对象被当做同步锁并有一个线程抢到了锁时，锁标志位还是 01，“是否偏向锁”标志位设置为 1，并且记录抢到锁的线程 ID，表示进入偏向锁状态。</li></ol><p>在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加 JVM 参数关闭偏向锁来调优系统性能<br><code>-XX:-UseBiasedLocking // 关闭偏向锁（默认打开）</code><br>2. 轻量级锁</p><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 Mark Word 中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换 Mark Word 中的线程 ID 为自己的 ID，该锁会保持偏向锁状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。<br>轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。<br>3. 自旋锁与重量级锁</p><p>轻量级锁 CAS 抢锁失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的时间内释放资源，那么进入阻塞状态的线程无疑又要申请锁资源。</p><p>JVM 提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。<br>自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。<br>在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。！！！<br>一旦锁竞争激烈或锁占用的时间过长，自旋锁将会导致大量的线程一直处于 CAS 重试状态，占用 CPU 资源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。<br>在高负载、高并发的场景下，我们可以通过设置 JVM 参数来关闭自旋锁，优化系统性能，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseSpinning <span class="comment">// 参数关闭自旋锁优化 (默认打开) </span></span><br><span class="line">-XX:PreBlockSpin <span class="comment">// 参数修改默认的自旋次数。JDK1.7 后，去掉此参数，由 jvm 控制</span></span><br></pre></td></tr></table></figure><ol start="4"><li>动态编译实现锁消除 / 锁粗化<br>JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。<br>确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用</li></ol><p>锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。<br>5. 减小锁粒度：锁分离、锁分段<br>读写锁实现了锁分离，也就是说读写锁是由“读锁”和“写锁”两个锁实现的，其规则是可以共享读，但只有一个写。<br>当我们的锁对象是一个数组或队列时，集中竞争一个对象的话会非常激烈，锁也会升级为重量级锁。我们可以考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行度。<br>ConcurrentHashMap 就很很巧妙地使用了分段锁 Segment 来降低锁资源竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修饰静态方法:类锁！！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8，ConcurrentHashMap 做了大量的改动，摒弃了 Segment 的概念。由于 Synchronized 锁在 Java6 之后的性能已经得到了很大的提升，所以在 JDK1.8 中，Java 重新启用了 Synchronized 同步锁，通过 Synchronized 实现 HashEntry 作为锁粒度。这种改动将数据结构变得更加简单了，操作也更加清晰流畅。</p><h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p> JVM 隐式获取和释放锁的 Synchronized 同步锁，Lock 同步锁（以下简称 Lock 锁）需要的是显示获取和释放锁<br> 这就为获取和释放锁提供了更多的灵活性。Lock 锁的基本操作是通过乐观锁来实现的，但由于 Lock 锁也会在阻塞时被挂起，因此它依然属于悲观锁。</p><p> <img src="/2020/09/09/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E9%94%81%E5%AF%B9%E6%AF%94.png" alt="1"></p><p> 并发量不高、竞争不激烈的情况下，Synchronized 同步锁由于具有分级锁的优势，性能上与 Lock 锁差不多<br> 高负载、高并发的情况下，Synchronized 同步锁由于竞争激烈会升级到重量级锁，性能则没有 Lock 锁稳定。</p><p>常用的实现类有 ReentrantLock、ReentrantReadWriteLock（RRW），它们都是依赖 AbstractQueuedSynchronizer（AQS）类实现的。</p><p>AQS 类结构中包含一个基于链表实现的等待队列（CLH 队列），用于存储所有阻塞的线程，AQS 中还有一个 state 变量，该变量对 ReentrantLock 来说表示加锁状态。</p><p>该队列的操作均通过 CAS 操作实现</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程创建多了导致上下文切换频繁。cpu、内存负载提高</p><p>一个线程被剥夺处理器的使用权而被暂停运行，就是“切出”；一个线程被选中占用处理器开始或者继续运行，就是“切入”。在这种切出切入的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是“上下文”了。</p><p>包括了寄存器的存储内容以及程序计数器存储的指令内容。CPU 寄存器负责存储已经、正在和将要执行的任务，程序计数器负责存储 CPU 正在执行的指令位置以及即将执行的下一条指令的位置。</p><p>当前 CPU 数量远远不止一个的情况下，操作系统将 CPU 轮流分配给线程任务，此时的上下文切换就变得更加频繁了，并且存在跨 CPU 上下文切换，比起单核上下文切换，跨核切换更加昂贵。</p><p>线程主要有“新建”（NEW）、“就绪”（RUNNABLE）、“运行”（RUNNING）、“阻塞”（BLOCKED）、“死亡”（DEAD）五种状态。</p><p>一种是程序本身触发的切换，这种我们称为自发性上下文切换，另一种是由系统或者虚拟机诱发的非自发性上下文切换。</p><p>自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。</p><p>sleep()<br>wait()<br>yield()<br>join()<br>park()<br>synchronized<br>lock<br>非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。</p><p>使用 Linux 内核提供的 vmstat 命令，来监视 Java 程序运行过程中系统的上下文切换频率</p><p>监视某个应用的上下文切换，就可以使用 pidstat 命令监控指定进程的 Context Switch 上下文切换。</p><p>多线程中使用 Synchronized 还会发生进程间的上下文切换吗？</p><p>进程上下文切换，是指用户态和内核态的来回切换。我们知道，如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。</p><p>上下文切换是多线程编程性能消耗的原因之一，而竞争锁、线程间的通信以及过多地创建线程等多线程编程操作，都会给系统带来上下文切换。除此之外，I/O 阻塞以及 JVM 的垃圾回收也会增加上下文切换。</p><p>总的来说，过于频繁的上下文切换会影响系统的性能，所以我们应该避免它。另外，我们还可以将上下文切换也作为系统的性能参考指标，并将该指标纳入到服务性能监控，防患于未然。</p><p>ThreadPoolExecutor 创建线程池：</p><p>默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务。</p><p>但有一种情况排除在外，就是调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法的话，可以提前创建等于核心线程数的线程数量，这种方式被称为预热，在抢购系统中就经常被用到。</p><p>当创建的线程数等于 corePoolSize 时，提交的任务会被加入到设置的阻塞队列中。当队列满了，会创建线程执行任务，直到线程池中的数量等于 maximumPoolSize。</p><p>当线程数量已经等于 maximumPoolSize 时， 新提交的任务无法加入到等待队列，也无法创建非核心线程直接执行，我们又没有为线程池设置拒绝策略，这时线程池就会抛出 RejectedExecutionException 异常，即线程池拒绝接受这个任务。</p><p>当线程池中创建的线程数量超过设置的 corePoolSize，在某些线程处理完任务后，如果等待 keepAliveTime 时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，会对所谓的“核心线程”和“非核心线程”一视同仁，直到线程池中线程的数量等于设置的 corePoolSize 参数，回收过程才会停止。</p><p> <img src="/2020/09/09/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="1"></p><p> 一般多线程执行的任务类型可以分为 CPU 密集型和 I/O 密集型，根据不同的任务类型，我们计算线程数的方法也不一样。</p><p> 线程数 =N（CPU 核数）*（1+WT（线程等待时间）/ST（线程时间运行时间））</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis4-RDB</title>
      <link href="2020/09/09/redis4-RDB/"/>
      <url>2020/09/09/redis4-RDB/</url>
      
        <content type="html"><![CDATA[<h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><p>AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用</p><p>RDB内存快照：记录的是某一时刻的数据（<strong>全量数据</strong>）</p><p>save：在主线程中执行，会导致阻塞<br>bgsave：创建一个子进程，专门用于写入 RDB 文件（默认）</p><h2 id="创建RDB期间，redis还能提供写操作"><a href="#创建RDB期间，redis还能提供写操作" class="headerlink" title="创建RDB期间，redis还能提供写操作"></a>创建RDB期间，redis还能提供写操作</h2><p>Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。<br>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。<br>主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份副本，主线程在副本上进行修改。同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件。</p><p><img src="/2020/09/09/redis4-RDB/9.jpg" alt="导入"></p><h2 id="多久一次"><a href="#多久一次" class="headerlink" title="多久一次"></a>多久一次</h2><p>不能太频繁，多个快照写入竞争磁盘带宽，且fork过程会阻塞主线程<br>同时<br>Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程（霸道）</p><h2 id="RDB风险"><a href="#RDB风险" class="headerlink" title="RDB风险"></a>RDB风险</h2><p>例如：2核CPU、4GB内存、500G磁盘，Redis实例占用2GB，写读比例为8:2，此时做RDB持久化，产生的风险主要在于 CPU资源 和 内存资源 这2方面：</p><p>a、内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，“写实复制”会重新分配整个实例80%的内存副本，大约需要重新分配1.6GB内存空间，这样整个系统的内存使用接近饱和，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。</p><p>b、CPU资源风险：虽然子进程在做RDB持久化，但生成RDB快照过程会消耗大量的CPU资源，虽然Redis处理处理请求是单线程的，但Redis Server还有其他线程在后台工作，例如AOF每秒刷盘、异步关闭文件描述符这些操作。由于机器只有2核CPU，这也就意味着父进程占用了超过一半的CPU资源，此时子进程做RDB持久化，可能会产生CPU竞争，导致的结果就是父进程处理请求延迟增大，子进程生成RDB快照的时间也会变长，整个Redis Server性能下降。</p><h2 id="增量快照"><a href="#增量快照" class="headerlink" title="增量快照"></a>增量快照</h2><p>全量之后只对修改过的数据进行记录<br>怎么记录—-AOF reids4.0 实现两种持久化的结合：一定频率执行RDB，两次RDB期间AOF</p><p>不用频繁forK rdb &amp;&amp;重写 进程，不用频繁重写AOF文件</p><h2 id="关于-AOF-和-RDB-的选择问题"><a href="#关于-AOF-和-RDB-的选择问题" class="headerlink" title="关于 AOF 和 RDB 的选择问题"></a>关于 AOF 和 RDB 的选择问题</h2><p>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；<br>如果允许分钟级别的数据丢失，可以只使用 RDB；<br>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis3-AOF</title>
      <link href="2020/09/05/redis3-AOF/"/>
      <url>2020/09/05/redis3-AOF/</url>
      
        <content type="html"><![CDATA[<h1 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h1><p>不同于数据库的写前日志<br>AOF是写后日志： Redis 是先执行命令，把数据写入内存，然后才记录日志<br>记录的是 Redis 收到的每一条命令</p><h2 id="为什么先执行后记录AOF"><a href="#为什么先执行后记录AOF" class="headerlink" title="为什么先执行后记录AOF"></a>为什么先执行后记录AOF</h2><ol><li><p>为了避免额外的检查开销<br>Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。<br>所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。<br>先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</p></li><li><p>不会阻塞当前的操作<br>先解决redis要干的正事，正事干完了再持久化，redis为了快<br>但是先执行完再写，还是先写再执行，意义不大？AOF也是在主线程执行的</p></li></ol><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><ol><li><p>刚执行完一个命令，还没有来得及记日志就宕机了<br>如果redis是缓存，重新读。但如果是做数据库，数据就丢了</p></li><li><p>如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p></li></ol><p>控制一个写命令执行完后 AOF 日志写回磁盘的时机上述风险可以降低</p><h2 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h2><p>Always：同步写会，执行完立马写</p><p>Everysec：每秒写回，执行完，先写到缓冲区，一秒后缓冲区写到磁盘（建议）</p><p>No：系统写回，写到缓冲区，系统决定何时写入磁盘</p><p>可靠性逐渐减低，性能逐渐提高，看业务自行取舍</p><h2 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h2><p>不断追加aof文件过大，往大文件里写数据效率会减低，影响主线程，影响redis性能</p><p>重写机制具有“多变一”：一条命令反复修改时，aof记录最终的结果</p><p>每次 AOF 重写时，主进程fork子进程，子进程拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。因为 Redis 采用额外的线程进行数据重写，所以不会阻塞主线程（但是fork过程会阻塞）</p><font color="red">aof重写是子进程bgrewriteaof 进行aof写回是主线程</font><h2 id="什么时候触发AOF重写"><a href="#什么时候触发AOF重写" class="headerlink" title="什么时候触发AOF重写"></a>什么时候触发AOF重写</h2><p>两个配置项在控制AOF重写的触发时机：</p><ol><li><p>auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB</p></li><li><p>auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。</p></li></ol><p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p><h2 id="AOF重写风险"><a href="#AOF重写风险" class="headerlink" title="AOF重写风险"></a>AOF重写风险</h2><ol><li>主进程fork子进程<br>fork这个瞬间一定是会阻塞主线程的<br>fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。</li></ol><p>fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。</p><h2 id="AOF-重写也有一个重写日志，为什么它不共享使用-AOF-本身的日志呢？"><a href="#AOF-重写也有一个重写日志，为什么它不共享使用-AOF-本身的日志呢？" class="headerlink" title="AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？"></a>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？</h2><p>一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。<br>二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。</p><p>使用 AOF 进行故障恢复时，我们仍然需要把所有的操作记录都运行一遍。再加上 Redis 的单线程设计，这些命令操作只能一条一条按顺序执行，这个“重放”的过程就会很慢了。—RDB牛逼了</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis2-单线</title>
      <link href="2020/09/02/redis2-%E5%8D%95%E7%BA%BF/"/>
      <url>2020/09/02/redis2-%E5%8D%95%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么单线程"><a href="#为什么单线程" class="headerlink" title="为什么单线程"></a>为什么单线程</h1><p>1.多线程上下文切换<br>2.共享资源的并发访问控制：锁-&gt;等待-&gt;并行变串行</p><p>严格说：Redis 的网络 IO 和键值对读写是单线程，<br>持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h2><p>1.大部分基于内存<br>2.多种数据结构：跳表，压缩，双向，哈希，数组等<br>3.多路复用机制</p><h2 id="linux的多路复用"><a href="#linux的多路复用" class="headerlink" title="linux的多路复用"></a>linux的多路复用</h2><p>一个线程处理多个 IO 流(select/epoll 机制)。<br>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。<br>内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p><h2 id="Redis单线程处理IO请求性能瓶颈主要包括2个方面"><a href="#Redis单线程处理IO请求性能瓶颈主要包括2个方面" class="headerlink" title="Redis单线程处理IO请求性能瓶颈主要包括2个方面"></a>Redis单线程处理IO请求性能瓶颈主要包括2个方面</h2><p>1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：</p><ul><li>操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；</li><li>使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；</li><li>大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；</li><li>淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；</li><li>AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；</li><li>主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li><li>rehash扩容</li></ul><p>2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</p><p>针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p><p>针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis1-数结</title>
      <link href="2020/09/01/redis1-%E6%95%B0%E7%BB%93/"/>
      <url>2020/09/01/redis1-%E6%95%B0%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数结"><a href="#数结" class="headerlink" title="数结"></a>数结</h1><p>使用了一个哈希表来保存所有键值对<br>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p>哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。<br><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/2.jpg" alt="1"></p><h2 id="为什么哈希表操作变慢了？"><a href="#为什么哈希表操作变慢了？" class="headerlink" title="为什么哈希表操作变慢了？"></a>为什么哈希表操作变慢了？</h2><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对应到了同一个哈希桶中。<br>Redis 解决哈希冲突的方式，就是链式哈希。<strong>链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</strong>。</p><p>rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</p><p>使用了两个全局哈希表：类似JDK复制算法<br>哈希表 1 和哈希表 2<br>一开始使用哈希表 1，哈希表 2 没有分配空间。<br>rehash分为三步：<br>    给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；<br>    把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；<br>    释放哈希表 1 的空间。<br>    哈希表 1 留作下一次 rehash 扩容备用<br>问题：大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求</p><p>解决方法：渐进式 rehash<br>第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。</p><p><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/3.jpg" alt="导入"></p><p>对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。</p><h2 id="集合数据操作效率"><a href="#集合数据操作效率" class="headerlink" title="集合数据操作效率"></a>集合数据操作效率</h2><p>第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查</p><p>集合的操作效率和哪些因素相关呢？<br>首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素的操作要比读写所有元素的效率高</p><p>集合类型的底层数据结构主要有 5 种：<strong>整数数组、双向链表、哈希表、压缩列表和跳表</strong>。<br><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/1.jpg" alt="导入"><br>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。<br>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。<br><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/4.jpg" alt="导入"></p><p><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/5.jpg" alt="导入"></p><p>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。</p><p>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免</strong>。</p><p>从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</p><p>统计操作，是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p><p>例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</p><p>Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是 O(N)。这里，我的建议是：用其他命令来替代，例如可以用 SCAN 来代替，避免在 Redis 内部产生费时的全集合遍历操作。当然，我们不能忘了复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。因此，我的建议是：因地制宜地使用 List 类型。例如，既然它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。</p><p>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？</p><p>1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</p><p>2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</p><h2 id="为什么-String-类型内存开销大"><a href="#为什么-String-类型内存开销大" class="headerlink" title="为什么 String 类型内存开销大"></a>为什么 String 类型内存开销大</h2><p>记录实际数据，String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了，有点“喧宾夺主”的意思。</p><p>当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。</p><p>当你保存的数据中包含字符时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图所示：</p><p><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/6.jpg" alt="导入"></p><p>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。<br>len：占 4 个字节，表示 buf 的已用长度。<br>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。<br>除了 SDS 的额外开销(len,alloc)，还有一个来自于 RedisObject 结构体的开销。<br>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址</p><p><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/7.jpg" alt="导入"></p><p>Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。<br>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。<br>一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。<br>字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。</p><p><img src="/2020/09/01/redis1-%E6%95%B0%E7%BB%93/8.jpg" alt="导入"></p><p>因为 10 位数的图片 ID 和图片存储对象 ID 是 Long 类型整数，所以可以直接用 int 编码的 RedisObject 保存。每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了。此时，每个 ID 会使用 16 字节，加起来一共是 32 字节。但是，另外的 32 字节去哪儿了呢？我在第 2 讲中说过，Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节，如下图所示：</p><p>但是，这三个指针只有 24 字节，为什么会占用了 32 字节呢？这就要提到 Redis 使用的内存分配库 jemalloc 了。jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。举个例子。如果你申请 6 字节空间，jemalloc 实际会分配 8 字节空间；如果你申请 24 字节空间，jemalloc 则会分配 32 字节。所以，在我们刚刚说的场景里，dictEntry 结构就占用了 32 字节。好了，到这儿，你应该就能理解，为什么用 String 类型保存图片 ID 和图片存储对象 ID 时需要用 64 个字节了。</p><h1 id="用什么数据结构可以节省内存？"><a href="#用什么数据结构可以节省内存？" class="headerlink" title="用什么数据结构可以节省内存？"></a>用什么数据结构可以节省内存？</h1><p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。<br>prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。<br>len：表示自身长度，4 字节；<br>encoding：表示编码方式，1 字节；<br>content：保存实际数据。</p><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p><p>每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8=14），实际分配 16 字节。Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。这个方案听起来很好，但还存在一个问题：在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在我们的场景中，一个图片 ID 只对应一个图片的存储对象 ID，我们该怎么用集合类型呢？换句话说，在一个键对应一个值（也就是单值键值对）的情况下，我们该怎么用集合类型来保存这种单值键值对呢？</p><h1 id="如何用集合类型保存单值的键值对？"><a href="#如何用集合类型保存单值的键值对？" class="headerlink" title="如何用集合类型保存单值的键值对？"></a>如何用集合类型保存单值的键值对？</h1><p>在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。<br>Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。<br>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。<br>在内存空间的开销上，也许哈希表没有压缩列表高效<br>但是哈希表的查询效率，要比压缩列表高。<br>在对查询效率高的场景中，可以考虑空间换时间</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式全局唯一ID</title>
      <link href="2020/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/"/>
      <url>2020/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中，经常需要使用全局唯一ID查找对应的数据。产生这种ID需要保证系统全局唯一，而且要高性能以及占用相对较少的空间。<br>全局唯一ID在数据库中一般会被设成主键，这样为了保证数据插入时索引的快速建立，还需要保持一个有序的趋势。<br>这样全局唯一ID就需要保证这两个需求：</p><ul><li>全局唯一</li><li>趋势有序<h1 id="全局ID产生的几种方式"><a href="#全局ID产生的几种方式" class="headerlink" title="全局ID产生的几种方式"></a>全局ID产生的几种方式</h1></li></ul><ol><li>数据库自增<br>当服务使用的数据库只有单库单表时，可以利用数据库的auto_increment来生成全局唯一递增ID.</li></ol><p><strong>优势</strong>：<br>简单，无需程序任何附加操作<br>保持定长的增量<br>在单表中能保持唯一性<br><strong>劣势</strong>：<br>高并发下性能不佳，主键产生的性能上限是数据库服务器单机的上限。<br>水平扩展困难，在分布式数据库环境下，无法保证唯一性。</p><ol start="2"><li>UUID<br>一般的语言中会自带<code>UUID</code>的实现，比如Java中UUID方式<code>UUID.randomUUID().toString()</code>，可以通过服务程序本地产生，ID的生成不依赖数据库的实现。</li></ol><p><strong>优势</strong>：<br>本地生成ID，不需要进行远程调用。<br>全局唯一不重复。<br>水平扩展能力非常好。<br><strong>劣势</strong>：<br>ID有<code>128 bits</code>,占用的空间较大，需要存成字符串类型，索引效率极低。<br>生成的ID中没有带<code>Timestamp</code>，无法保证趋势递增</p><ol start="3"><li>Twitter Snowflake<br>产生一个<code>long</code>型的ID，<br>使用其中<code>41bit</code>作为毫秒数，<br><code>10bit</code>作为机器编号，<br><code>12bit</code>作为毫秒内序列号。<br>这个算法单机每秒内理论上最多可以生成<code>1000*(2^12)</code>个，也就是大约<code>400W</code>的ID，完全能满足业务的需求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-4.常见生产问题处理</title>
      <link href="2020/06/15/redis-4-%E5%B8%B8%E8%A7%81%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
      <url>2020/06/15/redis-4-%E5%B8%B8%E8%A7%81%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存和数据库双写一致性问题"><a href="#1-缓存和数据库双写一致性问题" class="headerlink" title="1.缓存和数据库双写一致性问题"></a>1.缓存和数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，还可以再分为<strong>最终一致性</strong>和<strong>强一致性</strong>。数据库和缓存双写，就必然会存在不一致的问题。</p><p>首先要明白<strong>如果对数据有强一致性要求，就不能放缓存</strong>。<br>只能说降低不一致发生的概率，<strong>无法完全避免</strong>。因此，有强一致性要求的数据，不能放缓存。</p><ul><li><strong>采取正确更新策略，先更新数据库，再删缓存。</strong></li><li>其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li></ul><h2 id="2-缓存穿透问题"><a href="#2-缓存穿透问题" class="headerlink" title="2.缓存穿透问题"></a>2.缓存穿透问题</h2><p><font color="#ff0000">缓存和数据库中都没有的数据</font>，而用户不断发起请求(也可能是故意攻击),导致数据库压力过大。</p><ul><li><strong>缓存空值</strong><br>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障）我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过5分钟。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库</li><li><strong>采用布隆过滤器BloomFilter</strong><br>将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力<br>在缓存之前在加一层BloomFilter，在查询的时候先去BloomFilter去查询key是否存在，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库<br>优势：占用内存空间很小，位存储；性能特别高，使用key的hash判断key存不存在</li></ul><h2 id="3-缓存击穿问题"><a href="#3-缓存击穿问题" class="headerlink" title="3.缓存击穿问题"></a>3.缓存击穿问题</h2><p><font color="#ff0000">缓存中没有但数据库中有的数据</font>（一般是缓存时间到期），并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大</p><ul><li>利用互斥锁:    缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试,等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</li><li>采用异步更新策略:    无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</li><li>设置热点数据永不过期</li></ul><h2 id="4-缓存雪崩问题"><a href="#4-缓存雪崩问题" class="headerlink" title="4.缓存雪崩问题"></a>4.缓存雪崩问题</h2><p><font color="#ff0000">缓存同一时间大面积的失效</font>，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。(同时缓存击穿数量大)</p><ul><li>给缓存的失效时间，<strong>加上一个随机值</strong>，避免集体失效。</li><li>使用<strong>互斥锁</strong>，但是该方案吞吐量明显下降了。</li><li><strong>双缓存</strong>。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。</li><li><strong>服务降级</strong>。非核心数据先返回空如商品图片</li><li>业务系统中实现<strong>服务熔断或请求限流</strong>机制:业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。或者前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库(保护数据库防止宕机)</li><li>搭建高可靠集群<br>然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</li></ul><h2 id="5-如何解决-Redis-的并发竞争-Key-问题"><a href="#5-如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="5.如何解决 Redis 的并发竞争 Key 问题"></a>5.如何解决 Redis 的并发竞争 Key 问题</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。<br>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p><p>可以利用 Redis 事务机制,但是不好,因为在生产环境，基本都是 Redis 集群环境，做了数据分片操作。<br>你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。<br><strong>正确:</strong></p><ul><li>如果对这个 Key 操作，不要求顺序</li></ul><p><strong>利用setnx实现分布式锁</strong>，抢到锁就做 set 操作即可。</p><ul><li>如果对这个 Key 操作，要求顺序<br>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。<br>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。<br>假设时间戳如下：系统A key 1 {valueA 3:00}    系统B key 1 {valueB 3:05}    系统C key 1 {valueC 3:10}<br>假设系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</li><li><strong>利用队列，将 set 方法变成串行访问</strong></li><li><strong>客户端角度</strong>:证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</li></ul><h2 id="6-key是如何寻址的"><a href="#6-key是如何寻址的" class="headerlink" title="6.key是如何寻址的"></a>6.key是如何寻址的</h2><p><strong>背景:</strong><br>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：<br>redisDb.id 存储着 redis 数据库以整数表示的号码。<br>redisDb.dict 存储着该库所有的键值对数据。<br>redisDb.expires 保存着每一个键的过期时间。<br>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。<br>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。<br>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p><p><strong>寻址 key 的步骤</strong><br>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。<br>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。<br>计算哈希表，根据当前字典与 key 进行哈希值的计算。<br>根据哈希值与当前字典计算哈希表的索引值。<br>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。<br>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</p><h2 id="7-Redis-的过期策略以及内存淘汰机制"><a href="#7-Redis-的过期策略以及内存淘汰机制" class="headerlink" title="7.Redis 的过期策略以及内存淘汰机制"></a>7.Redis 的过期策略以及内存淘汰机制</h2><p>比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么？<br>还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><ul><li><strong>Redis 采用的是定期删除+惰性删除策略。</strong></li></ul><h3 id="7-1为什么不用定时删除策略"><a href="#7-1为什么不用定时删除策略" class="headerlink" title="7.1为什么不用定时删除策略?"></a>7.1为什么不用定时删除策略?</h3><p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分<br>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。<strong>消耗 CPU 资源。</strong></p><h3 id="7-2定期删除-惰性删除是如何工作"><a href="#7-2定期删除-惰性删除是如何工作" class="headerlink" title="7.2定期删除+惰性删除是如何工作"></a>7.2定期删除+惰性删除是如何工作</h3><p><strong>定期删除</strong>:    Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。<br>需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。<br>因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。<br><strong>惰性删除</strong>:    也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，过期了此时就会删除。</p><h3 id="7-3采用定期删除-惰性删除就没其他问题了么"><a href="#7-3采用定期删除-惰性删除就没其他问题了么" class="headerlink" title="7.3采用定期删除+惰性删除就没其他问题了么?"></a>7.3采用定期删除+惰性删除就没其他问题了么?</h3><p>不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。<br>在 redis.conf 中有一行配置：<br><code>maxmemory-policy volatile-lru</code></p><p>该配置就是配内存淘汰策略的：</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>◆<code>noeviction</code>：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。<br>◆<code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。<br>◆<code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。<br>◆<code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。<br>◆<code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。<br>◆<code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。<br>◆<code>volatile-lfu</code><br>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么<code>volatile-lru，volatile-random</code>和 <code>volatile-ttl</code> 策略的行为，和 noeviction(不删除) 基本上一致。</p><h2 id="8-缓存污染"><a href="#8-缓存污染" class="headerlink" title="8.缓存污染"></a>8.缓存污染</h2><p>缓存污染问题指的是留存在缓存中的数据，实际不会被再次访问了，但是又占据了缓存空间。如果这样的数据体量很大，甚至占满了缓存，每次有新数据写入缓存时，还需要把这些数据逐步淘汰出缓存，就会增加缓存操作的时间开销。<br>识别出这些只访问一次或是访问次数很少的数据，在淘汰数据时，优先把它们筛选出来并淘汰掉<br>LRU 策略时，由于 LRU 策略只考虑数据的访问时效，对于只访问一次的数据来说，LRU 策略无法很快将其筛选出来。<br>而 LFU 策略在 LRU 策略基础上进行了优化，在筛选数据时，首先会筛选并淘汰访问次数少的数据，然后针对访问次数相同的数据，再筛选并淘汰访问时间最久远的数据。<br>LRU 和 LFU 两个策略关注的数据访问特征各有侧重，LRU 策略更加关注数据的时效性，而 LFU 策略更加关注数据的访问频次。通常情况下，实际应用的负载具有较好的时间局部性，所以 LRU 策略的应用会更加广泛。但是，在扫描式查询的应用场景中，LFU 策略就可以很好地应对缓存污染问题了，建议你优先使用。</p><h2 id="9-Redis如何做内存优化"><a href="#9-Redis如何做内存优化" class="headerlink" title="9. Redis如何做内存优化"></a>9. Redis如何做内存优化</h2><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。<br>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><h2 id="10-Redis回收进程如何工作的"><a href="#10-Redis回收进程如何工作的" class="headerlink" title="10. Redis回收进程如何工作的"></a>10. Redis回收进程如何工作的</h2><p>一个客户端运行了新的命令，添加了新的数据。<br>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。<br>一个新的命令被执行，等等。<br>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h2 id="11-Redis集群方案应该怎么做？都有哪些方案？"><a href="#11-Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="11. Redis集群方案应该怎么做？都有哪些方案？"></a>11. Redis集群方案应该怎么做？都有哪些方案？</h2><p>1.codis。<br>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。<br>2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。<br>3.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思-2异位词分组与质数</title>
      <link href="2020/06/01/%E6%9C%89%E6%84%8F%E6%80%9D-2%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%B8%8E%E8%B4%A8%E6%95%B0/"/>
      <url>2020/06/01/%E6%9C%89%E6%84%8F%E6%80%9D-2%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%B8%8E%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br>示例:<br>输入:<code> [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code><br>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解题思路<br>算术基本定理<br>**任何一个大于1的自然数N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积  !  !  !  !**牛逼<br>[a, z]Unicode编码 - 97=[0, 25] 对应26个质数,或者减’a’。每字母代表一个质数,质数的乘积表示字符串<br>乘法交换律忽略字母顺序。算术基本定理保证不同质数 或 相同质数不同个数，乘积唯一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">int[] prime = new int[] &#123; 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,</span><br><span class="line">83, 89, 97, 101 &#125;;  //26个质数</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">long sum = 1;  //因为乘积怕太大了就用long</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">sum *= prime[strs[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list = map.getOrDefault(sum + <span class="string">&quot;&quot;</span>, new ArrayList&lt;String&gt;()); //根据key去list,如果没有新建</span><br><span class="line">list.add(strs[i]);</span><br><span class="line">map.put(sum + <span class="string">&quot;&quot;</span>, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他解法:</p><ul><li><p>暴力:</p><p>所有字符串都排序,排完了放到map<br>key是排序后的字符串,value是放之前的string集合…<br>class Solution {<br>  public List&lt;List<String>&gt; groupAnagrams(String[] strs) {</String></p><pre><code>  Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();  for (String str : strs) &#123;      char[] array = str.toCharArray();      Arrays.sort(array);      String key = new String(array);      List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());      list.add(str);      map.put(key, list);  &#125;  return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</code></pre><p>  }<br>}</p></li></ul><p>时间复杂度：O(nk log k)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。<br>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><ul><li>计数</li></ul><p>两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">int[] counts = new int[26];</span><br><span class="line">int length = str.length();</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">counts[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++; //字符串遍历,每个字符出现一次就在对应位置加一</span><br><span class="line">&#125;</span><br><span class="line">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (counts[i] != 0) &#123;</span><br><span class="line">sb.append((char) (<span class="string">&#x27;a&#x27;</span> + i));  //如果这个位置有字母,记录当前这个位置对应的字母</span><br><span class="line">sb.append(counts[i]);       //counts[i]  这个字母在字符串出现的次数,sb就成了 :l2i1n1g1这种</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String key = sb.toString();</span><br><span class="line">List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());</span><br><span class="line">list.add(str);</span><br><span class="line">map.put(key, list);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">return</span> new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思-0两数交换与异或</title>
      <link href="2020/05/25/%E6%9C%89%E6%84%8F%E6%80%9D-0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%BC%82%E6%88%96/"/>
      <url>2020/05/25/%E6%9C%89%E6%84%8F%E6%80%9D-0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h1 id="两数交换不借助第三数"><a href="#两数交换不借助第三数" class="headerlink" title="两数交换不借助第三数"></a>两数交换不借助第三数</h1><p>利用数学计算mdzz……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void swapTwo()&#123;</span><br><span class="line">    int a &#x3D; 4;</span><br><span class="line">    int b &#x3D; 5;</span><br><span class="line">    a&#x3D;a+b;</span><br><span class="line">    b&#x3D;a-b;</span><br><span class="line">    a&#x3D;a-b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>利用异或运算我是智障</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">swapThree</span></span>()&#123;</span><br><span class="line">        int a = 4;</span><br><span class="line">        int b = 5;</span><br><span class="line">        a = a ^ b; // 0101 ^ 0100 ===&gt; 0001，此时a的值为1</span><br><span class="line">        b = a ^ b; // 0001 ^ 0100 ===&gt; 0101，此时b的值为5</span><br><span class="line">        a = a ^ b; // 0001 ^ 0101 ===&gt; 0100，此时a的值为4</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>+a); //a:5</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+b); //a:4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的异或</p><h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int hammingWeight(int n) &#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">      <span class="keyword">for</span>(int i=0;i&lt;32;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>((n&amp;1)==1) count++;</span><br><span class="line">          n = n&gt;&gt;1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p>实现函数<code>double Power(double base, int exponent)</code>，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。<br>输入: 2.00000, 10<br>输出: 1024.00000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double myPow(double x, int n) &#123;</span><br><span class="line">       <span class="keyword">if</span>(n == 0) <span class="built_in">return</span> 1;</span><br><span class="line">       <span class="keyword">if</span>(n == 1) <span class="built_in">return</span> x;</span><br><span class="line">       <span class="keyword">if</span>(n == -1) <span class="built_in">return</span> 1/x;</span><br><span class="line">       long m = n;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;0)&#123;</span><br><span class="line">           x=1/x;</span><br><span class="line">           m = -m;</span><br><span class="line">       &#125;</span><br><span class="line">       Double num = 1.0;</span><br><span class="line">       <span class="keyword">while</span>(m&gt;0)&#123;</span><br><span class="line">           <span class="keyword">if</span>((m&amp;1) == 1) num*=x;</span><br><span class="line">           m = m&gt;&gt;1;</span><br><span class="line">           x*=x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思-1剪绳子与数论</title>
      <link href="2020/05/14/%E6%9C%89%E6%84%8F%E6%80%9D-1%E5%89%AA%E7%BB%B3%E5%AD%90%E4%B8%8E%E6%95%B0%E8%AE%BA/"/>
      <url>2020/05/14/%E6%9C%89%E6%84%8F%E6%80%9D-1%E5%89%AA%E7%BB%B3%E5%AD%90%E4%B8%8E%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] </code>可能的<strong>最大乘积</strong>是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><ul><li>数论</li></ul><p><strong>任何大于1的数都可由2和3相加组成</strong>（根据奇偶证明）<br>因为<code>2*2=1*4</code>，<code>2*3&gt;1*5</code>, 所以将数字拆成2和3，能得到的积最大<br>因为2<em>2</em>2&lt;3*3, **所以3越多积越大 时间复杂度O(n/3)**，用幂函数可以达到O(log(n/3)), 因为n不大，所以提升意义不大，我就没用。 空间复杂度常数复杂度O(1)</p><p>简单的数论题，<strong>DP并不是最优解，套用DP谁都会，而数论时间复杂度空间复杂度都远胜DP</strong><br>如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1<br>如果 n == 4，返回4<br>如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段<br>以上2和3可以合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int cuttingRope(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1 || n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        if(n&#x3D;&#x3D;3)</span><br><span class="line">            return 2;</span><br><span class="line">        int num &#x3D; 1;</span><br><span class="line">        while(n&gt;4)&#123;</span><br><span class="line">            num*&#x3D;3;</span><br><span class="line">            n-&#x3D;3;</span><br><span class="line">        &#125;</span><br><span class="line">        return num*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>卑微的动归<br>用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1<br>我们先把绳子剪掉第一段（长度为j），只剪掉长度为1，乘积没用，所以从长度为2开始剪<br>剪了第一段后，剩下<code>(i - j)</code>长度可以剪也可以不剪。如果不剪的话长度乘积即为<code>j * (i - j)</code>；<br>如果剪的话长度乘积即为<code>j * dp[i - j]</code>。取两者最大值<code>max(j * (i - j), j * dp[i - j])</code><br>第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为<br><code>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int cuttingRope(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        <span class="keyword">for</span>(int i = 3; i &lt; n + 1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = 2; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-3.持久化,集群模式</title>
      <link href="2020/05/13/redis-3-%E6%8C%81%E4%B9%85%E5%8C%96-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/05/13/redis-3-%E6%8C%81%E4%B9%85%E5%8C%96-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一-持久化"><a href="#一-持久化" class="headerlink" title="一.持久化"></a>一.持久化</h1><p>Redis的所有数据都是保存在内存中，redis崩掉的话，会丢失。Redis持久化就是把数据保存到磁盘上（可永久保存的存储设备中），以便数据恢复。</p><h2 id="1-RDB-快照（snapshot）"><a href="#1-RDB-快照（snapshot）" class="headerlink" title="1.RDB 快照（snapshot）"></a>1.RDB 快照（snapshot）</h2><p><strong>将存在于某一时刻的所有数据都写入到硬盘中。</strong></p><ol><li>原理:</li></ol><p><strong>RDB是Redis默认的持久化方案</strong>。<strong>在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个</strong><code>dump.rdb</code><strong>文件</strong>，<strong>Redis重启会通过加载</strong><code>dump.rdb</code><strong>文件恢复数据</strong><br>可以对 Redis 进行设置， “N 秒内至少有 M 个改动”时， 自动保存。(配置:save n m,多个条件时满足一个就会执行BGSAVE—&gt;Redis的服务器周期性操作函数<code>serverCron</code>默认<strong>每隔100毫秒就会执行一次</strong>)<br>你也可以通过调用 <code>SAVE</code> 或者 <code>BGSAVE</code>，手动让 Redis 进行数据集保存操作。<br>这种持久化方式被称为快照。该功能可以将某个时间点上的数据库状态保存到一个RDB文件中</p><ol start="2"><li><p>创建:<br><code>SAVE</code>命令:    会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，<strong>服务器不能处理任何命令请求</strong><br><code>BGSAVE</code>命令:        会派生出一个<strong>子进程</strong>，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求(SAVE、BGSAVE除外,这俩会被拒绝)</p></li><li><p>载入:<br>Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件</p></li></ol><p><strong>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</strong><br>创建RDB文件的实际工作由<code>rdb.c/rdbSave</code>函数完成，载入RDB文件的实际工作由<code>rdb.c/rdbLoad</code>函数完成</p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p><ul><li>Redis 创建一个子进程。</li><li>子进程将数据集写入到一个临时快照文件中。</li><li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。<br>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</li></ul><ol start="4"><li>优点:<br>它保存了某个时间点的数据集，非常<strong>适用于数据集的备份</strong>。<br>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），<strong>非常适用于灾难恢复</strong>。<br>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li></ol><p><strong>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</strong></p><ol start="5"><li>缺点:<br>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。<br>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，<strong>fork 的过程是非常耗时的</strong>，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li></ol><hr><h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h2><p><strong>将Redis执行过的所有指令记录下来</strong>（读操作不记录），<strong>只许追加文件，但不可以改写文件，redis启动之初会读取该文件重新构建数据</strong>(默认关闭)</p><ol><li><p>原理:<br>a. 打开AOF:appendonly  YES<br>b. Redis 创建一个子进程。<br>c. 子进程开始将新 AOF 文件的内容写入到临时文件。<br>d. 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>e. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。<br>f. 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p></li><li><p>AOF文件的载入与数据还原:<br>1）创建一个不带网络连接的伪客户端：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样<br>2）从AOF文件中分析并读取出一条写命令<br>3）使用伪客户端执行被读出的写命令<br>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止</p></li><li><p>优点:<br>使用默认的每秒 <code>fsync</code> 策略，Redis 的性能依然很好(<code>fsync</code> 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。<br>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 <code>redis-check-aof </code>工具修复这些问题。<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：<strong>重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的</strong>。<br>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</p></li><li><p>缺点:<br>对于相同的数据集来说，<strong>AOF 文件的体积通常要大于 RDB 文件的体积</strong>。<br>根据所使用的 <code>fsync</code> 策略，<strong>AOF 的速度可能会慢于快照</strong>。在一般情况下，每秒 <code>fsync</code> 的性能依然非常高，而关闭 <code>fsync</code> 可以让** AOF 的速度和快照一样快<strong>，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，</strong>快照可以提供更有保证的最大延迟时间**（latency）。</p></li></ol><p><strong>因为AOF文件的更新频率通常比RDB文件的更新频率高</strong>，所以：<br><strong>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态</strong><br><strong>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态</strong><br><img src="/2020/05/13/redis-3-%E6%8C%81%E4%B9%85%E5%8C%96-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1.png" alt="1"></p><hr><h1 id="redis三种搭建模式"><a href="#redis三种搭建模式" class="headerlink" title="redis三种搭建模式"></a>redis三种搭建模式</h1><h2 id="一-主从"><a href="#一-主从" class="headerlink" title="一.主从"></a>一.主从</h2><ol><li><p><strong>主从复制过程</strong>:<br>从服务器连接主服务器，发送 <code>SYNC</code> 命令；<br>主服务器接收到 <code>SYNC</code> 命名后，开始执行 <code>BGSAVE</code> 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；<br>主服务器 <code>BGSAVE</code> 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；<br>果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在<strong>连接成功之后，一次完全同步将被自动执行</strong></p></li><li><p><strong>优点</strong><br>1、同一个Master可以同步多个Slaves。<br>2、Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力(<strong>图结构</strong>)<br>3、<strong>Slave可以设置只读服务器</strong>，写服务仍然必须由Master来完成。<br>6、Master可以将<strong>数据保存操作交给Slaves完成</strong>，从而避免了在Master中要有独立的进程来完成此操作。<br>7、支持主从复制，主机会自动将数据同步到从机，可以进行<strong>读写分离</strong>。</p></li><li><p><strong>缺点</strong>:<br>1、不具备<strong>自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败<br>2、需要<strong>手动主从切换</strong><br>3、主从切换后还会有<strong>数据不一致的问题</strong>(部分数据从服务器未同步)<br>4、较难支持<strong>在线扩容</strong></p></li></ol><h2 id="二-哨兵"><a href="#二-哨兵" class="headerlink" title="二.哨兵"></a>二.哨兵</h2><p><strong>Sentinel模式</strong>  主从模式的升级,主从可以切换，故障可以转移<br>Redis提供了哨兵的命令，<strong>哨兵是一个独立的进程</strong>，独立运行。</p><ol><li><p>原理:<br>是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。<br>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。<br><img src="/2020/05/13/redis-3-%E6%8C%81%E4%B9%85%E5%8C%96-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/2.png" alt="2"><br>Spring进行配置RedisTemplate里面有用</p></li><li><p>故障迁移<br>由哨兵节点处理,不同于集群节点的从节点自己处理<br>主观下线:        一个哨兵主观的认为主服务器不可用,系统并不会马上进行failover过程<br>客观下线:        经过个哨兵投票认为不可用,投票的结果由一个哨兵发起，进行failover操作<br>先leader选举:客观下线时发起选举,优先级排序,相同的选迁移量offset大的<br>设置为主节点–&gt;设置从节点为新的主节点的复制—&gt;将旧的主节点变为新的主节点的复制 </p></li><li><p>哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的<br> 1.首先主节点的信息是配置在哨兵(Sentinel)的配置文件中<br> 2.哨兵节点会和配置的主节点建立起两条连接命令连接和订阅连接<br> 3.哨兵会通过命令连接每10s发送一次INFO命令，通过INFO命令，主节点会返回自己的run_id和自己的从节点信息<br> 4.哨兵会对这些从节点也建立两条连接命令连接和订阅连接<br> 5.哨兵通过命令连接向从节点发送INFO命令，获取到他的一些信息 run_id/role/从服务器的复制偏移量 offset等<br> 6.因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，命令连接和订阅连接</p><pre><code> a. 通过命令连接向服务器的_sentinel:hello频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等 b. 通过订阅连接对服务器的_sentinel:hello频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到 c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来 d. 向观察到的其他的哨兵节点建立命令连接----没有订阅连接</code></pre></li></ol><p>优点:同主从<br>缺点:仍是扩容</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="/2020/05/13/redis-3-%E6%8C%81%E4%B9%85%E5%8C%96-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/3.png" alt="3"><br>Redis服务器节点，两两都相连，只要客户端连接到其中一台Redis服务器就可以对其他Redis服务器进行读写操作<br><strong>解决单机Redis容量有限的问题</strong>，将Redis的数据根据一定的规则分配到多台机器。<br>根据官方推荐 集群部署至少要3台以上的master节点就需要六个Redis实例(三主三从)</p><ol><li>数据分片<br>Redis集群有16384个哈希槽，Redis会根据节点数量大致均等的将哈希槽映射到不同的节点。<br>当需要在Redis集群中存储一个key-value时，Redis先对key使用CRC16算法算出一个结果，然后把结果对16383求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽（CRC16(key) &amp; 16383）<br>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽(去中心化)，并检查这个槽是否指派给了自己<br>1、如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令<br>2、如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令</li></ol><p><strong>内部也需配置主从，并且内部也是采用哨兵模式:<br>如果有半数节点发现某个异常节点，就把状态改为下线，若果是主节点，则从节点自动向集群广播投票,顶替为主节点，使用老的主节点的槽并向集群通知自己的槽指派,当原先的主节点上线后，则会变为从节点。</strong></p><ol start="2"><li>特点:</li></ol><ul><li> 多个redis节点网络互联，数据共享,节点之间使用轻量协议通信 减少带宽占用 性能很高</li><li> 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用</li><li>不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，</li><li>并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为</li><li> 支持在线增加、删除节点</li><li> 客户端可以连接任何一个主节点进行读写</li><li>自动实现负载均衡与高可用，自动实现failover并且支持动态扩展。</li></ul><p><strong>如果集群中的master没有slave节点，则master挂掉后整个集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态</strong></p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot自动配置原理简析</title>
      <link href="2020/05/10/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/"/>
      <url>2020/05/10/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p>为什么springBoot可以实现自动装配?例如server.port 他就知道这是web容器端口?<br>为什么我没有配置spring.redis.port他就默认6379?<br>为什么有的我刚刚引入maven就可以无需配置直接使用?<br>srpingboot:自动装配—&gt;<font color="#FF0000">  约定大于配置 </font>   </p><hr><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p><font color="#FF0000"><strong>@EnableAutoConfiguration借助@Import的支持，将所有符合自动配置条件的bean定义加载到IoC容器</strong></font> </p><h3 id="先总结"><a href="#先总结" class="headerlink" title="先总结:"></a>先总结:</h3><p>1.核心注解@SpringbootApplication–&gt;@EnableAutoConfiguration–&gt;@Import(<font color="#FF0000">AutoConfigurationImportsSelects</font>.class)</p><p>2.AutoConfigurationImportsSelects的<font color="#FF0000">selectImport</font>方法先判断是否开启AudoConfiguration,根据application.yml中配置的<em>spring.boot.enableautoconfiguration</em>参数,没有则为true</p><p>3.若开启再找到<strong>spring-autoaconfig-matedate.properties</strong>   获取所有支持自动配置类的key value (key为 自动配置类+条件,value为条件类)</p><p>4.调用getAutoConfigurationEntry:获取满足自动配置的实体通过自定义的加载器SpringFactoriesLoader.loadFactoryNames(A.class,ClassLoader)方法扫描所有具有<font color="#FF0000">META-INF/spring.factories</font>的jar包并找到A的类名作为主键<br>返回所有value集合。这一步是找到主键为<font color="#FF0000">EnableAutoConfiguration</font>的configuration<strong>组</strong> </p><p>5.删除重复项以及exclusions排除项 –&gt;@EnableAutoConfiguration注解中的<strong>exclude/excludeName</strong>参数筛选进行筛选</p><p>6.剩下候选的configurations和properties集合传入filter方法进行匹配<br>把候选configurations的list转化为数组 再调用getAutoConfigurationImportFilters获取三个条件过滤器</p><p>8.仍然用SpringFactoryLoader 的loadFactoryNames,这一步主键为<font color="#FF0000">AutoConfigurationImportFilter</font>取到三个Condition:<strong>OnBeanCondition OnClassCondition OnWebApplicationCondition</strong></p><p>9.分别对configurations和properties进行匹配,根据properties中key后面的注解和三个过滤器的match方法进行前提条件校验<br> 注:每个xxAutoConfiguration基本都有两个注解:<br>    <strong>EnableAutoConfingProperties</strong>和前提条件例如<strong>configurationOnClass</strong>(这个可以换成别的条件注解)<br>    前提条件:比如configurationOnClass(A.class)就是在类路径下能找到A类化之后再实例化放到Bean中<br>    EnableAutoConfingProperties(**Properties.class) :将对应的properties类注解为bean<br>    properties类就是定义了一些application.yml中的自动配置的属性,通过@ConfigurationProperties注解确定application.yml中命中的格式,比如RedisAutoProperties就是spring.redis</p><p>10.如果满足条件就会true,否则false,代表跳过,不会自动装配</p><p>11.满足条件的configurations交给spring容器实例化bean</p><hr><h3 id="自动配置选择器-AutoConfigurationImportSelector-源码分析"><a href="#自动配置选择器-AutoConfigurationImportSelector-源码分析" class="headerlink" title="自动配置选择器:AutoConfigurationImportSelector 源码分析"></a>自动配置选择器:AutoConfigurationImportSelector 源码分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="title">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">String</span>[] <span class="function"><span class="title">selectImports</span>(<span class="params">AnnotationMetadata annotationMetadata</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果AutoConfiguration没开,返回&#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将spring-autoconfigure-metadata.properties的键值对配置载入到PropertiesAutoConfigurationMetadata对象中并返回</span></span><br><span class="line">    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">            .loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">    <span class="comment">// 基于各种配置计算需要import的configuration和exclusion</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">            annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断AudoConfiguration是否开启</span></span><br><span class="line">protected boolean <span class="function"><span class="title">isEnabled</span>(<span class="params">AnnotationMetadata metadata</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == AutoConfigurationImportSelector.class) &#123;</span><br><span class="line">        <span class="comment">// 如果配置文件中有&quot;spring.boot.enableautoconfiguration&quot;,返回该字段的值;否则返回true</span></span><br><span class="line">        <span class="keyword">return</span> getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, <span class="built_in">Boolean</span>.class, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,</span><br><span class="line">        AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//......仍是调用isEnabled判断是否开启自动配置</span></span><br><span class="line">    <span class="comment">// 获取注解的属性值</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取所有候选配置类EnableAutoConfiguration,使用SpringFactoriesLoader，查找classpath上所有jar包中</span></span><br><span class="line">    <span class="comment">// META-INF\spring.factories，找出其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration </span></span><br><span class="line">    <span class="comment">// 的属性定义的工厂类名称。虽然参数有annotationMetadata,attributes,但在 AutoConfigurationImportSelector 的</span></span><br><span class="line">    <span class="comment">// 实现 getCandidateConfigurations()中，这两个参数并未使用</span></span><br><span class="line">    <span class="comment">// 从META-INF/spring.factories文件中获取EnableAutoConfiguration所对应的configurations</span></span><br><span class="line">    List&lt;<span class="built_in">String</span>&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 去重,List转Set再转List</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 从注解的exclude/excludeName属性中获取排除项</span></span><br><span class="line">    <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 对于不属于AutoConfiguration的exclude报错</span></span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 从configurations去除exclusions</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 由所有AutoConfigurationImportFilter类的实例再进行一次筛选,滤器检查候选配置类上的注解@ConditionalOnClass，</span></span><br><span class="line">    <span class="comment">//若要求的类在classpath中不存在，则这个候选配置类会被排除掉!!!!此处结合了spring-autoConfig-matedate.properties和spring.factories!!!!</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 现在已经找到所有需要被应用的候选配置类,广播事件把AutoConfigurationImportEvent绑定在所有AutoConfigurationImportListener子类实例上</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 返回(configurations, exclusions)组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">//此处结合了spring-autoConfig-matedate.properties和spring.factories!!configurations:spring.factories取得自动配置类</span></span><br><span class="line"><span class="comment">//autoConfigurationMetadata 从spring-autoConfig-matedate.properties取得,key中含有注解</span></span><br><span class="line">private List&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">filter</span>(<span class="params">List&lt;<span class="built_in">String</span>&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata</span>)</span> &#123;</span><br><span class="line">       <span class="comment">//将所有的待处理类（所有META-INFO/spring.factories里key为EnableAutoConfiguration的配置）从List转成数组</span></span><br><span class="line"><span class="built_in">String</span>[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line">boolean[] skip = <span class="keyword">new</span> boolean[candidates.length];</span><br><span class="line">boolean skipped = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//调用SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader);获取spring.factories中配置的filter</span></span><br><span class="line">  <span class="comment">//key为AutoConfigurationImportFilter的配置类 有OnBeanCondition OnClassCondition OnWebApplicationCondition三个</span></span><br><span class="line"><span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">invokeAwareMethods(filter);</span><br><span class="line">               <span class="comment">//分别调用3个类的match方法返回boolean[] 数组</span></span><br><span class="line">boolean[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line">               <span class="comment">//数组中元素为true表示该EnableAutoConfiguration类合法，为false则表示不合法，需要标记为跳过</span></span><br><span class="line"><span class="keyword">if</span> (!match[i]) &#123;</span><br><span class="line">skip[i] = <span class="literal">true</span>;</span><br><span class="line">candidates[i] = <span class="literal">null</span>;</span><br><span class="line">skipped = <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!skipped) &#123; <span class="keyword">return</span> configurations;&#125;</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!skip[i]) &#123; result.add(candidates[i]); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-autoconfigure-metadata-properties"><a href="#spring-autoconfigure-metadata-properties" class="headerlink" title="spring-autoconfigure-metadata.properties"></a>spring-autoconfigure-metadata.properties</h3><p>代表性节选:近500行<br>key/value形式    key组成:类名+注解名(就是条件)                value:类名全路径<br>作用:如果没有这个配置文件,自动装配默认是配置所有的spring.factories中写的配置,但是好多都没有导入maven怎么配置?<br>所以需要这个properties文件,通过增加条件然后在过滤的时候配置需要配置的,避免找不到jar包的报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration.ConditionalOnClass&#x3D;org.flywaydb.core.Flyway</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration.ConditionalOnClass&#x3D;org.springframework.data.redis.core.RedisOperations</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration.ConditionalOnWebApplication&#x3D;SERVLET</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration.AutoConfigureAfter&#x3D;org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration.AutoConfigureBefore&#x3D;org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration.AutoConfigureAfter&#x3D;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration.AutoConfigureBefore&#x3D;org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration.ConditionalOnClass&#x3D;org.springframework.data.redis.connection.RedisConnectionFactory</span><br></pre></td></tr></table></figure><p>比如第三条:RedisAutoConfiguration表示redis自动配置的配置类路径,ConditionalOnClass表示使用ConditionalOnClass注解<br>value后面表示RedisOperations类———&gt;若要自动装配redis配置既初始化RedisAutoConfiguration中配置的bean需要:在classpath下能找到RedisOperations类的前提下()<br>找到RedisAutoConfiguration类,验证,果然有ConditionalOnClass注解并参数为RedisOperations<br><img src="/2020/05/10/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/2.jpg" alt="1"><br>其他常用注解有:<br>@ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）<br>@ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean）<br>@ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean）<br>@ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean）<br>@ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean）<br>@ConditionalOnNotWebApplication（不是web应用）<br>@AutoConfigureBefore  (在谁知前执行)<br>@AutoConfigureAfter (在谁之后执行)</p><p><strong>@EnableConfigurationProperties注解</strong>:开启配置属性，而它后面的参数是一个ServerProperties类，这就是<font color="#FF0000">习惯优于配置的最终落地点</font>。<br>EnableConfigurationProperties为带有@ConfigurationProperties注解的Bean提供有效的支持。这个注解可以提供一种方便的方式来<br>将带有@ConfigurationProperties注解的类注入为Spring容器的Bean<br>比如默认的redis的自动装配是怎么设置spring.redis.port这种凭啥这么写redis就自动读取了?—&gt;<br>EnableConfigurationProperties   + RedisProperties    +  @ConfigurationProperties(prefix = “spring.redis”)<br><img src="/2020/05/10/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/3.jpg" alt="3"><br>XxxxProperties类的含义是：封装配置文件中相关属性；XxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件。</p><h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories:"></a>spring.factories:</h3><p><strong>该文件它更多是提供一种配置查找的功能支持</strong>，包括了<strong>过滤器,监听器,自动配置类</strong>等的路径(注意每个类型的第一行,就是SpringFactoryLoader 的loadFactoryNames方法的第一个参数,类似主键)<br>自动配置类即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类<br>过滤器就是根据AutoConfigurationImportFilter 取到Condition组:OnBeanCondition OnClassCondition OnWebApplicationCondition<br>160+行,就是springboot可实现的自动配置(\是为了换行之后也能读取)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Initializers初始化</span><br><span class="line">org.springframework.context.ApplicationContextInitializer&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners监听器</span><br><span class="line">org.springframework.context.ApplicationListener&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters过滤器</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line"># Auto Configure自动配置,第一行!!</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">.......................................省略</span><br></pre></td></tr></table></figure><hr><h2 id="练习实现"><a href="#练习实现" class="headerlink" title="练习实现"></a>练习实现</h2><p>添加配置类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.EnvironmentAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvConfig</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getLongValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getStringValue(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.parseLong(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            syso(<span class="string">&quot;字符串转换Long失败：&#123;&#125; = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLongValue(key).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.env = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加自动配置类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(PropertyResolver.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvAutoConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnvConfig <span class="title">envConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EnvConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到自动配置组:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//注意第一行!!!</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class="line">com.oceanpayment.common.config.env.EnvAutoConfig</span><br></pre></td></tr></table></figure><p>这个实战没有建properties,不然就能实现从application.yml中自动读取属性了</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-AOP源码分析</title>
      <link href="2020/04/21/spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2020/04/21/spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>spring一说就aop和ioc,都知道干啥用的,<br>也都知道aop原理的动态代理,一个jdk自带的一个cglib吧<br>这俩代理一个需要实现接口一个不需要<br>但是spring是如何用动态代理做成编制的感觉整成切面的?</p><h1 id="一-注解怎么解析的"><a href="#一-注解怎么解析的" class="headerlink" title="一.注解怎么解析的"></a>一.注解怎么解析的</h1><p>至少表面看就是注解实现的,看看这个注解凭啥</p><p><strong>基础:</strong></p><ol><li>ApplicationContext相关实现类加载bean的时候，会针对所有单例且非懒加载的bean，在构造ApplicationContext的时候就会创建好这些bean，而不会等到使用的时候才去创建。这也就是单例bean默认非懒加载的应用<br>2）BeanPostProcessor的相关使用，所有实现BeanPostProcessor接口的类，在初始化bean的时候都会调用这些类的方法，一般用于在bean初始化前或后对bean做一些修改。而AOP的功能实现正式基于此，在bean初始化后创建针对该bean的proxy，然后返回给用户该proxy<br>3）结合以上两点，被代理后的bean，实际在ApplicationContext构造完成之后就已经被创建完成，getBean()的操作直接从singletonObjects中获取即可</li></ol><p>注解都有对应的解析器，以用来解析该注解的行为。全局搜索之后可发现</p><h2 id="1-aop-aspectj-autoproxy"><a href="#1-aop-aspectj-autoproxy" class="headerlink" title="1.aop:aspectj-autoproxy/"></a>1.<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></h2><p>org.springframework.aop.config.AopNamespaceHandler类中有对应的解析行为，代码如下：注意第六行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">// In 2.0 XSD as well as <span class="keyword">in</span> 2.1 XSD.</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, new ConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, new AspectJAutoProxyBeanDefinitionParser());// 就是该段代码!!!!!!!</span><br><span class="line">registerBeanDefinitionDecorator(<span class="string">&quot;scoped-proxy&quot;</span>, new ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"> </span><br><span class="line">// Only <span class="keyword">in</span> 2.0 XSD: moved to context namespace as of 2.1</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-了解AspectJAutoProxyBeanDefinitionParser对应的行为"><a href="#2-了解AspectJAutoProxyBeanDefinitionParser对应的行为" class="headerlink" title="2.了解AspectJAutoProxyBeanDefinitionParser对应的行为"></a>2.了解AspectJAutoProxyBeanDefinitionParser对应的行为</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">        // 1.注册proxy creator</span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // registerAspectJAnnotationAutoProxyCreatorIfNecessary()</span><br><span class="line">    public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">        // 注册行为主要内容</span><br><span class="line">BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    // registerAspectJAnnotationAutoProxyCreatorIfNecessary()</span><br><span class="line">public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object <span class="built_in">source</span>) &#123;</span><br><span class="line">        // 主要就是为了注册AnnotationAwareAspectJAutoProxyCreator类</span><br><span class="line"><span class="built_in">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, <span class="built_in">source</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    // 注册类相关代码</span><br><span class="line">    private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object <span class="built_in">source</span>) &#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">int requiredPriority = findPriorityForClass(cls);</span><br><span class="line"><span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        // 类似于我们在使用BeanFactory.getBean()时候的操作，生成一个RootBeanDefinition，然后放入map中</span><br><span class="line">RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</span><br><span class="line">beanDefinition.setSource(<span class="built_in">source</span>);</span><br><span class="line">beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line"><span class="built_in">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br><code>AspectJAutoProxyBeanDefinitionParser</code>主要的功能就是将<code>AnnotationAwareAspectJAutoProxyCreator</code>注册到Spring容器中，把bean交给Spring去管。<br> AnnotationAwareAspectJAutoProxyCreator的功能我们大胆猜测一下：应该也就是生成对象的代理类的相关功能，这个我们接下来再看。</p><p>问题：<br>最开始的类AopNamespaceHandler.init()方法是在什么时候被调用的呢？什么时候生效的？这个决定了我们注册到Spring的<code>AnnotationAwareAspectJAutoProxyCreator</code>的生效时间？</p><h2 id="3-分析AnnotationAwareAspectJAutoProxyCreator主要行为"><a href="#3-分析AnnotationAwareAspectJAutoProxyCreator主要行为" class="headerlink" title="3.分析AnnotationAwareAspectJAutoProxyCreator主要行为"></a>3.分析AnnotationAwareAspectJAutoProxyCreator主要行为</h2><pre><code>    通过查看`AnnotationAwareAspectJAutoProxyCreator`的类层次结构，可知，其实现了`BeanPostProcessor`接口，实现类为`AbstractAutoProxyCreator`    类层次结构如下：</code></pre><p><img src="/2020/04/21/spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p><h2 id="4-AbstractAutoProxyCreator主要方法"><a href="#4-AbstractAutoProxyCreator主要方法" class="headerlink" title="4.AbstractAutoProxyCreator主要方法"></a>4.AbstractAutoProxyCreator主要方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   // 主要看这个方法，在bean初始化之后对生产出的bean进行包装</span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != null) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line"><span class="built_in">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   // wrapIfNecessary</span><br><span class="line">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create proxy <span class="keyword">if</span> we have advice.</span><br><span class="line">       // 意思就是如果该类有advice则创建proxy，</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">           // 1.通过方法名也能简单猜测到，这个方法就是把bean包装为proxy的主要方法，</span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">           </span><br><span class="line">           // 2.返回该proxy代替原来的bean</span><br><span class="line"><span class="built_in">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="built_in">return</span> bean;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br> 1）通过<code>AspectJAutoProxyBeanDefinitionParser</code>类将<code>AnnotationAwareAspectJAutoProxyCreator</code>注册到Spring容器中<br> 2）<code>AnnotationAwareAspectJAutoProxyCreator</code>类的<code>postProcessAfterInitialization()</code>方法将所有有advice的bean重新包装成proxy</p><hr><h1 id="二-创建proxy过程分析"><a href="#二-创建proxy过程分析" class="headerlink" title="二.创建proxy过程分析"></a>二.创建proxy过程分析</h1><pre><code>通过之前的代码结构分析，所有的bean在返回给用户使用之前都需要经过`AnnotationAwareAspectJAutoProxyCreator`类的`postProcessAfterInitialization()`方法，而该方法的主要作用也就是将所有拥有advice的bean重新包装为proxy，那么我们接下来直接分析这个包装为proxy的方法即可，看一下bean如何被包装为proxy，proxy在被调用方法时，是具体如何执行的以下是`AbstractAutoProxyCreator.wrapIfNecessary(Object bean, String beanName, Object cacheKey)`中的`createProxy()`代码片段分析</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line">       // 1.创建proxyFactory，proxy的生产主要就是在proxyFactory做的</span><br><span class="line">ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(this);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       // 2.将当前bean适合的advice，重新封装下，封装为Advisor类，然后添加到ProxyFactory中</span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">proxyFactory.addAdvisor(advisor);</span><br><span class="line">&#125;</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line">proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">       // 3.调用getProxy获取bean对应的proxy</span><br><span class="line"><span class="built_in">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-创建何种类型的Proxy？JDKProxy还是CGLIBProxy？"><a href="#1-创建何种类型的Proxy？JDKProxy还是CGLIBProxy？" class="headerlink" title="1.创建何种类型的Proxy？JDKProxy还是CGLIBProxy？"></a>1.创建何种类型的Proxy？JDKProxy还是CGLIBProxy？</h2><pre><code>// getProxy()方法</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line"><span class="built_in">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   // createAopProxy()方法就是决定究竟创建何种类型的proxy</span><br><span class="line">protected final synchronized AopProxy <span class="function"><span class="title">createAopProxy</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (!this.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line">       // 关键方法createAopProxy()</span><br><span class="line"><span class="built_in">return</span> getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   // createAopProxy()</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">       // 1.config.isOptimize()是否使用优化的代理策略，目前使用与CGLIB</span><br><span class="line">       // config.isProxyTargetClass() 是否目标类本身被代理而不是目标类的接口</span><br><span class="line">       // hasNoUserSuppliedProxyInterfaces()是否存在代理接口</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">throw new AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">           // 2.如果目标类是接口或者是代理类，则直接使用JDKproxy</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">           // 3.其他情况则使用CGLIBproxy</span><br><span class="line"><span class="built_in">return</span> new ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-getProxy-方法"><a href="#2-getProxy-方法" class="headerlink" title="2.getProxy()方法"></a>2.getProxy()方法</h2><p>由1）可知，通过createAopProxy()方法来确定具体使用何种类型的Proxy<br>针对于该示例，我们具体使用的为JdkDynamicAopProxy，下面来看下<code>JdkDynamicAopProxy.getProxy()</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable// JdkDynamicAopProxy类结构，由此可知，其实现了InvocationHandler，则必定有invoke方法，来被调用，也就是用户调用bean相关方法时，此invoke()被真正调用</span><br><span class="line">    // getProxy()</span><br><span class="line">    public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating JDK dynamic proxy: target source is &quot;</span> + this.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, <span class="literal">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        </span><br><span class="line">        // JDK proxy 动态代理的标准用法</span><br><span class="line"><span class="built_in">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-invoke-方法"><a href="#3-invoke-方法" class="headerlink" title="3.invoke()方法"></a>3.invoke()方法</h2><p>以上的代码模式可以很明确的看出来，使用了JDK动态代理模式，真正的方法执行在invoke()方法里，下面我们来看下该方法，来看下bean方法如何被代理执行的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = null;</span><br><span class="line">boolean setProxyContext = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">Class&lt;?&gt; targetClass = null;</span><br><span class="line">Object target = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">           // 1.以下的几个判断，主要是为了判断method是否为equals、hashCode等Object的方法</span><br><span class="line"><span class="keyword">if</span> (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">// The target does not implement the equals(Object) method itself.</span><br><span class="line"><span class="built_in">return</span> equals(args[0]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">// The target does not implement the hashCode() method itself.</span><br><span class="line"><span class="built_in">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line"><span class="built_in">return</span> AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">// Service invocations on ProxyConfig with the proxy config...</span><br><span class="line"><span class="built_in">return</span> AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this.advised.exposeProxy) &#123;</span><br><span class="line">// Make invocation available <span class="keyword">if</span> necessary.</span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// May be null. Get as late as possible to minimize the time we <span class="string">&quot;own&quot;</span> the target,</span><br><span class="line">// <span class="keyword">in</span> <span class="keyword">case</span> it comes from a pool.</span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line"><span class="keyword">if</span> (target != null) &#123;</span><br><span class="line">targetClass = target.getClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.获取当前bean被拦截方法链表</span><br><span class="line">List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">// 3.如果为空，则直接调用target的method</span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line">           // 4.不为空，则逐一调用chain中的每一个拦截方法的proceed</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">// We need to create a method invocation...</span><br><span class="line">invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">// Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-拦截方法真正被执行调用invocation-proceed"><a href="#4-拦截方法真正被执行调用invocation-proceed" class="headerlink" title="4.拦截方法真正被执行调用invocation.proceed()"></a>4.拦截方法真正被执行调用invocation.proceed()</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">//We start with an index of -1 and increment early.</span><br><span class="line"><span class="keyword">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line"><span class="built_in">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">// Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">// been evaluated and found to match.</span><br><span class="line">InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123;</span><br><span class="line"><span class="built_in">return</span> dm.interceptor.invoke(this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">// Dynamic matching failed.</span><br><span class="line">// Skip this interceptor and invoke the next <span class="keyword">in</span> the chain.</span><br><span class="line"><span class="built_in">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">// It<span class="string">&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line"><span class="string">// been evaluated statically before this object was constructed.</span></span><br><span class="line"><span class="string">return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><pre><code>总结4：依次遍历拦截器链的每个元素，然后调用其实现，将真正调用工作委托给各个增强器</code></pre><hr><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>简单的说:</strong><br>实际就是为bean创建一个proxy，JDKproxy或者CGLIBproxy，然后在调用bean的方法时，会通过proxy来调用bean方法<br>    重点过程可分为：<br>    1）通过``类将<code>AnnotationAwareAspectJAutoProxyCreator</code>注册到Spring容器中<br>    2）<code>AnnotationAwareAspectJAutoProxyCreator</code>类的<code>postProcessAfterInitialization()</code>方法将所有有advice的bean重新包装成proxy<br>    3）调用bean方法时通过proxy来调用，proxy依次调用增强器的相关方法，来实现方法切入</p><p><strong>稍微墨迹点:</strong><br>AopNamespaceHandler 拦截注解<br>在inti里面创建AspectJAutoProxyBeanDefinitionParser<br>他里面有创建AnnotationAwareAspectJAutoProxyCreator,里面的postProcessAfterInitialization,将所有有advice的bean重新包装成proxy,主要通过createProxy方法<br>先创建创建proxyFactory,然后找到bean适合的advice，重新封装下，封装为Advisor类，然后添加到ProxyFactory中<br>调用proxyFactory.getProxy获取bean对应的proxy<br>getProxy方法判断没有接口或者config.isOptimize()方法开启了配置就用cglib代理<br>否则用jdk代理</p><p>1.代理由proxyFactory生成<br>2.bean封装成advice添加到proxyFactroy中<br>3.<code>config.isOptimize()</code>是否使用优化的代理策略，目前使用与CGLIB // config.isProxyTargetClass() 是否目标类本身被代理而不是目标类的接口 // <code>hasNoUserSuppliedProxyInterfaces()</code>是否存在代理接口<br>4.是接口类型的为jdk代理，其他是cglib代理<br>5.jdk代理调用invoke方法，去除equals、hashcode等object方法<br>6.jdk代理获取当前bean被拦截方法链表chain<br>7.chain为空直接反射调用target的method<br>8.chain不为空,则逐一调用chain中的每一个拦截方法的proceed</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构6-哈希表</title>
      <link href="2020/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>2020/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>问题</strong>:Word 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”<br>常用的英文单词有 20 万个左右，假设平均长度是 10 个字母，单词平均占用 10 个字节的内存空间，共约占 2MB ，顶天20MB。这个大小完全可以放在内存里面。<br>可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><p>学习散列表之前要明确什么是<code>hash算法</code>(算法)、<code>hash函数</code>(关系式)、<code>hash table</code>(结构),<code>Map</code>(k-&gt;v的数据类型)<br>最终拓展HashMap(下次再说)</p><h1 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h1><p>一类算法的统称: 通过把输入值切碎,转换成固定长度的输出值<br>就是为了区分输入数据的<br>常见的有<code>MD5</code>、<code>SHA1</code>  (base64不是hash)</p><h2 id="有啥用"><a href="#有啥用" class="headerlink" title="有啥用?"></a>有啥用?</h2><ol><li>文件校验<br>文件校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，不能防止对数据的恶意破坏。<br>MD5 是眼下应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。</li><li> 数字签名<br>Hash 算法也是现代password体系中的一个重要组成部分。因为非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称”数字摘要”进行数字签名，在统计上能够觉得与对文件本身进行数字签名是等效的。</li><li>鉴权协议<br>例如以下的鉴权协议又被称作挑战–认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</li><li><strong>数据结构领域</strong><br>通常还可用作快速查找。根据Hash函数实现哈希表也叫散列表(Hash Table) 。这种结构可以实现对数据进行快速的「<strong>存</strong>」和「<strong>取</strong>」。</li><li>分布式中的应用:负载均衡、数据分片、分布式存储</li></ol><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>散列表用的是 <strong>数组</strong> 支持按照下标随机访问数据的特性，<br>设定的Hash函数 - H(key) 和处理冲突的方法，将一组关键字映象 到一个<font color="#ff000000"><strong>有限的连续的地址集（区间）</strong></font>上，并以关键字在地址集中的象 作为记录在表中的存储位置，<br>这样的<strong>映射表</strong>便称为Hash表。</p><h2 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h2><p>函数f(x)就是表达式,hash函数就是确定表达<strong>存储位置和关键字的关系</strong><br>哈希函数是一个关系，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在<strong>表长允许的范围之内</strong>即可。<br>对不同的关键字可能得到同一哈希地址，即key1≠key2，而f(key1)=f(key2) ，这种现象称为「<code>冲突(collision)</code>」。<br>冲突只能尽量地少，而不能完全避免—<em>常说的hashcode相等未必equals,但是equals一定hashcode相等</em></p><h3 id="常见hash函数"><a href="#常见hash函数" class="headerlink" title="常见hash函数:"></a>常见hash函数:</h3><p>不同的情况采用不同的Hash函数，通常要考虑的因素有：</p><ul><li><strong>Hash函数 执行的时间。</strong></li><li>关键字 的长度。</li><li>Hash表 的大小。</li><li><strong>关键字 的分布情况。</strong></li><li>记录 的查找频率。</li><li><strong>从哈希值不能反向推导出原始数据</strong></li></ul><ol><li>直接寻址法：<br>f(k)=k 或者f(k)=a∗k+b<br>特点：由于直接地址法相当于有多少个关键字就必须有多少个相应地址去对应，不会产生冲突，但是费空间,很少使用这种构造。</li><li>平方取中法：<br>先求出关键字内部编码的平方值，然后按需要取平方值的中间几位作为哈希地址。较常用</li><li>取余法<br>f(k)=k mod p ， p&lt;=m<br>常用简单</li></ol><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><ol><li>开放定址法：<br>Hi=(H(key)+di)modm，i=1,2,…,k(k≤m−1)<br>H(key) 为哈希函数；m 为哈希表表长；<br>di 为增量序列，有3种取法：<br>di=1,2,3,…,m−1，称为线性探测再散列；<br>di=12,−12,22,−22,32,…,±k2，(k≤m2)，称为二次探测再散列；<br>di=伪随机数序列，称为伪随机探测再散列；</li><li>再次哈希</li><li>链地址法：<br>将所有关键字为同义词的记录存储在同一线性表中。即在Hash 出来的哈希地址中不直接存Key ，而是存储一个Key 的链表 ，当发生冲突 时，将同义的Key 加入链表。<br><img src="/2020/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-%E5%93%88%E5%B8%8C%E8%A1%A8/1.png" alt="1"></li></ol><hr><h1 id="HashMap简单延伸"><a href="#HashMap简单延伸" class="headerlink" title="HashMap简单延伸:"></a>HashMap简单延伸:</h1><p>Java 这个高级程序设计语言中一个数据类型<code>Map</code>的实现<code>HashMap</code>，它利用了哈希表这个数据结构但它不是哈希表本身，它就是它自己 - <code>HashMap</code>类型。所以，我们再看一次<code>HashMap</code>父接口<code>Map</code>的JavaDoc描述： “<em>An object that maps keys to values.</em> ”，即“<code>Map</code>是一个键值对对象”。<br><code>Hash</code>表 是一种逻辑数据结构，HashMap是Java中的一种数据类型，它通过代码实现了<code>Hash</code>表 这种数据结构，并利用此结构实现了<code>Map</code>的功能。去除<code>value</code>部分只看<code>key</code>部分就是一个Hash表 了。</p><p><code>HashMap</code>是基于数组来实现哈希表的，数组就好比内存储空间，数组的index就好比内存的地址。<br><code>HashMap</code>中的每个记录就是数组中存储的一个<code>Entry&lt;K, V&gt;</code>对象(链)。<br><code>HashMap</code>的哈希函数为 <code>f(key) = key.hashCode() &amp; (table.length - 1)</code>;，这里简化了<code>hashCode</code>的优化部分，后面会继续说。<br><code>HashMap</code>冲突方法是：链地址法，即每个数组位置上(称为bucket)存放的实际上都是一个<code>Entry</code>链而不是单个对象。这表现在<code>Entry</code>对象都有一个属性<code>next</code>来指向链表的下一个<code>Entry</code>。<br><code>HashMap</code>的装填因子：默认为<code>0.75</code>。<br>基本上<code>HashMap</code>就像上图那样…..</p><p>DK1.8之前，<code>HashMap</code>底层采用数组+链表实现<br>JDK1.8之后HashMap存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树<br>问题:为什么用红黑树,用跳表不行吗?待解决<br><code>hashmap</code>中的元素个数超过数组大小<code>*loadFactor</code>时，就会进行数组扩容，<code>loadFactor</code>的默认值为0.75，<br>而这是一个非常消耗性能的操作，所以如果我们已经预知<code>hashmap</code>中元素的个数，那么预设元素的个数能够有效的提高<code>hashmap</code>的性能。</p><p>后续单独分析hashMap…….</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ有啥用怎么用</title>
      <link href="2020/04/04/RabbitMQ%E6%9C%89%E5%95%A5%E7%94%A8%E6%80%8E%E4%B9%88%E7%94%A8/"/>
      <url>2020/04/04/RabbitMQ%E6%9C%89%E5%95%A5%E7%94%A8%E6%80%8E%E4%B9%88%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="有啥用"><a href="#有啥用" class="headerlink" title="有啥用:"></a>有啥用:</h1><ol><li><p>高并发下的异步业务需求<br>登录后发送短信同时发送邮件<br>登录-短信-邮件,串行的情景是要全部执行完页面响应,非人类<br>现在登录后直接响应,短信以及邮件数据有mq保存处理<br>问题:异步为什么不使用多线程—-高并发下多线程开销大,且不安全,主服务器用来处理请求,消息队列放在其他服务器,架构层面能解决的问题不需要增加语言层面的负担,尤其是限制滥用多线程….稳定性,宕机后使用中间件数据能保存写入的程序</p></li><li><p>解耦<br>A系统有一份数据需要推送多个系统<br>B系统需求变化推送时间段要改,新来个系统叫C也要这份数据 A自己改非人类<br>现在都写入mq,谁要什么时候要自己整,用过再删,<br>A系统数据调用B系统,B宕机怎么办,或者响应慢,因为低优先级服务影响到高优先级服务,垃圾<br>签到领积分,订单减库存都是类似的,用户关心的是签到能立刻成功,积分表面加了就行,下单立刻成功,库存和我没鸡毛关系,或者说用户对积分和库存有时间容忍度<br>所以签到和积分两个服务需要解耦,订单和库存系统需要解耦,两个系统之间不再直接交互,而是通过消息中间件<br>问题:mq挂了多个系统都没数据一脸懵逼,</p></li><li><p>削峰<br>双十一12.00并发请求*&amp;%    *&amp;^%,服务器炸了<br>加入mq,订单慢慢从mq中生成,一秒生不成两秒十秒不着急,都该睡了</p></li></ol><p>问题:宕机,重复消费,数据丢失,消息顺序,操作原子性(A的成功需要bcd消费成功,A说已经成功了,bc消费,d消费失败,在业务逻辑中是失败的)</p><p>总结类似用空间缓冲转换及时响应/系统健壮</p><p>特点: 队列先进先出,发布订阅(保证了及时性,下游系统一直在监听mq),部分实现持久化,支持分布式部署</p><hr><p><font color="#ff0000"></font></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 下面将重点介绍RabbitMQ中的一些基础概念，了解了这些概念，是使用好RabbitMQ的基础。<br>ConnectionFactory连接管理器、Connection连接、Channel信道<br><font color="#ff0000">ConnectionFactory、Connection链接生产者和消费者都是通过socket和mq连接的</font>，它封装了socket协议相关部分逻辑。<br><font color="#ff0000">ConnectionFactory为Connection的制造工厂</font>。<br> Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，<strong>包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</strong></p><h2 id="防止数据丢失-三种方式红字"><a href="#防止数据丢失-三种方式红字" class="headerlink" title="防止数据丢失:三种方式红字"></a>防止数据丢失:三种方式红字</h2><p>Message acknowledgment:<br><font color="#ff0000">消息回执</font>:消费者受到消息后未处理完成宕机,可能会导致数据丢失,所以需要消费之消费完成后返回给mq一个信息,没有回执+消费者断开连接的话就把消息给其他消费者(问题:没有timeout,既消费者不断开,处理时间再长,mq都不会把这条消息转给其他消费者,)<br>同时防止断电或者重启的情况下消息丢失(默认重启丢失)…..可以将消息<font color="#ff0000">持久化</font>,这样还会有丢失数据的可能,接收到生产者的消息后还没来得及持久化断电了…..这种情况下可以使用<font color="#ff0000">事务</font>.</p><h2 id="持久化步骤"><a href="#持久化步骤" class="headerlink" title="持久化步骤:"></a>持久化步骤:</h2><p>1.投递消息的时候—-durable设置为true，消息持久化，非spring原生代码：channel.queueDeclare(x, true, false, false, null)，参数2设置为true持久化<br>2.设置投递模式deliveryMode设置为2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENT_TEXT_PLAIN,x)，参数3设置为存储纯文本到磁盘；<br>3.消息已经到达持久化交换器上；<br>1.消息已经到达持久化的队列；<br>原理还是类似写到磁盘有个标记,消费了之后删除,所以持久化缺点就是性能就会收磁盘读写速度的影响,降低了服务器的吞吐量,所以要根据实际情况决定是否持久化<br>如果 exchange 和 queue 都是持久化的，那么它们之间的 binding 也是持久化的，如果 exchange 和 queue 两者之间有一个持久化，一个非持久化，则不允许建立绑定.<br>注意：一旦创建了队列和交换机，就不能修改其标志了，例如，创建了一个 non-durable 的队列，然后想把它改变成 durable 的，唯一的办法就是删除这个队列然后重现创建。</p><h2 id="防止消费者处理能力不均影响效率"><a href="#防止消费者处理能力不均影响效率" class="headerlink" title="防止消费者处理能力不均影响效率"></a>防止消费者处理能力不均影响效率</h2><p>加入把消息平均分配给各个消费者可能会出现有的消费者忙完了待着,有的会一直忙,可以通过设置Prefetch count限制每次发给消费者消费的消息数量,处理完后再给你分配新的消息<br>例:        Prefetch count = 1这样可能会导致queue堆积<br>需要添加更多的 Consumer，或者创建更多的 virtualHost 来细化你的设计。</p><h2 id="exchange交换器"><a href="#exchange交换器" class="headerlink" title="exchange交换器"></a>exchange交换器</h2><p>生产者通过exchange将消息发送至rabbitmq,就是接受/收发消息<br>路由键:把生产者的数据分配到交换器上<br>绑定键:把用于交换器的消息绑定到消费者上</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>用来存储消息,多个消息、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的 消费者可以订阅同一个queue<br>channle信道,消息推送的通道<br><img src="/2020/04/04/RabbitMQ%E6%9C%89%E5%95%A5%E7%94%A8%E6%80%8E%E4%B9%88%E7%94%A8/1.png" alt="1"></p><p>多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。<br>vhost特性<br>1.RabbitMQ默认的vhost是“/”开箱即用<br>2.多个vhost是隔离的，多个vhost无法通讯，并且不用担心命名冲突（队列和交换器和绑定），实现了多层分离；<br>3.创建用户的时候必须指定vhost<br>vhost操作<br>可以通过rabbitmqctl工具命令创建:        <code>rabbitmqctl add_vhost[vhost_name]</code><br>删除vhost：        <code>rabbitmqctl delete_vhost[vhost_name]</code><br>查看所有的vhost：        <code>rabbitmqctl list_vhosts</code></p><h2 id="routingKey-binding-bindingKey"><a href="#routingKey-binding-bindingKey" class="headerlink" title="routingKey/binding/bindingKey"></a>routingKey/binding/bindingKey</h2><p>生产者与exchange之间通过routingKey建立消息路由规则,通过binding将exchange和queue关联起来,并且指定一个或者多个bindingKey,当bingingKey和routingKey匹配时就实现了消息从生产者到queue的传递,但是并不是绝对,还要依赖ExchangeType</p><h2 id="ExchangeType"><a href="#ExchangeType" class="headerlink" title="ExchangeType"></a>ExchangeType</h2><p>fanout:只要有生产者传过来消息不管什么key,会把消息给所有和exchange 绑定的queue发过去,很不检点<br>direct:非常严格的按照key进行匹配,只会将消息按照两个key一致的线路将其从生产者传到queue</p><h2 id="topic-建立了匹配两个key的特殊的规则"><a href="#topic-建立了匹配两个key的特殊的规则" class="headerlink" title="topic:建立了匹配两个key的特殊的规则"></a>topic:建立了匹配两个key的特殊的规则</h2><p>routing/binding key为一个句号分隔的多个单词组成的字符串 如fuck.you<br>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词  </p><p>routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1与Q2，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orangemale.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。(通配符匹配)</p><p>headers:不管什么key,消息包含headers属性是个键值对,queue和exchange绑定时也有一个键值对两个键值对匹配就行.</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>mq本来就是为了异步处理,但是往往有的业务需求中客户端需要同步知道消息是否执行成功,这种需要同步的,需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）<br>客户端发送请求（消息）时，在消息的属性（MessageProperties ，在AMQP 协议中定义了14中properties ，这些属性会随着消息一起发送）中设置两个值replyTo （一个Queue 名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue 中）和correlationId （此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）<br>服务器端收到消息并处理<br>服务器端处理完消息后，将生成一条应答消息到replyTo 指定的Queue ，同时带上correlationId 属性<br>客户端之前已订阅replyTo 指定的Queue ，从中收到服务器的应答消息后，根据其中的correlationId 属性分析哪条请求被执行了，根据执行结果进行后续业务处理</p><h2 id="生产者消费者生命周期"><a href="#生产者消费者生命周期" class="headerlink" title="生产者消费者生命周期"></a>生产者消费者生命周期</h2><p>发布者需要完成的任务：1.连接到RabbitMQ。2.获取信道。3.声明交换机。4.创建消息。5.关闭消息。6.关闭信道。7.关闭连接。<br>消费者需要执行的任务：1.连接到RabbitMQ。2.获取信道。3.声明交换机。4.声明队列。5.把队列和交换机绑定起来。6.消费消息。7.关闭信道。8.关闭连接</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>实现语言是天生具备高并发高可用的 erlang 语言。一种写电话交换机的语言</p><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><h2 id="1-高可用性如何实现"><a href="#1-高可用性如何实现" class="headerlink" title="1.高可用性如何实现"></a>1.高可用性如何实现</h2><p>rabbitMq有三种模式:单机模式/普通集群/镜像集群模式<br>单机模式既一个mq服务器不存在高可用<br>普通集群也不存在高可用,多台机器启动多个mq实例,但是创建的queue只放在一个mq实例A上,其他的实例同步那个queue的元数据,就是类似于queue的配置信息,能够找到实例A,现在消费的时候连接的是B,b取得数据还是从a上拿的,拉取开销是问题,A宕机了也是问题<br>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><h2 id="2-如何解决消息队列的延时以及过期失效问题？"><a href="#2-如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="2.如何解决消息队列的延时以及过期失效问题？"></a>2.如何解决消息队列的延时以及过期失效问题？</h2><p>其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢，造成消息堆积了，MQ存储快要爆了，甚至开始过期失效删除数据了。<br>针对这个问题可以有事前、事中、事后三种处理<br>事前：开发预警程序，监控最大的可堆积消息数，超过就发预警消息（比如短信），不要等出生产事故了再处理。<br>事中：看看消费端是不是故障停止了，紧急重启。<br>事后：需要对消费端紧急扩容 ，增加处理消费者进程，如扩充10倍处理，但其实这也有个问题，即数据库的吞吐是有限制的，如果是消费到数据库也是没办法巨量扩容的，所以还是要在吞吐能力支持下老老实实的泄洪消 费。所以事前预防还是最重要的。否则出发删除过期数据，那就需要再重写生产消息的程序，重新产生消息。<br>新建一个topic，partition是原来的10倍；然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue；接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据；等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息；</p><h2 id="3-RabbitMQ如何保证不丢数据？-可靠性"><a href="#3-RabbitMQ如何保证不丢数据？-可靠性" class="headerlink" title="3.RabbitMQ如何保证不丢数据？(可靠性)"></a>3.RabbitMQ如何保证不丢数据？(可靠性)</h2><p>消息不可靠的情况可能是消息丢失，劫持等原因；<br>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；<br>需要考虑3个可能丢数据的地方：生产端、队列本身、消费端<br><strong>生产端：</strong><br><strong>1.推荐开启 confirm 模式，</strong><br>在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id(所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始）)，然后如果写入了RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而 且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>2.transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；（<strong>不推荐，太耗性能降低吞吐</strong>）</p><p><strong>队列本身</strong>：<br>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的<strong>持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。<br><strong>这个持久化配置可以和confirm机制配合使用</strong>，<strong>你可以在消息持久化磁盘后，再给生产者发送一个Ack信号</strong>。<br>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br>设置持久化有两个步骤：<br>1.创建 queue 的时候将其设置为持久化(<strong>durable设置为true</strong>),则代表是一个持久的队列这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。<br>2.发送消息的时候将消息的 <strong>deliveryMode 设置为 2</strong>。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p><p><strong>自动</strong>消费端：<strong>确认消息模式，改为手动确认消息即可！处理消息成功后，手动回复确认消息。</strong><br>用RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，通过自己的一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别 的 consumer 去处理，消息是不会丢的。</p><h2 id="4-如何保证队列的消息不被重复消费？"><a href="#4-如何保证队列的消息不被重复消费？" class="headerlink" title="4.如何保证队列的消息不被重复消费？"></a>4.如何保证队列的消息不被重复消费？</h2><p>这个需要灵活作答，考察的是思考力，因为消费的场景有很多，有数据库、有缓存、有第三方接口<br>比如针对数据库，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键（或者UUID），那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。<br>再比如redis缓存，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。<br>再比如第三方接口，需要确定两点，第三方接口程序是有去重能力的，那么脏一点直接丢数据过去，如果没有去重能力，还是需要我们来写程序去重，就是第2点的办法。<br>造成消息重复的根本原因是：网络不可达。<br>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？<br>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p><h2 id="5-集群节点类型都有什么？"><a href="#5-集群节点类型都有什么？" class="headerlink" title="5.集群节点类型都有什么？"></a>5.集群节点类型都有什么？</h2><p>节点的存储类型分为两种：<br>磁盘节点<br>内存节点<br>磁盘节点就是配置信息和元信息存储在磁盘上，内存节点把这些信息存储在内存中，当然内次节点的性能是大大超越磁盘节点的。<br>单节点系统必须是磁盘节点，否则每次你重启RabbitMQ之后所有的系统配置信息都会丢失。<br>RabbitMQ要求集群中至少有一个磁盘节点，当节点加入和离开集群时，必须通知磁盘节点。</p><h2 id="6-如何保证RabbitMQ消息的顺序性？"><a href="#6-如何保证RabbitMQ消息的顺序性？" class="headerlink" title="6.如何保证RabbitMQ消息的顺序性？"></a>6.如何保证RabbitMQ消息的顺序性？</h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构5-堆</title>
      <link href="2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/"/>
      <url>2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一种特殊的树<br>是一个完全二叉树；<br>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值<br>大顶堆:上面大下面小,根最大<br>小顶堆:上面小下面打,跟最小</p><p><strong>如何实现一个堆？</strong><br>完全二叉树比较适合用数组来存储–注意下标的规律,堆顶从1开始的话,左子节点是2n,右子节点是2n+1</p><h2 id="堆上的操作"><a href="#堆上的操作" class="headerlink" title="堆上的操作"></a>堆上的操作</h2><ol><li>往堆中插入一个元素<br>往堆中插入一个元素后，我们需要继续满足堆的两个特性—–堆化<br>让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。<br>如:插入22<br><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/1.png" alt="1"></li><li>删除堆顶元素<br>互换堆顶和最后一个节点,移除原堆顶节点，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。好处是:用的最后一个节点,和堆顶交换后再堆化还是完全二叉树<br><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/2.png" alt="1"></li></ol><h2 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h2><ol><li>建堆:<br>将数组原地建成一个堆。<br>第一种:假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。<br>从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化<br>第二种:从后往前处理数组，并且每个数据都是从上往下堆化。叶子节点往下堆化只能自己跟自己比较，所以直接从最后一个非叶子节点开始，依次堆化就行了。<br>例如:最后一个非叶子节点是8,从八往前都有叶子节点,所有从8开始堆化<br><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/3.png" alt="1"><br><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-%E5%A0%86/4.png" alt="1"></li><li>排序:<br>建堆之后数组中的数据已经是按照大顶堆的特性来组织的。第一个元素就是堆顶也是最大的元素。<br>把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。<br>类似上面讲的“删除堆顶元素”的操作,<br>当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。<br>堆化完成之后，再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素—<font color="#FFF0000"><strong>堆化,取最大,再堆化</strong></font>…..<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建堆，</span><br><span class="line"> * @param arr 待排序列</span><br><span class="line"> */</span><br><span class="line">private static void heapSort(int[] arr) &#123;</span><br><span class="line">    //创建堆</span><br><span class="line">    <span class="keyword">for</span> (int i = (arr.length - 1) / 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    //调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    <span class="keyword">for</span> (int i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        //将堆顶元素与末尾元素进行交换</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[0];</span><br><span class="line">        arr[0] = temp;</span><br><span class="line">        //重新对堆进行调整</span><br><span class="line">        adjustHeap(arr, 0, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 调整堆</span><br><span class="line"> * @param arr 待排序列</span><br><span class="line"> * @param parent 父节点</span><br><span class="line"> * @param length 待排序列尾元素索引</span><br><span class="line"> */</span><br><span class="line">private static void adjustHeap(int[] arr, int parent, int length) &#123;</span><br><span class="line">    //将temp作为父节点</span><br><span class="line">    int temp = arr[parent];</span><br><span class="line">    //左孩子</span><br><span class="line">    int lChild = 2 * parent + 1;</span><br><span class="line">    <span class="keyword">while</span> (lChild &lt; length) &#123;</span><br><span class="line">        //右孩子</span><br><span class="line">        int rChild = lChild + 1;</span><br><span class="line">        // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span><br><span class="line">        <span class="keyword">if</span> (rChild &lt; length &amp;&amp; arr[lChild] &lt; arr[rChild]) &#123;</span><br><span class="line">            lChild++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果父结点的值已经大于孩子结点的值，则直接结束</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= arr[lChild]) &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把孩子结点的值赋给父结点</span><br><span class="line">        arr[parent] = arr[lChild];</span><br><span class="line">        //选取孩子结点的左孩子结点,继续向下筛选</span><br><span class="line">        parent = lChild;</span><br><span class="line">        lChild = 2 * lChild + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构4-树</title>
      <link href="2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/"/>
      <url>2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>非线性表结构<br>高度（Height）、深度（Depth）、层（Level）<br>高:数楼房,深:数坑<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/1.png" alt="1"></p><hr><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>每个节点 <strong>最多</strong> 有两个“叉”，也就是两个子节点，分别是左子节点和右子节点</p><p>存储二叉树:一种是基于指针链式存储法，一种是基于数组的顺序存储法<br><strong>链式存储法</strong>:每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针<br><strong>顺序存储法</strong>:根节点存储在下标 <code>i = 1</code> 的位置，那左子节点存储在下标 <code>2 * i = 2</code> 的位置，右子节点存储在 <code>2 * i + 1 = 3</code> 的位置。<br>以此类推<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/2.png" alt="1"><br>只要知道根节点存储的位置（为了方便计算子节点，一般根节点会存储在下标为 1 的位置），<br>这样就可以通过下标计算，把整棵树都串起来。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历:"></a>二叉树的遍历:</h2><p>就是一个递归的过程,时间复杂度是 O(n)。<br>前序遍历:   跟左右<br>中序遍历:   左跟右<br>后序遍历:   左右跟<br>树不方便进行迭代操作，因为它不是一个线性结构。而树的子树就是一个更小规模的树，与递归中子问题的概念完美契合<br>遍历模板:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//前</span><br><span class="line">public static void preOrderRecur(TreeNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line">//中</span><br><span class="line">public static void preOrderRecur(TreeNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line">//后</span><br><span class="line">public static void postOrderRecur(TreeNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderRecur(head.left);</span><br><span class="line">    postOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>———<strong>Morris 遍历算法待学习</strong>——–<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/3.png" alt="1"></p><h2 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>1.该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n - 1, n为层数。<br>2.除叶子节点之外，每个节点都有左右两个子节点 满足这两条性质的为满二叉树</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/4.png" alt="1"><br>完全二叉树适合用数组来存储，比较节省内存空间。仅仅“浪费”了一个下标为 0 的存储位置。<br>堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>实现快速查找而生,快速插入、删除–类似二分<br>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值<br>比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)–平衡二叉查找树</p><ol><li>二叉查找树的查找:先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</li><li>二叉查找树的插入:从根节点开始，依次比较要插入的数据和节点的大小关系。如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置</li><li>二叉查找树的删除:第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。<br>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了<br>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。</li></ol><p>关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点<font color="#FF0000"><strong>标记为“已删除”</strong></font>，但是并不真正从树中将这个节点去掉。节点还存储在内存中，虽费内存，但是删除操作就变得简单。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。<br>4. 二叉查找树的其他操作:<br>快速地查找最大节点和最小节点、前驱节点和后继节点<br>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效–所以也叫<font color="#FF0000">二叉排序树</font><br>5. 支持重复数据的二叉查找树:<br>   第一种方法:每一个节点不仅存储一个数据，通过链表和支持动态扩容的数组等结构，把值相同的数据都存储在同一个节点上。费内存<br>   第二种方法:把这个新插入的数据当作大于这个节点的值来处理。要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/5.png" alt="1"></p><ol start="6"><li>对比散列表:<ol><li>散列表中的数据是无序，要输出有序的数据需先排序。二叉查找树只需要中序遍历，就可以在 O(n) -O(logn)的时间复杂度实现。</li><li>散列表扩容耗时，遇到散列冲突时，性能不稳定，在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>散列表的构造比二叉查找树要复杂，需考虑很多如散列函数的设计、冲突解决办法、扩容、缩容。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li></ol></li></ol><h3 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树:"></a>平衡二叉查找树:</h3><p>解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。<br>二叉查找树中任意一个节点的左右子树的高度相差不能大于 1 ? 未必,红黑树也是但是从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，<br>AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，<br>就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。<br>还有红黑/伸展/数堆等</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>甚至默认平衡二叉查找树就是红黑树,属于上面的一种<br>近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。<br>红黑树中的节点，一类被标记为黑色，一类被标记为红色。<br>根节点是黑色的<br>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；<br>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；<br>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</p><p>为什么说红黑树是“近似平衡”的 ？<br>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。<br>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重。</p><p>实现红黑树的基本思想:<br>遇到什么样的节点排布，我们就对应怎么去调整<br>左旋（rotate left）、右旋（rotate right）:<br>就是围着某个节点旋转</p><h3 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h3><p>平衡多路查找树,数据库索引技术里大量使用者B树和B+树的数据结构</p><ol><li>规则：</li></ol><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；<br>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；<br>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);<br>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p><ol start="2"><li>查找:<br>找到E字母，流程如下<br>（1）获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点<br>（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；<br>（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/6.png" alt="1"></li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找<br><img src="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E6%A0%91/7.png" alt="1"></p><ol><li><p>规则<br>（1）B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；<br>（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；<br>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。<br>（4）非叶子节点的子节点数=关键字数,另一种为非叶节点的关键字数=子节点数-1，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现;<br>总结:只有叶子节点保存数据   搜索时相当于二分查找  增加了相邻接点的指向指针。</p></li><li><p>特点</p></li></ol><p>1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；<br>2、B+树查询速度更稳定：<strong>B+所有关键字数据地址(数据)都存在叶子节点上</strong>，每次查找的次数都相同所以查询速度要比B树更稳定;<br>3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。<br>4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，<em>这有利于数据库做全表扫描</em>。<br>B树相对于B+树的优点是:如果经常访问的<strong>数据离根节点很近</strong>，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p><p><font color="#FFF0000">数据的保存位置</font>和<font color="#FFF0000">相邻节点的指向</font>。就是这俩造成了MongoDB和Mysql的差别。为什么呢？<br>1.MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。<br>2.Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见双指针-对撞</title>
      <link href="2020/03/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%AF%B9%E6%92%9E/"/>
      <url>2020/03/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%AF%B9%E6%92%9E/</url>
      
        <content type="html"><![CDATA[<p>对撞:两个指针一前一后,相向移动</p><h1 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h1><p>Jdk本身就有reverse函数，非常简单，力扣第 344 题是类似的需求，反转一个char[]类型的字符数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(char[] arr) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = arr.length - 1;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        // 交换 arr[left] 和 arr[right]</span><br><span class="line">        char temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++; right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = Arrays.asList(array);</span><br><span class="line">Collections.reverse(list);//JDK中反转</span><br></pre></td></tr></table></figure><hr><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找:"></a>二分查找:</h1><p>一 个顺序数组,猜一个目标数,通过两个指针:<br>我们首先定义两个指针，分别在数组头部和尾部。然后找出指针的中间位置，将中间元素的值和目标元素进行对比，进而决定我们是移动左指针还是右指针。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int halfNum(int[] array, int target) &#123;</span><br><span class="line">int head = 0;</span><br><span class="line">int tail = array.length - 1;</span><br><span class="line">// 给定数组长度不符合返回</span><br><span class="line"><span class="keyword">if</span> (tail &lt;= 1)</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line"><span class="keyword">while</span> (tail &gt;= head) &#123;</span><br><span class="line">//找中间数</span><br><span class="line">int midIndex = head + (tail - head) / 2;</span><br><span class="line"><span class="keyword">if</span> (target == array[midIndex]) &#123;</span><br><span class="line"><span class="built_in">return</span> midIndex;</span><br><span class="line">&#125;</span><br><span class="line">// 如果目标数比中间数大,调整左边界为中间数加一</span><br><span class="line"><span class="keyword">if</span> (target &gt; array[midIndex]) &#123;</span><br><span class="line">head = midIndex + 1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">// 如果目标数比中间数小,调整右边界为中间数减一</span><br><span class="line">tail = midIndex - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找变形</strong><br><strong>题目</strong>：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<br>输入: [1,3,5,6], 5<br>输出: 2<br>输入: [1,3,5,6], 7<br>输出: 4<br>就是上面代码把<code>return -1</code> 改成<code>return head</code></p><hr><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><strong>题目</strong>：<br>给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>说明:<br>返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:<br><strong>输入</strong>: numbers = [2, 7, 11, 15], target = 9            <strong>输出</strong>: [1,2]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    // 定义左侧指针left，指向数组中第一个元素    </span><br><span class="line">    int left = 0;</span><br><span class="line">    // 定义右侧指针right，指向数组中最后一个元素    </span><br><span class="line">    int right = numbers.length - 1;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;        </span><br><span class="line">        // 如果左侧指针与右侧指针所指向的元素和等于目标值，则返回结果     </span><br><span class="line">       <span class="keyword">if</span> (numbers[left] + numbers[right] == target) &#123;         </span><br><span class="line">          res[0] = left + 1;            </span><br><span class="line">          res[1] = right + 1;            </span><br><span class="line">          <span class="built_in">return</span> res;        </span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;            </span><br><span class="line">          // 如果左侧指针与右侧指针所指向的元素和小于目标值            </span><br><span class="line">          // 因为数组是升序排列的，为了让两数之和变大一些            </span><br><span class="line">          // 因此应将左侧指针向右移动一位            </span><br><span class="line">          left++;        </span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;            </span><br><span class="line">          // 如果左侧指针与右侧指针所指向的元素和大于目标值            </span><br><span class="line">          // 因为数组是升序排列的，为了让两数之和变小一些            </span><br><span class="line">          // 因此应将右侧指针向左移动一位            </span><br><span class="line">          right--;        </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有用map的解法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int [] twoAdd (int [] array, int num)&#123;</span><br><span class="line">    Map&lt;<span class="built_in">integer</span>,<span class="built_in">integer</span>&gt; map = new HashMap&lt;&gt; ();</span><br><span class="line">    <span class="keyword">for</span> (int i = 0 ;i&lt;array.length ;i++)&#123;</span><br><span class="line">        int targetNum = num - array[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(targetNum))&#123;</span><br><span class="line">            <span class="built_in">return</span> new int [] &#123;map.get(targetNum),i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(num[i],i)</span><br><span class="line">   &#125;</span><br><span class="line">    throw new IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展:三数之和</strong><br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code> 输出：<code>[[-1,-1,2],[-1,0,1]]</code><br>先排序复杂度为 O(NlogN)<br>固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))两端，通过i,j双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：如果和大于0, j往左移动,如果和小于0 ,i 往右移动,  如果k大于0 ,不用管了,排在K后面的 i,和 j 肯定也大于0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int k = 0; k &lt; nums.length - 2; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; 0) <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) <span class="built_in">continue</span>;</span><br><span class="line">            int i = k + 1, j = nums.length - 1;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                int sum = nums[k] + nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; 0)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; 0) &#123;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><p><strong>题目</strong>：<br>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>空字符串也定义为有效的回文串<br><strong>输入</strong>: “race a car”   <strong>输出</strong>:false<br>回文串是一种从左到右读和从右到左读都一样的字符串。题目中描述的回文串是忽略字母大小写并且只考虑字母和数字字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">    String lowerCase = s.toLowerCase();</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = lowerCase.length() - 1;    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;        </span><br><span class="line">        // 指针left小于指针right且当前考察的字符不是字母或数字，指针left向左移动        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(left))) &#123;</span><br><span class="line">            left++;        </span><br><span class="line">        &#125;</span><br><span class="line">        // 指针left小于指针right且当前考察的字符不是字母或数字，指针right向右移动       </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(right))) &#123;</span><br><span class="line">            right--;        </span><br><span class="line">        &#125;</span><br><span class="line">        // 如果指针left指向的字符与指针right指向的字符不同，则不是回文串        </span><br><span class="line">        <span class="keyword">if</span> (lowerCase.charAt(left) != lowerCase.charAt(right)) &#123;            </span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        // 指针left左移，指针right右移，继续考察下一对字符        </span><br><span class="line">        left++;        </span><br><span class="line">        right--;    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p><strong>题目</strong>：<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>示例:<br><img src="/2020/03/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%AF%B9%E6%92%9E/1.jpg" alt="1"><br><strong>输入</strong>：[1,8,6,2,5,4,8,3,7]         <strong>输出</strong>：49<br>对于指针left与指针right来说，每次在计算其与X轴构成的面积之后，应向内移动较短边所对应的指针，来使得较短边不再参与后续的计算。<br>(如果移动较长边的话面积肯定减少,因为高度由较短边决定,长度由距离决定)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;    </span><br><span class="line">    // 用于记录最大面积    </span><br><span class="line">    int maxArea = 0,left = 0,right = height.length - 1;    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;               </span><br><span class="line">        maxArea = height[left] &lt; height[right] ?</span><br><span class="line">        Math.max (maxArea,(right - left) * height[left++]):</span><br><span class="line">        Math.max (maxArea,(right - left) * height[right--]); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的实现</title>
      <link href="2020/03/04/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/03/04/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>和hash表不是一回事,他的key可以看成hash表,<strong>真正的身份是map</strong><br>key和value的映射,key是根据hash函数,指向value的地址吧<br><strong>数据加链表,现在是链表长度到8之后转成红黑树了,长度小于6再转换成链表</strong><br><strong>为啥到8转换成树?</strong><br>长度为8红黑平均三次找到,链表要4次<br><strong>为啥到6变链表?</strong><br>都是三次差不多,一样的查找还要树干啥<br><strong>为啥不用7?</strong><br>万一来回在8徘徊就不断转换….撑得<br><strong>为啥用红黑呢?</strong><br>之前用的链表查找要遍历,n的复杂度,红黑简单<br><strong>为啥不用平衡二叉?</strong><br>脱了裤子放屁,一共没多少还来回平衡,查询其实没啥大区别,但是平衡太费劲了,不用那么平衡,快就完了<br><strong>啥时候扩容</strong><br>容量乘以下面的负载因子</p><p>正文:<br>从头看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承map</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">//默认初始化大小 16 这块为啥不直接写16?????</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     <span class="comment">//负载因子0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;         <span class="comment">//初始化的默认数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;     <span class="comment">//HashMap中元素的数量</span></span><br><span class="line">    <span class="keyword">int</span> threshold;  <span class="comment">//判断是否需要调整HashMap的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的扩容操作是一项很耗时的任务，所以如果能估算Map的容量，最好给它一个默认初始值，避免进行多次扩容。(底层数组的老毛病,连续空间是中病,还有病友arraylist)</strong><br>HashMap的线程是不安全的，多线程环境中推荐是<code>ConcurrentHashMap</code>。</p><p>和table的区别,感觉没必要看,table和stack一样,是jdk1遗留下来的垃圾,官方自己也知道不推荐,<br>stack也用优先队列代替了,hashtable根本没人用单线程人家有map,多线程都用<code>concurrentHashMap</code>,不用墨迹一直<code>synchronized</code><br>但是最为基础还是要假装了解下<br>1.table线程安全,没卵用<br>2.hashmap的key可以为null,但是最好别这么整(null的key一般都在第一个节点)<br>3.容量与扩容,table初始时11,map扩容是默认乘以2,table是秤2加一<br>4.计算hash方法不同,table是用key的hashcode对长度取余,map是二次hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());  <span class="comment">//hash一次再hash</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据结构:<br>Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，<br>它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。</p><p>属性有 hash，key，value，next。</p><p><img src="/2020/03/04/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt="1"></p><p><strong>1.8的put实现:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //调用putVal()方法完成</span><br><span class="line">    <span class="built_in">return</span> putVal(<span class="built_in">hash</span>(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">final V putVal(int <span class="built_in">hash</span>, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //判断table是否初始化，否则初始化操作</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //计算存储的索引位置，如果没有元素，直接赋值</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - 1) &amp; <span class="built_in">hash</span>]) == null)</span><br><span class="line">        tab[i] = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //节点若已经存在，执行赋值操作</span><br><span class="line">        <span class="keyword">if</span> (p.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        //判断链表是否是红黑树!!!!!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            //红黑树对象操作</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, <span class="built_in">hash</span>, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            //为链表，</span><br><span class="line">            <span class="keyword">for</span> (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">                    //链表长度8，将链表转化为红黑树存储</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 <span class="keyword">for</span> 1st</span><br><span class="line">                        treeifyBin(tab, <span class="built_in">hash</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //key存在，直接覆盖</span><br><span class="line">                <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123; // existing mapping <span class="keyword">for</span> key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="built_in">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //记录修改次数</span><br><span class="line">    ++modCount;</span><br><span class="line">    //判断是否需要扩容</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    //空操作</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说put<br>先看初始化了嘛<br>初始化了对key二次hash根据长度求出下标<br>没有冲突放进去,有冲突了就放到后面<br>超过8就变成红黑树,节点存在就替换<br>容量满了就扩容</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装修niubi....</title>
      <link href="2020/03/03/%E8%A3%85%E4%BF%AEniubi/"/>
      <url>2020/03/03/%E8%A3%85%E4%BF%AEniubi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/35634268/answer/1353329114">https://www.zhihu.com/question/35634268/answer/1353329114</a></p>]]></content>
      
      
      <categories>
          
          <category> 破烂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一顿BB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见双指针-快慢</title>
      <link href="2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/"/>
      <url>2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找中点"><a href="#寻找中点" class="headerlink" title="寻找中点"></a>寻找中点</h1><p>寻找链表中点的常规做法是，先遍历一遍链表，计算链表的长度n 。再遍历一遍链表，找到第  n/2个元素。这样需要遍历链表两遍。<br>双指针:一快一慢两个指针。快指针一次前进两个结点，速度是慢指针的两倍。这样当快指针到达链表尾部时，慢指针正好到达的链表的中部。只需遍历链表一遍。当然，时间复杂度仍然是 O(n)，<br>不过链表类题目就是需要这样减少一次遍历的技巧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode middleNode(ListNode head) &#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        // fast 一次前进两个元素，slow 一次前进一个元素</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链表元素为奇数个时，slow 指向链表的中点,元素为偶数个时，slow 指向链表两个中点的右边一个</span><br><span class="line">    <span class="built_in">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="寻找倒数第K个元素"><a href="#寻找倒数第K个元素" class="headerlink" title="寻找倒数第K个元素"></a>寻找倒数第K个元素</h1><p>常规做法是，先遍历一遍链表，计算链表的长度n 。这样就可以计算出要找第 n-k 个元素，再遍历一遍链表即可。<br>这里同样可以使用快慢指针方法减少一次遍历。不过这次两个指针速度相同，只是间隔一定距离。快指针先前进  k个元素，然后两个指针同样速度前进。这样当快指针到达链表尾部时，慢指针正好到达链表的倒数第k个元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int k) &#123;</span><br><span class="line">    // 将 fast 前进 k 个元素</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        // 这里省略了检测空指针的代码</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    // fast 和 slow 指针间隔 k 个同时前进</span><br><span class="line">    // 这里使用了链表遍历框架，将 slow 指针变成两个指针 curr 和 prev</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    <span class="keyword">while</span> (fast != null) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev == null) &#123;</span><br><span class="line">        head = curr.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展:删除链表的倒数第k个结点，并且返回链表的头结点。</strong>  例如<strong>输入</strong>：<code>head = [1,2,3,4,5], n = 2</code>,<strong>输出</strong>：<code>[1,2,3,5]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);    </span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    // 慢指针初始指向虚拟头结点    </span><br><span class="line">    ListNode slow = dummyHead;    </span><br><span class="line">    // 快指针初始指向虚拟头结点    </span><br><span class="line">    ListNode fast = dummyHead;</span><br><span class="line">    // 快指针先向前移动n+1步    </span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt;= n; i++) &#123;        </span><br><span class="line">        fast = fast.next;    </span><br><span class="line">    &#125;</span><br><span class="line">    // 快慢指针同时向前移动，直到快指针指向null    </span><br><span class="line">    <span class="keyword">while</span> (fast!=null)&#123;        </span><br><span class="line">        fast = fast.next;        </span><br><span class="line">        slow = slow.next;    </span><br><span class="line">    &#125;</span><br><span class="line">    // 慢指针的下一个节点即待删除节点    </span><br><span class="line">    ListNode delNode = slow.next;    </span><br><span class="line">    // 慢指针的后继指针指向待删除节点的下一个节点    </span><br><span class="line">    // 这样就将待删除节点删除了    </span><br><span class="line">    slow.next = delNode.next;    </span><br><span class="line">    delNode.next = null;    </span><br><span class="line">    <span class="built_in">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h1><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>输入</strong>: <code>2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</code><br><strong>输出</strong>: <code>2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></p><p>就是让我们将原来奇数位的结点放一起，偶数位的结点放一起。和结点值无关，是交换结点。<br>定义两个指针，一个起点为 0，一个起点为 1 .且起点为 0  的只在偶数位运行，并将偶数位连接在一起，起点为 1 的只在奇数位运行。并将奇数位连接在一起。最后再把奇数位链表的位和偶数链表的头相连就实现了，奇偶链表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">   <span class="keyword">if</span>(head==null) <span class="built_in">return</span> head;</span><br><span class="line">    ListNode sec=head.next;</span><br><span class="line">   ListNode odd=head;//奇数位置指针</span><br><span class="line">   ListNode even=head.next;//偶数位置指针</span><br><span class="line">   <span class="keyword">while</span> (odd!=null&amp;&amp;even!=null)</span><br><span class="line">   &#123;</span><br><span class="line">       odd.next=even.next;//指向下一个奇数位置</span><br><span class="line">       <span class="keyword">if</span>(even.next==null) <span class="built_in">break</span>;</span><br><span class="line">       even.next=even.next.next;//指向下一个偶数位置</span><br><span class="line">       odd=odd.next;//移动</span><br><span class="line">       even=even.next;</span><br><span class="line">   &#125;</span><br><span class="line">   odd.next=sec;</span><br><span class="line">   <span class="built_in">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h1><p><strong>输入</strong>: <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</code><strong>输出</strong>: <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code><br>将链表中每个节点向右移动K个位置，也就是将链表中倒数第K个节点作为头节点，其前面的所有节点放在原链表尾节点之后。<br>找到倒数第K个节点的前一个节点，然后让链表首尾相连，第K个节点作为链表旋转后的新的头节点，其前一个节点作为链表旋转后的尾节点。<br>首先，定义慢指针slow和快指针fast，其初始都指向链表头节点。然后，让快指针fast先向前移动2步。<br>接着，慢指针slow和快指针fast同时向前移动，每次移动一步，直到快指针fast指向链表的尾节点。这里，快指针fast指向链表的尾节点，不再继续向后移动的原因是，我们需要将尾节点和链表头节点相连，因此其所指节点不能为null。<br>此时，慢指针slow所指节点的下一个节点就是倒数第K个节点。<br>接着，要做的就是将快指针fast所指的尾节点的后继指针指向链表头节点，使链表成环。然后，倒数第K个节点作为链表旋转后的新的头节点，指针slow所指节点作为新的尾节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line"><span class="keyword">if</span> (head == null) &#123;</span><br><span class="line"><span class="built_in">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">// 先计算链表中节点个数</span><br><span class="line">int len = calculateLen(head);</span><br><span class="line">    // 再对k取余，原因是由于最后链表首尾相连成环形链表，所以当k大于链表长度len时，</span><br><span class="line">    // 对于一个节点来说其移动k个位置和移动k对len取余个位置结果是一样的。</span><br><span class="line">k = k % len;</span><br><span class="line">// 快慢指针初始指向头节点</span><br><span class="line">ListNode slow = head;</span><br><span class="line">ListNode fast = head;</span><br><span class="line">// 快指针先向前移动k步</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line">// 快慢指针同时向前移动，直到快指针指向的节点的下一个节点为null</span><br><span class="line"><span class="keyword">while</span> (fast.next != null) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line">// 快指针此时在链表末尾,然后其指向的节点的后继指针指向头节点,这时链表首尾相连成环</span><br><span class="line">fast.next = head;</span><br><span class="line">// 新的头节点是慢指针所指节点的下一个节点</span><br><span class="line">head = slow.next;</span><br><span class="line">// 慢指针所指节点的的后继指针指向null,断开环</span><br><span class="line">slow.next = null;</span><br><span class="line"><span class="built_in">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int calculateLen(ListNode head)&#123;</span><br><span class="line">    int len = 0;    </span><br><span class="line">    <span class="keyword">while</span> (head!=null) &#123;        </span><br><span class="line">        head = head.next;        </span><br><span class="line">        len++;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展-反转链表"><a href="#拓展-反转链表" class="headerlink" title="拓展:反转链表"></a>拓展:反转链表</h2><p><strong>输入</strong>: <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> <strong>输出</strong>: <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code><br>当前节点的next指向上一个节点,,,当前节点的next节点的next指向当前节点就完成了反转<br>循环:<br>提前取出上一节点<br>把当前节点的next指向上一节点<br>上一节点换成当前节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">//申请节点，pre和 cur，pre指向null</span><br><span class="line">ListNode pre = null;</span><br><span class="line">ListNode cur = head;</span><br><span class="line">ListNode tmp = null;</span><br><span class="line"><span class="keyword">while</span>(cur!=null) &#123;</span><br><span class="line">//记录当前节点的下一个节点</span><br><span class="line">tmp = cur.next;</span><br><span class="line">//然后将当前节点指向pre</span><br><span class="line">cur.next = pre;</span><br><span class="line">//pre和cur节点都前进一位</span><br><span class="line">pre = cur;</span><br><span class="line">cur = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p>编写一个程序，找到两个单链表相交的起始节点。<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/2.jpg" alt="2"><br><strong>输入</strong>：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</code><br><strong>输出</strong>：<code>Reference of the node with value = 8</code><br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 <code>[4,1,8,4,5]</code>，链表 B 为 <code>[5,0,1,8,4,5]</code>。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>定义两个指针，分别放到两个链表的头部，然后进行遍历，当某一指针遍历结束后，则从另一指针的起点继续遍历。这样两个指针肯定会在交点相遇的，因为他们速度相同，相同时间内路程一致，所以肯定会在交点相遇的。<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/3.jpg" alt="3"></p><hr><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p>给定一个链表，判断链表中是否有环。pos代表环的入口，若为-1，则代表无环<br>如果链表中存在环，则返回 true 。否则，返回 false<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/5.jpg" alt="5"><br><strong>输入</strong>：<code>head = [3,2,0,-4], pos = 1</code>,<strong>输出</strong>：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>如果链表中有环的话，一个速度快的指针和一个速度慢的指针在环中运动的话，若干圈后快指针肯定可以追上慢指针的。<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/6.jpg" alt="6"></p><hr><h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。<br><strong>输入</strong>：<code>s  =  7, nums  =  [2,3,1,2,4,3]</code> <strong>输出</strong>：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br><strong>滑动窗口</strong>：就是通过不断调节子数组的起始位置和终止位置，进而得到我们想要的结果，<strong>滑动窗口</strong>也是双指针的一种。<br>创建两个指针，一个指针负责在前面探路，并不断累加遍历过的元素的值，当和大于等于我们的目标值时，后指针开始进行移动，<br>判断去除当前值时，是否仍能满足我们的要求，直到不满足时后指针停止，<br>前面指针继续移动，直到遍历结束。前指针和后指针之间的元素个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//初始状态下，start 和 end 都指向下标 0，sum 的值为 0。</span><br><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">    int res = Integer.MAX_VALUE;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n == 0)&#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int start = 0,end = 0, sum = 0;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;n)&#123;</span><br><span class="line">        //每移动一次end，就加上nums[end];</span><br><span class="line">        sum +=nums[end];</span><br><span class="line">        //如果sum&gt;=s，则start不断右移，sum减去nums[start]，直到sum&lt;s为止</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=s)&#123;</span><br><span class="line">            res = Math.min(res,end-start+1);</span><br><span class="line">            sum = sum - nums[start];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res == Integer.MAX_VALUE ? 0:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p>给你一个数组  nums  和一个值  val，你需要 原地 移除所有数值等于  val  的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用  O(1)  额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>给定 nums = [3,2,2,3], val = 3<br>函数应该返回新的长度  2, 并且  nums  中的前两个元素均为  2  你不需要考虑数组中超出新长度后面的元素。<br>创建两个双指针，从数组头部出发，前面的指针负责侦察找到待删除的元素，遇到待删除结点时，前面指针移动，后面不动，等前指针越过待删除元素时，后面的指针继续移动。直至遍历结束，我们可以这样理解这个组合，运行时前指针负责探路，没有危险时后指针跟上，所以我叫他侦察兵。该类型的双指针多用于删除结点时的题目，在链表中同样适用，大家可以去做一下 leetcode 上的83题和84题<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/4.gif" alt="4"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">int slowIndex = 0;</span><br><span class="line"><span class="keyword">for</span>(int fastIndex = 0;fastIndex&lt;nums.length;fastIndex++) &#123;</span><br><span class="line"><span class="keyword">if</span>(val!=nums[fastIndex]) &#123;</span><br><span class="line">nums[slowIndex++]=nums[fastIndex];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> slowIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序,必须在原数组上操作，不能拷贝额外的数组。输入: [0,1,0,3,12]输出: [1,3,12,0,0]<br>双指针:一次遍历<br>时间复杂度: O(n)<br>空间复杂度: O(1)<br><img src="/2020/02/19/%E5%B8%B8%E8%A7%81%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BF%AB%E6%85%A2/7.gif" alt="7"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums==null) <span class="built_in">return</span>;</span><br><span class="line">//两个指针i和j</span><br><span class="line">int j = 0;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span><br><span class="line"><span class="keyword">if</span>(nums[i]!=0) &#123;</span><br><span class="line">int tmp = nums[i];</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">nums[j++] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>定义慢指针slow，指向数组中的第一个元素。<br>定义快指针fast，其所指向的元素为当前在考察的元素。<br>因为数组是排好序的，因此数组中的第一个元素是一定存在于返回数组中的，所以从第二个元素开始考察，即快指针fast的初始值为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    // 区间[0,slow]中的元素都是排序数组中只出现一次的元素</span><br><span class="line">    int slow = 0;    </span><br><span class="line">    // 快指针fast的初始值为1，因为数组是排好序的    </span><br><span class="line">    // 因此数组中的第一个元素是一定存在于返回数组中的。    </span><br><span class="line">    <span class="keyword">for</span>(int fast = 1; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">       // 当前考察的元素nums[fast]和nums[slow]不相等时        </span><br><span class="line">       // 说明nums[fast]是需要放入区间[0,slow]中的        </span><br><span class="line">       <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">          // slow++是因为区间[0,slow]是左闭右闭的</span><br><span class="line">          // 因此，在slow加1之后，在将nums[fast]的值赋予nums[slow]</span><br><span class="line">          slow++;            </span><br><span class="line">          nums[slow] = nums[fast];        </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;    </span><br><span class="line">   // j指向的是新数组中末尾的元素，即新数组最后的索引    </span><br><span class="line">   // 而索引从0开始，题目要求返回新数组的长度，因此返回slow+1    </span><br><span class="line">   <span class="built_in">return</span> slow + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展:在 原地 删除重复出现的元素，使得每个元素最多出现两次</strong><br><strong>输入</strong>：<code>nums = [1,1,1,2,2,3]</code>,<strong>输出</strong>：<code>5, nums = [1,1,2,2,3]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    // 最大重复次数两次</span><br><span class="line">    int maxRepeat = 2;    </span><br><span class="line">    // 慢指针slow指向索引为1的位置    </span><br><span class="line">    int slow = maxRepeat - 1;    </span><br><span class="line">    <span class="keyword">for</span>(int fast = maxRepeat; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">       // nums[fast] != nums[slow - maxRepeat + 1]        </span><br><span class="line">       // 保证在区间[0,slow]中元素最多不会超过2次        </span><br><span class="line">       <span class="keyword">if</span> (nums[fast] != nums[slow - maxRepeat + 1]) &#123;</span><br><span class="line">          // 先扩展区间            </span><br><span class="line">          slow++;            </span><br><span class="line">          // 再赋值            </span><br><span class="line">          nums[slow] = nums[fast];        </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> slow + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摩尔投票法</title>
      <link href="2020/02/15/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"/>
      <url>2020/02/15/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><p>如何找出数组中出现次数大于1/2的整数?</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>  1.因为出现次数大于1/2,可以直接排序然后取中间<br>  2.利用map的key的唯一性,key存值,value存出现次数,循环一次后找到map中value最大的值</p><h1 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票:"></a>摩尔投票:</h1><p>  理解:就是把每个元素看成人,元素值就是人投的票,两个元素之间互相厮杀,投的票不一致就互相抵消,反正会有1/2以上的人投同一个最后剩下的肯定是这个票<br>  翻译成人话:维护一个计数器，如果遇到一个目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">answer</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> zhongShu = nums[<span class="number">0</span>];  <span class="comment">//众数:先假装第一个元素是</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (zhongShu == nums[i]) <span class="comment">//如果是当前候选的众数,就加一票</span></span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">count--;    <span class="comment">//不是就减一票</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123; <span class="comment">//没票了就换候选人,取下一个</span></span><br><span class="line">zhongShu = nums[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zhongShu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p>map:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">answer2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">Map map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : nums) &#123; <span class="comment">// 循环一遍,有就value加一没有就put</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(a)) &#123;</span><br><span class="line">map.put(a, (Integer) map.get(a) + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(a, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList(map.entrySet());</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; (o1.getValue() - o2.getValue()));</span><br><span class="line"><span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>).getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序取中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">answer30</span> <span class="params">(<span class="keyword">int</span> [] nums )</span></span>&#123;</span><br><span class="line">   <span class="comment">// jdk排序根据length选择具体排序:&gt;=286且连续性好 归并排序，&gt;=286且连续性不好  双轴快速排序。</span></span><br><span class="line">   <span class="comment">//在47和286之间 双轴快速排序，length&lt;=47 插入排序</span></span><br><span class="line">    Array.sort(nums); </span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力求解:略</p><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸:"></a>延伸:</h1><p>  现在不想找超过1/2,而是想找超过1/3的所有数,或者1/4的所有数<br>  或者1/n的所有数,反正这种数最多n-1个,要找几个数就取几个候选人,下面以找出超过1/3的所有数为例(最多俩)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoEr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">twoNum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  超过1/3最多有俩人,就先定义两个候选者和他们的票数,最终还不一定有符合的呢</span></span><br><span class="line">        <span class="keyword">int</span> cand1 = <span class="number">0</span>, cand2 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  投票过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//  如果是候选者1，则票数++</span></span><br><span class="line">            <span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="comment">//  直接开始下一次遍历</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  如果是候选者2，则票数++</span></span><br><span class="line">            <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  不是候选人cand1或者cand2则判断他们的票数是否为0，为0则更换候选人</span></span><br><span class="line">            <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//  虽然先更换候选人1,但是不耽误事,反正最终两个候选人都是超过1/3的票数,所以都为0的时候不影响</span></span><br><span class="line">                cand1 = num;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">                cand2 = num;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt1--;</span><br><span class="line">            cnt2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  检查两个候选人的票数符不符合</span></span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            res.add(cand1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt2 &gt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            res.add(cand2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试标签</title>
      <link href="2020/02/15/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"/>
      <url>2020/02/15/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>设置全标签用<br><font color="#FF0000"></font>   红色</p><p><span class="inline-tag red"> 123123</span></p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> mysql </tag>
            
            <tag> redis </tag>
            
            <tag> springboot </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Hexo </tag>
            
            <tag> mongo </tag>
            
            <tag> rabbit </tag>
            
            <tag> vue </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构3-跳跃表</title>
      <link href="2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>链表查询慢,插入删除快,有序链表也要O(n)浪费了有序特性,<strong>升维空间换时间</strong><br>在链表的基础上提高查询速度的数据结构—-链表加多级索引—-跳跃表,前提:<font color="#FF0000"><strong>有序链表</strong></font> **<br>跳表的空间复杂度是 <code>O(n)</code><br>增删查<code> O(logn)</code><br>对标:<strong>平衡二叉树,二分法</strong></p><p>往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。<br>如何选择加入哪些索引层呢？<br>通过随机函数来维护前面提到的“平衡性”。<br>比如随机函数生成了值 K，那就将这个结点添加到第一级到第 K 级这 K 级索引中。<br>其效率可比拟于红黑树和AVL树(对于大多数操作需要O(logn)平均时间)，但是实现起来更容易且对并发算法友好<br>理想情况下，跳跃表结构中第一层中存在所有的节点，第二层只有一半的节点，而且是均匀间隔，第三层则存在1/4的节点，并且是均匀间隔的，<br>以此类推，这样理想的层数就是<code>logN</code>。<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/1.png" alt="1"><br>查询元素为55的结点，只需要在L2层查找4次即可。<br>查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，<br>因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后退回到元素37，<br>到它的下一层即L1层继续搜索46。只需要再查询1次就能找到46。耗费5次查询。</p><p>但是如果想要在上图中插入或者删除一个元素呢？<br>比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？<br>我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。<br>有一种基于概率统计的<strong>插入算法</strong>，也能得到时间复杂度为O(logn)的查询效率，<br>如果我们要插入元素2，首先是在底部插入元素2，如下图：<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/2.png" alt="2"><br>然后抛硬币，结果是正面，那么要将2插入到L2层，如下图:<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/3.png" alt="2"><br>继续抛硬币，结果是反面，那么元素2的插入操作就停止了，接下来入元素33如下图：<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/4.png" alt="2"><br>然后抛硬币，结果是反面，那么元素33的插入操作就结束了，如上图,接下来，插入元素55如下图：<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/5.png" alt="2"><br>然后抛硬币两次都是正面,L2/L3都要插入55<br><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E8%B7%B3%E8%B7%83%E8%A1%A8/6.png" alt="2"></p><p>删除:直接删除元素，然后调整一下删除元素后的指针即可。跟普通的链表删除操作完全一样。</p><h2 id="Redis-为什么会选择用跳表来实现有序集合呢？"><a href="#Redis-为什么会选择用跳表来实现有序集合呢？" class="headerlink" title="Redis 为什么会选择用跳表来实现有序集合呢？"></a>Redis 为什么会选择用跳表来实现有序集合呢？</h2><p>Redis 中的有序集合是通过跳表来实现的，其实还用到了散列表。<br>Redis 中的有序集合支持的核心操作主要有：</p><ol><li>插入/删除/查找一数据；</li><li>按区间查找数据（比如查找值在[100, 356]之间的数据）；</li><li>迭代输出有序序列。<br>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。<br>但是，<strong>按照区间来查找数据</strong>这个操作，红黑树的效率没有跳表高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公平洗牌</title>
      <link href="2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/"/>
      <url>2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<p>放在一个数组,随机选两个数交换位置,重复K次,K取几?1000?100?应该和几张牌有关,但是真的公平吗?</p><p>暴力算法:n张牌,列出所有排列情况,共有n!中,选其中的一种,复杂度O(n!), 问题是复杂度是2^n已经被称为指数爆炸了,n!的代价太大了</p><p>公平洗牌可以理解为<strong>每个位置出现每个元素的概率都是相同的!</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 核心:实现随机</span></span><br><span class="line"><span class="comment">* 生成一个随机数:随机数为(0,length-1),就是说数组每个元素的下标都有可能</span></span><br><span class="line"><span class="comment">* 将下标为i的元素和下标为随机数的元素交换,i是从后往前开始,交换完后后面的那个位置的元素确定了</span></span><br><span class="line"><span class="comment">* 位置为确定的再继续重复,此时i-1,随机数也是(0,i)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> suiji = (<span class="keyword">int</span>)(Math.random()*(i-<span class="number">0</span>+<span class="number">1</span>));</span><br><span class="line">swap(nums,i,suiji);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = array[i];</span><br><span class="line">array[i] = array[j];</span><br><span class="line">array[j] = temp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>复杂度O(n)<br>分析:<br>我们简单的只是用 5 个数字进行模拟。假设初始的时候，是按照 1，2，3，4，5 进行排列的。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/1.jpg" alt="1"><br>那么，根据这个算法，首先会在这五个元素中选一个元素，和最后一个元素 5 交换位置。假设随机出了 2。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/2.jpg" alt="1"><br>下面，我们计算 2 出现在最后一个位置的概率是多少？非常简单，因为是从 5 个元素中选的嘛，就是 1/5。实际上，根据这一步，任意一个元素出现在最后一个位置的概<br>率，都是 1/5。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/3.jpg" alt="1"><br>下面，根据这个算法，我们就已经不用管 2 了，而是在前面 4 个元素中，随机一个元素，放在倒数第二的位置。<br>假设我们随机的是 3。3 和现在倒数第二个位置的元素 4 交换位置。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/4.jpg" alt="1"><br>下面的计算非常重要。3 出现在这个位置的概率是多少？计算方式是这样的：<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/5.jpg" alt="1"><br>其实很简单，因为 3 逃出了第一轮的筛选，概率是 4/5，但是 3 没有逃过这一轮的选择。在这一轮，一共有4个元素，<br>所以 3 被选中的概率是 1/4。因此，最终，3 出现<br>在这个倒数第二的位置，概率是 4/5 * 1/4 = 1/5。<br>还是 1/5 !</p><p>实际上，用这个方法计算，任意一个元素出现在这个倒数第二位置的概率，都是1/5。</p><p>我们再进行下一步，在剩下的三个元素中随机一个元素，放在中间的位置。假设我们随机的是 1。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/6.jpg" alt="1"><br>关键是：1 出现在这个位置的概率是多少？计算方式是这样的：<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/7.jpg" alt="1"><br>即首先在第一轮没被选中，概率是 4/5，<br>在第二轮又没被选中，概率是 3/4 ，但是<br>在第三轮被选中了，概率是 1/3。乘在一起，4/5 * 3/4 * 1/3 = 1/5。</p><p>用这个方法计算，任意一个元素出现在中间位置的概率，都是 1/5。</p><p>这个过程继续，现在，我们只剩下两个元素了，在剩下的两个元素中，随机选一个，比如是4。将4放到第二个位置。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/8.jpg" alt="1"><br>然后，4 出现在这个位置的概率是多少？4 首先在第一轮没被选中，概率是 4/5；在第二轮又没被选中，概率是 3/4；<br>第三轮还没选中，概率是 2/3，但是在第四轮被选中了，概率是 1/2。4/5 * 3/4 * 2/3 * 1/2 = 1/5。</p><p>用这个方法计算，任意一个元素出现在第二个位置的概率，都是 1/5。<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/9.jpg" alt="1"><br>最后，就剩下元素5了。它只能在第一个位置呆着了。</p><p>那么 5 留在第一个位置的概率是多少？即在前 4 轮，5 都没有选中的概率是多少？</p><p>在第一/二/三/四轮都没被选中:4/5 * 3/4 * 2/3 * 1/2 = 1/5<br><img src="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/10.jpg" alt="1"><br>你看，在整个过程中，每一个元素出现在每一个位置的概率，都是 1/5 ！</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发笔记-同步控制</title>
      <link href="2020/01/30/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/"/>
      <url>2020/01/30/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h1><p>synchronized关键字就是一种最简单的控制方法。<br>它决定了一个线程是否可以访问临界区资源。<br>同时，<code>Object.wait()</code>和<code>Object.notify()</code> 方法起到了线程等待和通知的作用。这些工具对于实现复杂的多线程协作起到了重要的作用。</p><h1 id="重入锁ReentrantLock——–"><a href="#重入锁ReentrantLock——–" class="headerlink" title="重入锁ReentrantLock——–"></a>重入锁ReentrantLock——–</h1><p><strong>扩展的synchronized</strong><br>用来:<br>递归调用<br>调用同一对象其它synchronized或者有同步锁函数<br>重入锁可以完全替代synchronized关键字(他也是可重入锁)。在JDK5的早期版本中，重入锁的性能远远好于synchronized,但从JDK6.0开始，<br>JDK在synchronized上做了大量的优化，使得两者的性 能差距并不大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ReenterLock implements Runnable&#123;</span><br><span class="line">     public static ReentrantLock lock = new ReentrantLock(); </span><br><span class="line">     public static int i=0;</span><br><span class="line">     ©Override</span><br><span class="line">     public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">         <span class="keyword">for</span>(int j=0;j&lt;10000000;j++)&#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             try&#123;</span><br><span class="line">                i++；</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">          ReenterLock tl=new ReenterLock();</span><br><span class="line">          Thread tl=new Thread(tl);</span><br><span class="line">          Thread t2=new Thread(tl);</span><br><span class="line">          tl.start();t2.start();</span><br><span class="line">          tl. join() ;t2. join ();</span><br><span class="line">          System.out.printin(i);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码第7  —  1 2 行，使用重入锁保护临界区资源i , 确保多线程对i 操作的安全性。从这 段代码可以看到，与<code>synchronized</code>相比，重入锁要显示指定加锁释放锁<br>为什么叫可重入: 一个线程可以多次进入获得同一个锁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock (); </span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    i++；</span><br><span class="line">&#125;finally!</span><br><span class="line">    lock.unlock(); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不可重入第二次加锁就会成死锁,但是可重入锁就是牛逼<br><strong>注意:多次获得锁，也要释放相同次数。</strong><br>如果释放锁的次数多—IllegalMonitorStateException异常，<br>放锁的次数少，资源被这个线程锁死了。<br><strong>重入锁还有中断响应功能</strong>–<code>lockInterruptibly</code></p><p>对于synchronized来说，要么执行要么等到死—-die  or live is not your choice<br>重入锁:在等待锁的过程中，线程自己选择是否继续等锁还是中断—-我命由我不由天,大不了自杀</p><p>如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待避免死锁<br>下面的代码产生了一个死锁，但得益于锁中断，我们可以很轻易地解决这个死锁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class IntLock implements Runnable &#123;</span><br><span class="line">    public  static  ReentrantLock  lockl  =  new  ReentrantLock(); </span><br><span class="line">    public  static  ReentrantLock  lock2  =  new  ReentrantLock(); </span><br><span class="line">    int lock;</span><br><span class="line">    //控制加锁顺序，方便构造死锁</span><br><span class="line">    public IntLock(int lock) &#123;</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock == 1)   &#123;</span><br><span class="line">               lockl.lockinterruptibly();   //tl先占用lockl,再占用lock2；</span><br><span class="line">               try&#123;</span><br><span class="line">                   Thread.sleep(500);   //防止一下占了两个锁</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockinterruptibly();   //t2先占用lock2,</span><br><span class="line">                try&#123;</span><br><span class="line">                   Thread.sleep(500);</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">                lockl.lockinterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace ();</span><br><span class="line">       .&#125; finally &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockl.isHeldByCurrentThread())</span><br><span class="line">               lockl.unlock();</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">               lock2.unlock();</span><br><span class="line">            System, out. printIn (Thread.currentThread ().getld() +<span class="string">&quot;线程退出&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException   &#123; </span><br><span class="line">        IntLock rl = new IntLock(1);</span><br><span class="line">        IntLock r2 = new IntLock(2)</span><br><span class="line">        Thread tl = new Thread(rl);</span><br><span class="line">        Thread t2 = new Thread(r2);</span><br><span class="line">        tl.start ();t2.start();</span><br><span class="line">        Thread.sleep(1000);  //主线程休眠时间两个线程处于死锁</span><br><span class="line">        t2.interrupt();   //中断其中一个线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lockInterruptibly:   可以对中断进行响应的锁申请,在等待锁的过程中，可以响应中断。</li></ul><p>主线程main处于休眠时，两个线程处于死锁的状态，<br>由于t 2 线程被中断，故t 2 会放弃对lock1 的申请，同时释放己获得lock2<br> 这个操作导致 tl线程可以顺利得到lock2而继续执行下去。</p><p>可以看到，中断后，两个线程双双退出。但真正完成工作的只有tl。而t2线程则放弃其任<br>务直接退出，释放资源。</p><p> – <strong>锁申请等待限时</strong>—<code>tryLock()</code>  or  <code>tryLock(int, Time)</code></p><p>给定一个等待时间，让线程自动放弃，<br>使用<code>tryLock()</code>方法进行一次限时的等待。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TimeLock implements Runnable&#123;</span><br><span class="line">     public static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"> ©Override</span><br><span class="line">     public void <span class="function"><span class="title">run</span></span> () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           <span class="keyword">if</span>(lock.tryLock(5, TimeUnit.SECONDS))&#123;  //最多请求5秒的锁</span><br><span class="line">              Thread.sleep (6000);  //睡眠6秒</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              System.out.printin (<span class="string">&quot;nget lock failed&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.<span class="function"><span class="title">isHeldByCurrentThread</span></span>()&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       TimeLock tl=new TimeLock();</span><br><span class="line">       Thread tl=new Thread(tl);</span><br><span class="line">       Thread t2=new Thread(tl);</span><br><span class="line">       tl.start();</span><br><span class="line">       t2.start ();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>tryLock()</code>方法接收两个参数，一个表示等待时长，另外一个表示计时单位。<br>最多等待5秒。如果超过5秒还没有 得到锁，就会返回<code>felse</code>。如果成功获得锁，则返回<code>true</code>。<br>占用锁的线程会持有锁长达6 秒，故另一个线程无法在5 秒的等待时间内 获得锁，因此，请求锁会失败。<br><code>ReentrantLock.tryLock()</code>方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获<br>得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回<code>t r u e</code><br>如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回<code>f a l s e o</code><br>这种模式不会引起线程等待，因此也不会产生死锁。—终归会执行完</p><p>– 公平锁 —–new ReentrantLock(true)</p><p>一般情况下锁都是非公平的,<br>1请求锁A,2也请求锁A ……给谁?<br>不一定的.系统随便挑个人就给了。因此不能保证其公平性。<br>公平锁，会按照时间的先后顺序，保证先到者先到得后到者后得。不会产生饥饿现象。<br><code>synchronized</code>关键字进行锁控制，那么产生的锁就是非公平的。<br>而重 入锁允许我们对其公平性进行设置。它有一个如下的构造函数：<br><code>public ReentrantLock(boolean fair)</code><br>当参数<code>fair</code>为<code>true</code>时，表示锁是公平的。<br><strong>实现成本比较高，性能相对也非常低下</strong>，因此，默认情况下，锁是非公平的。<br>公平锁和非公平锁在线 程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock implements Runnable &#123;</span><br><span class="line">    //参数设置为<span class="literal">true</span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">public static ReentrantLock fairLock = new ReentrantLock(<span class="literal">true</span>);</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           try&#123;</span><br><span class="line">               fairLock.lock();</span><br><span class="line">               Syso(Thread.currentThread().getName()+ <span class="string">&quot;获得锁〃)；</span></span><br><span class="line"><span class="string">            &#125;finally&#123;</span></span><br><span class="line"><span class="string">               fairLock.unlock();</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public static void main(String[] args) throws 工nterruptedException &#123;</span></span><br><span class="line"><span class="string">        FairLock rl = new FairLock();</span></span><br><span class="line"><span class="string">        Thread tl=new Thread(rl,&quot;</span>Thread一tl<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        Thread t2=new Thread (rl,&quot;</span>Thread一t2<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        tl.start&#123;);t2.start(&#125;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>构造函数设置为true<br>两个线程tl和t2分别请求这把锁，并且在得到锁后，进行一个控制台的输出，表示自己得到了锁。在公平锁的情况下，得到输出通常如下 所示：</p><p>几乎不会发生同一个线程连续多次获得锁的可能，从而公平 性也得到了保证。</p><p><strong>重入锁总结</strong><br>•    <code>lock()</code>：获得锁，如果锁己经被占用，则等待。—往死了尽力,不死不休<br>•    <code>locklnterruptibly()</code>:获得锁，优先响应中断(interrupt调用时先处理InterruptedException异常)–尽力但是能拽回来<br>•    <code>tryLock()</code>：获得锁，返回true，没得到返回false。—假装尽力了,不配叫try<br>•    <code>tryLock(long time, TimeUnit unit)</code>：在给定时间内尝试获得锁。—真尽力了,适可而止<br>•    <code>unlock()</code>：释放锁。<br>•    <code>new ReentrantLock(true)</code>: —公平,TMD还是公平</p><p>**重入锁实现的三个要素： **<br>一: 是原子状态。原子状态使用CAS操作来存储当前锁的状态,判断锁是否被别的线程占有<br>二: 是等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放<br>锁后，系统就能从等待队列中唤醒一个线程，继续工作。<br>三: 阻塞原语<code>park()</code>和<code>unpark()</code>:来挂起和恢复线程。没得到锁的线程将被挂起(参见LockSupport)</p><hr><h1 id="重入锁的Condition条件—–"><a href="#重入锁的Condition条件—–" class="headerlink" title="重入锁的Condition条件—–"></a>重入锁的Condition条件—–</h1><p><strong>await( )和single()等</strong><br>理解了 <code>Object.wait()</code>和<code>0bject.notify()</code>方法的话，就能很容易地理解Condition 对象了。<br>它和<code>wait()</code> 和<code>notify( )</code> 方法的作用是大致相同的。但是<code>wait()</code> 和<code>notify() </code>方法是和 <code>synchronized</code>关键字合作使用的<br>而<code>Condition</code>是<strong>与重入锁相关联的</strong>。通过LOCK 接口(重入锁就 实现了这一接口)的<br><code>Condition.newCondition()</code>方法可以<strong>生成一个与当前重入锁绑定的Condition 实例</strong>。<br>利用<code>Condition</code>对象，可以<strong>让线程在合适的时间等待，或者在某一个特定的时刻得 到通知，继续执行</strong>。<br>Condition接口提供的基本方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException; </span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws ZCnterruptedException; </span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException; </span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException; </span><br><span class="line">void signal(); </span><br><span class="line">void signalAll ();</span><br></pre></td></tr></table></figure><p><strong>以上方法的含义如下：</strong><br>•  await() 方法—–会使当前线程等待，同时释放当前锁，<strong>当其他线程中使用<code>signal()</code> 或者 <code>signalAll( )</code> 方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等 待。这和<code>0bject.wait()</code>方法很相似。</strong><br>•   awaitUninterruptibly()方法—-与await()方法基本相同，<strong>但是它并不会在等待过程中响应中 断。</strong><br>•   signal() 方法——-用于唤醒一个在等待中的线程。<br>•   signalAll(): 方法会唤醒所有在等待中 的线程。这和<code>0bejct.notify()</code>方法很类似。<br>下面的代码简单地演示了 <code>Condition</code>的功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ReenterLockCondition implements Runnable</span><br><span class="line">   public static ReentrantLock lock  = new ReentrantLock(); </span><br><span class="line">   public static Condition condition = lock.newCondition(); //绑定</span><br><span class="line">   @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          lock.lock(); //</span><br><span class="line">          condition.await();   //等待唤醒操作</span><br><span class="line">          System.out.printin(<span class="string">&quot;Thread is going on&quot;</span>); </span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">       &#125;finally&#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public  static  void  main(String[]  args)  throws  InterruptedException  &#123; </span><br><span class="line">       ReenterLockCondition tl=new ReenterLockCondition();</span><br><span class="line">       Thread tl=new Thread(tl);</span><br><span class="line">       tl.start ();</span><br><span class="line">       Thread.sleep(2000);   // 睡眠是让t1先执行,但是他有await,main等会还能拿到锁</span><br><span class="line">       lock.lock();  //ti被await了,现在我可以拿这个锁</span><br><span class="line">       condition.signal(); //唤醒了t1但是他还是不会执行,因为main拿到了锁</span><br><span class="line">       //我释放了锁,t1才能拿到,我不释放,虽然唤醒但他拿不到锁永远不会输出</span><br><span class="line">       lock.unlock(); </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过lock生成一个与之绑定的Condition对象。要求线程在Condition 对象上进行等待。由主线程main发出通知，告知等待在Condition上的线程可以 继续执行了。<br>和<code>Object.wait()</code>和<code>notify()</code>方法一样，<strong>当线程使用<code>Condition.await()</code>时，线程持有相关的 重入锁，在<code>Condition.await()</code>调用后，会释放这把锁。</strong><br><strong>同理，在<code>Condition.signal()</code>方法调用时，线程先获得相关的锁。</strong><br>在<code>signal()</code> 方法调用后，系统会从当前<code>Condition</code>对象的 <strong>等待队列</strong>中，唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成 功获取，就可以继续执行了。<br>在<code>signal()</code> 方法调用之后，一般需要<strong>释放相关的锁，谦让给 被唤醒的线程，让它可以继续执行</strong></p><p>JDK中重入锁和Condition对象被广泛地使用：<br><strong>ReentrantLock +Condition 实现ArrayBlockingQueue的put()方法实现如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//在 ArrayBlockingQueue 中的一些定义</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">private final Condition notFull;</span><br><span class="line">lock = new ReentrantLock(fair);</span><br><span class="line">//生成一个与 lock 绑定的Condition</span><br><span class="line">notEmpty = lock. newCondition《)； </span><br><span class="line">notFull = lock.newCondition();</span><br><span class="line">//put () 方法的实现</span><br><span class="line">public void put(E e) throws InterruptedException</span><br><span class="line">    <span class="keyword">if</span> (e = null) throw new NullPointerException ;</span><br><span class="line">    final E[] items = this.items </span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.locklnterruptibly(); //对put方法做同步</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) //如果当前队列己满</span><br><span class="line">                notFull.await(); //等待队列有足够的空间</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">            notFull.signal(); </span><br><span class="line">            throw ie; </span><br><span class="line">        &#125; </span><br><span class="line">    insert(e);  //当notFull被通知时，说明有足够空间</span><br><span class="line">    </span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void insert(E x) &#123; </span><br><span class="line">    items[putlndex] = x; </span><br><span class="line">    putlndex = inc(putlndex); </span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal ();  //通知需要take()的线程，队列己有数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同理，对应take ()方法实现如下:</span><br><span class="line">public E take() throws InterruptedException &#123; </span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.locklnterruptibly () ;   //对take ()方法做同步                     </span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span> (count = 0) //如果队列为空</span><br><span class="line">            notEmpty.await () ; //则消费者队列要等待一个非空的信号          </span><br><span class="line">        &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">            notEmpty.signal();</span><br><span class="line">            throw ie; </span><br><span class="line">       &#125;</span><br><span class="line">       E x = extract(); </span><br><span class="line">       <span class="built_in">return</span> x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private E <span class="function"><span class="title">extract</span></span>() &#123;</span><br><span class="line">    final E[] items = this.items; </span><br><span class="line">    E x = items[takeindex]; </span><br><span class="line">    items[takeindex] = null; </span><br><span class="line">    takeindex = inc(takeindex); </span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal () ;  //通知put ()线程队列己有空闲空间</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="多个线程同时访问：信号量-Semaphore"><a href="#多个线程同时访问：信号量-Semaphore" class="headerlink" title="多个线程同时访问：信号量(Semaphore)"></a>多个线程同时访问：信号量(Semaphore)</h1><p>是对锁的扩展。<br>无论 是内部锁<code>synchronized</code> 还是重入锁<code>reentrantLock</code> , 一次都只允许一个线程访问一个资源，而<strong>信号量却可以指定多个线程，同时访问某一个资源</strong>。<br>信号量主要提供了以下构造函数：<br><code>public Semaphore(int n)  //允许 n个准入数</code><br><code>public Semaphore (int n, boolean fair) //第二个参数可以指定是否公平</code></p><p>当每个线 程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。<br>信号量 的主要逻辑方法有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void acquire()  //尝试获得一个准入,没有就等待或者被中断</span><br><span class="line">public void acquireUninterruptibly() //同上,但是不会响应中断</span><br><span class="line">public boolean tryAcquire()  //类似tryLock尝试获得准入</span><br><span class="line">public boolean tryAcquire(long timeout,TimeUnit unit) //类似</span><br><span class="line">public void release()  //线程访问资源结束后，释放一个许可</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemapDemo implements Runnable&#123;</span><br><span class="line">   final Semaphore semp = new Semaphore(5);  //最多五个许可</span><br><span class="line">   @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           semp.acquire(); //20个线程进来申请许可</span><br><span class="line">           //模拟耗时操作</span><br><span class="line">           Thread.sleep(2000); //过20秒输出五组</span><br><span class="line">           Syso(Thread.currentThread().getld()+<span class="string">&quot;:done!&quot;</span>);</span><br><span class="line">           semp.release(); //一定要释放信号量</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       ExecutorService <span class="built_in">exec</span> = Executors.newFixedThreadPool(20);</span><br><span class="line">       final SemapDemo demo=new SemapDemo();</span><br><span class="line">       <span class="keyword">for</span>(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">           exec.submit(demo);//20个线程</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在离幵时，务必使用<code>release()</code>释放信号量。 就像是释放锁。<br>避免信号量的泄露(申请了但没有释放)，不然能进去的线程越来越少</p><h1 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h1><p>读写锁允许多个线程同时读<br>写写操作和读写操作间依然是需要相互等待和持有锁的。</p><p>•读-读不互斥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">   private static Lock lock=new ReentrantLock();</span><br><span class="line">   private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">   private static Lock readLock = readWriteLock.readLock();</span><br><span class="line">   private static Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">   private int value;</span><br><span class="line">   public Object handleRead(Lock  lock) throws InterruptedException&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">          lock.lock(); //模拟读</span><br><span class="line">          Thread.sleep(1000); //读的时间越多有事越明显</span><br><span class="line">          value=index;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public Object handleWrite(Lock lock,int index) throws InterruptedException&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">          lock.lock(); //模拟写操作</span><br><span class="line">          Thread.sleep(1000); </span><br><span class="line">          value=index;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123; </span><br><span class="line">     final ReadWriteLockDemo demo=new ReadWriteLockDemo(); </span><br><span class="line">     Runnable readRunnale = new <span class="function"><span class="title">Runnable</span></span>()&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            demo.handleRead(readLock);</span><br><span class="line">            //demo.handleRead(lock);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    Runnable writeRunnale=new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          demo.handleWrite(writeLock,new Random().nextlnt());</span><br><span class="line">          //demo.handleWrite(lock,new Random().nextlnt()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;18;i++)&#123;</span><br><span class="line">       new Thread(readRunnale).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">         new Thread(writeRunnale).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建读锁和写锁。读开启1 8 个读线程,写开启2个写线程。<br>由 于这里使用了读写分离，因此，读线程完全并行，而写会阻塞读，因此，实际上这段代码运行 大约2秒多就能结束(写线程之间是实际串行的)。而如果注释的两行ReentrantLock可重入锁，<br>那么所有的读和写线程 之间都必须相互等待，因此整个程序的执行时间将长达20余秒。</p><hr><h1 id="倒计时器：CountDownLatch"><a href="#倒计时器：CountDownLatch" class="headerlink" title="倒计时器：CountDownLatch"></a>倒计时器：CountDownLatch</h1><p>CountDownLatch是一个非常实用的多线程控制工具类。<br>把门锁起来，不让里面的线程跑出来。因 此，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。<br>要等检查线程执行完才能执行(或者说前置线程)<br><code>public CountDownLatch(int n)   ----让n个线程执行完之后,再执行</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchDemo implements Runnable &#123;</span><br><span class="line">    static final CountDownLatch end = newCountDownLatch(10);</span><br><span class="line">    static final CountDownLatchDemo demo=new CountDownLatchDemo();</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span> () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //模拟检查任务</span><br><span class="line">          Thread.sleep(new Random().nextlnt(10)*1000);</span><br><span class="line">          System.out.printIn(<span class="string">&quot;check     complete&quot;</span>);</span><br><span class="line">          end.countDown();</span><br><span class="line">        &#125; catch (工nterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       ExecutorService <span class="built_in">exec</span> = Executors.newFixedThreadPool(10);</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">           exec.submit(demo);</span><br><span class="line">        &#125;     </span><br><span class="line">       end.await ();  //等待检查</span><br><span class="line">       System.out.printin (<span class="string">&quot;执行冤比线程&quot;</span>);</span><br><span class="line">       exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成一个<code>CountDownLatch</code>实例。计数数量为10。这表示需要有10个线 程完成任务，等待在<code>CountDownLatch</code>上的线程才能继续执行。<br><code>CountDownLatch.countdown()</code>方法，也就是通知<code>CountDownLatch</code>, 一个线程己经完成了任务， 倒计时器可”以减1啦。<br><code>CountDownLatch.await()</code>方法，要求主线程等待所有10 个检查任务全部完成。待10个任务全部完成后，主线程才能继续执行。<br>主线程在<code>CountDownLatch</code>上等待，当所有检查任务全部完成后，主线程方能继续执行。</p><hr><h1 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h1><p><code>CyclicBarrier</code>是另外一种多线程并发控制实用工具。和<code>CountDownLatch</code>非常类似，它也可 以实现线程间的计数等待，但它的功能比<code>CountDownLatch</code>更加复杂且强大。<br><code>CyclicBarrier</code>可以理解为循环栅栏。栅栏就是一种障碍物，比如，通常在私人宅邸的周围 就可以围上一圈栅栏，阻止闲杂人等入内。这里当然就是用来阻止线程继续执行，要求线程在 栅栏处等待。前面Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计 数器设置为1 0 , 那么凑齐第一批1 0 个线程后，计数器就会归零，然后接着凑齐下一批1 0 个线 程，这就是循环栅栏内在的含义。<br><code>CyclicBarrier</code>的使用场景也很丰富。比如，司令下达命令，要求1 0 个士兵一起去完成一项 任务。这时，就会要求1 0 个士兵先集合报道，接着，一起雄赳赳气昂昂地去执行任务。当1 0 个士兵把自己手头的任务都执行完成了，那么司令才能对外宣布，任务完成！<br>比CountDownLatch略微强大一些，<code>CyclicBarrier</code>可以接收一个参数作为<code>barrierAction</code>。所 谓<code>barrierAction</code>就是当计数器一次计数完成后，系统会执行的动作。如下构造函数，其中，<code>parties</code> 表示计数总数，也就是参与的线程总数。<br><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><br>下面的示例使用CyclicBarrier演示了上述司令命令士兵完成任务的场景。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">public static class Soldier implements Runnable &#123;</span><br><span class="line">       private String soldier;</span><br><span class="line">       private final CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">       Soldier(CyclicBarrier cyclic, String soldierName) &#123;</span><br><span class="line">           this.cyclic = cyclic;</span><br><span class="line">           this.soldier = soldierName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               //等待所有士兵到齐</span><br><span class="line">               cyclic.await();</span><br><span class="line">               doWork();</span><br><span class="line">               //等待所有士兵完成工作实战Java高并发程序设计</span><br><span class="line">              cyclic.await(); </span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125; catch (BrokenBarrierException e) &#123; </span><br><span class="line">              e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       void <span class="function"><span class="title">doWork</span></span>()  &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep(Math.abs(new Random().nextlnt()%10000)); </span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">          System, out. <span class="built_in">print</span> In (soldier + 〃：任务完成•’ );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public static class BarrierRun implements Runnable &#123; </span><br><span class="line">       boolean flag;</span><br><span class="line">       int N; </span><br><span class="line">       public BarrierRun(boolean flag, int N) &#123;</span><br><span class="line">          this.flag = flag;</span><br><span class="line">          this.N = N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              System, out. <span class="built_in">print</span> In (n 司令：[士兵知+ 〃个，任务完成！ ]H); </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System, out.printin (** 司令：[士兵〃+N + 〃个，集合完毕！]’ ’</span><br><span class="line">              flag = <span class="literal">true</span>;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String args[]) throws InterruptedException &#123; </span><br><span class="line">       final int N = 10;</span><br><span class="line">       Thread[] allSoldier=new Thread[N];</span><br><span class="line">       boolean flag = <span class="literal">false</span>;</span><br><span class="line">CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag,- N))；第3章roK并发包</span><br><span class="line">       //设置屏障点，主要是为了执行这个方法</span><br><span class="line">       System, out .printin (n集合队伍！ 〃)；</span><br><span class="line">       <span class="keyword">for</span> (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">          System, out .printin (n士兵<span class="string">&quot;+i+,,报道！&quot;</span>)；</span><br><span class="line">          allSoldier [i ] =new Thread (new Soldier (cyclic, 〃士兵〃 + i)); </span><br><span class="line">          allSoldier[i].start();</span><br></pre></td></tr></table></figure><p>上述代码第5 7 行，创建了<code>CyclicBarrier</code>实例，并将计数器设置为1 0 , 并要求在计数器达 到指标时，执行第4 3 行的r u n ( ) 方法。每一个士兵线程会执行第1 1 行定义的<code>run( )</code> 方法。在第 14行，每一个士兵线程都会等待，直到所有的士兵都集合完毕。集合完毕后，意味着<code>CyclicBarrier</code> 的一次计数完成，当再一次调用<code>CyclicBarrier.await()</code>时，会进行下一次计数。第15行，模拟了 士兵的任务。当一个士兵任务执行完毕后，他就会要求<code>CyclicBarrier</code>开始下一次计数，这次计 数主要目的是监控是否所有的士兵都己经完成了任务。一旦任务全部完成，第3 5 行定义的 <code>BarrierRun</code>就会被调用，打印相关信息。</p><p><code>CyclicBarrier.await()</code>方法可能会抛出两个异常。一个是<code>InterruptedException</code>,也就是在等待 过程中，线程被中断，应该说这是一个非常通用的异常。大部分迫使线程等待的方法都可能会 抛出这个异常，使得线程在等待时依然可以响应外部紧急事件。另外一个异常则是CyclicBarrier 特有的BrokenBarrierException。一旦遇到这个异常，则表示当前的CyclicBarrier B经破损了， 可能系统己经没有办法等待所有线程到齐了。如果继续等待，可能就是徒劳无功的，因此，还 是就地散货，打道回府吧！上述代码第18—22行处理了这2种异常。<br>如果我们在上述代码的第63行后，插入以下代码，使得第5个士兵线程产生中断： if(i==5){<br>allSoldier[0].interrupt(); }<br>如果这样做，我们很可能就会得到1个InterruptedException和9个BrokenBarrierExceptiono 这个InterruptedException就是被中断线程抛出的。而其他9个BrokenBarrierException,则是等 待在当前Cy c l ic Ba r ri e r 上的线程抛出的。这个异常可以避免其他9 个线程进行永久的、无谓的 等待(因为其中一个线程已经被中断，等待是没有结果的)。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发笔记-锁优化</title>
      <link href="2020/01/22/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>2020/01/22/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h1><p>比如：<strong>避免死锁、减小锁粒度、锁分离、锁粗化、锁细化(减少锁时间)、读写代替独占</strong><br>多核使用多线程可以明显地提高系统的性能。也会额 外增加系统的开销。<br>对于单任务或者单线程的应用而言，其主要资源消耗都花在任务本身。它既不需要维护并行数据结构间的一致性状态，也不需要为线程的切换和调度花费时间。<br>多线程除了处理需求，还要维护多线程环境的特有信息，如线程本身的元数据、线 程的调度、线程上下文的切换等。</p><h2 id="1人能做的锁优化"><a href="#1人能做的锁优化" class="headerlink" title="1人能做的锁优化"></a>1人能做的锁优化</h2><h3 id="1-1减小锁持有时间"><a href="#1-1减小锁持有时间" class="headerlink" title="1.1减小锁持有时间"></a>1.1减小锁持有时间</h3><p>在锁竞争过程中，单个线程对锁的持有时间与 系统性能有着直接的关系。<br>应该尽可能地减少对某个锁的占有时间， 以减少线程间互斥的可能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void syncMethodO &#123;</span><br><span class="line">othercodel(); mutextMethod(); othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncMethodO</code>方法中，只有<code>mutextMethod()</code>方法是有同步需要的，而<code>othercodel()</code>和 <code>othercode2()</code>并不需要做同步控制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">syncMethod2</span></span>()&#123; </span><br><span class="line">othercodel(); </span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">mutextMethod();</span><br><span class="line">othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种技术手段在J D K 的源码包中比如处理正则表达式 的 Pattern 类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Matcher matcher(CharSequence input) &#123;</span><br><span class="line"><span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line"><span class="keyword">if</span> (!compiled)</span><br><span class="line">compile();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Matcher m = new Matcher(this, input);</span><br><span class="line"><span class="built_in">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。</strong></p><hr><h3 id="1-2减小锁粒度—-结构层面的分割"><a href="#1-2减小锁粒度—-结构层面的分割" class="headerlink" title="1.2减小锁粒度—-结构层面的分割"></a>1.2减小锁粒度—-结构层面的分割</h3><p><code>ConcurrentHashMap</code>类的实现。内部细分了若干个小的HashMap,称之为段(Segment)。 默认16 个段<br>新增时，不是将整个Map加锁，根据hashcode计算所属段，对该段加锁，并完成put()操作。<br>多个线程同时插入时，只要新增的不存放在同一个段中，则线程间便可以做到真正的并行。<br>理论上<code>ConcurrentHashMap</code>可以同时接受16个线程同时插入(如果都插入不同的段中)，<br>在第5 〜 6 行根据key , 获得段的序号。接着在第9 行得到段，然后将数据插 入给定的段中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">  Segment&lt;KrV&gt; s;</span><br><span class="line">  <span class="keyword">if</span> (value ==  null)</span><br><span class="line">  throw new NullPointerException(); 05 int <span class="built_in">hash</span> = <span class="built_in">hash</span>(key);</span><br><span class="line">  int j = (<span class="built_in">hash</span> »&gt; segmentshift) &amp; segmentMask;</span><br><span class="line">  <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject                // nonvolatile; recheck</span><br><span class="line">    (segments, (j « SSHIFT) + SBASE)) == null)      // <span class="keyword">in</span> ensureSegment</span><br><span class="line">    s = ensureSegment(j);</span><br><span class="line">  <span class="built_in">return</span> s.put(key, <span class="built_in">hash</span>, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，减少锁粒度存在一个问题，即：<br><strong>当系统需要取得全局锁时，其消耗的资源比较多。</strong><br>当试图访 问<code>ConcurrentHashMap</code> 全局信息时，就会需要同时取得所有段的锁。<br>比如 <code>ConcurrentHashMap</code>的<code>size()</code>方法，它将返回 <code>ConcurrentHashMap</code> 的有效表项的数量，即 <code>ConcurrentHashMap</code> 的全部有效表项之和。要获取这个信息需要取得所有子段的锁，因此，其 size()方法的部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;对所有的段加锁 &quot;统计总数</span><br><span class="line">&#x2F;&#x2F;释放所有的锁</span><br><span class="line">for (int i &#x3D; 0; i &lt; segments.length; ++i) segments[i].lock();</span><br><span class="line">for (int i &#x3D; 0; i &lt; segments.length; ++i) sum +&#x3D; segments[i].count;</span><br><span class="line">for (int i &#x3D; 0; i &lt; segments.length; ++i) segments[i].unlock();</span><br></pre></td></tr></table></figure><p>可以看到在计算总数时，先要获得所有段的锁，然后再求和。<br>但是，ConcurrentHashMap 的<code>size()</code>方法并不总是这样执行，<br>事实上，<code>size()</code>方法会先使用无锁的方式求和，如果失败才会尝试这种加锁的方法。但不管这么说，在<strong>高并发场合ConcurrentHashMap的size()的性能依然要差于同步的HashMap。</strong><br><strong>只有在类似于size()获取全局信息的方法调用并不频繁时，再考虑减小锁粒度的方法</strong></p><p><strong>注意：所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进 而提高系统的并发能力。</strong></p><hr><h3 id="1-3读写锁替换独占锁—-业务层面分割"><a href="#1-3读写锁替换独占锁—-业务层面分割" class="headerlink" title="1.3读写锁替换独占锁—-业务层面分割"></a>1.3读写锁替换独占锁—-业务层面分割</h3><p>好处:避免了读和读的竞争     适用于:读多写少</p><p>注意：在读多写少的场合，使用读写锁可以有效提升系统的并发能力。</p><h3 id="1-4锁分离"><a href="#1-4锁分离" class="headerlink" title="1.4锁分离"></a>1.4锁分离</h3><p>读写锁根据读写操作功能上的不同， 进行了有效的锁分离。<br>依据应用程序的功能特点，利用分离思想，也可以对独占锁进行分离。<br>例如在<code>LinkedBlockingQueue</code>的实现中，<code>take()</code>函数(存)和<code>put()</code>函数(取)<br>虽然两个写操作,但是分别作用于队列的前端和尾端(链表头尾)<br>如果使用独占锁，则要求在两个操作进行时获取当前队列的独占锁，那么<code>take()</code> 和<code>put()</code>操 作就不可能真正的并发，在运行时，它们会彼此等待对方释放锁资源。<br>所以JDK用两把锁分离了 <code>take()</code> 和<code>put()</code>操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** take ()函数需要持有 takeLock  */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock ();  </span><br><span class="line">private final Condition notEmpty = takeLock.newCondition(); </span><br><span class="line">/**put ()函数需要持有putLock**/</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();  </span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>定义** takeLock<strong>和</strong>putLock**，它们分别在<code>take()</code>操作和<code>put()</code>操作中使用。<br><code>take()</code>函数和<code>put()</code>函数就此相互独立，只需要在<code>take()</code>和<code>take()</code> 间、<code>put()</code>和<code>put()</code>间分别对takeLock和putLock进行竞争。<br>函数<code>take()</code>的实现如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final Atomiclnteger count = this.count; </span><br><span class="line">    final ReentrantLock takeLock = this.takeLock; </span><br><span class="line">    takeLock.locklnterruptibly(); //不能有两个线程同时取数据</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //如果当前没有可用数据，一直等待 </span><br><span class="line">            <span class="keyword">while</span> (count.get() == 0) </span><br><span class="line">                notEmpty.await();  //等待，put()操作的通知</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">            notEmpty.signal();    //通知其他未中断的线程</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125;</span><br><span class="line">    x = extract ();       //取得第一个数据</span><br><span class="line">    //数量减1，原子操作，因为会和put (&#125;函数同时访问count</span><br><span class="line">    //注意：变量c是 count减1前的值</span><br><span class="line">    c = count.getAndDecrement();   </span><br><span class="line">    <span class="keyword">if</span> (c &gt; 1)  </span><br><span class="line">        notEmpty.signal ();  //通知其他take()操作</span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        takeLock.unlock(); //释放锁</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity) signalNotFull();  //通知put()操作，己有空余空间</span><br><span class="line">    <span class="built_in">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数put()的实现如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123; </span><br><span class="line">    <span class="keyword">if</span> (e == null) throw new NullPointerException(); </span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock putLock = this.putLock; </span><br><span class="line">    final Atomiclnteger count = this.count; </span><br><span class="line">    putLock.lockInterruptibly(); //不能有两个线程同时进行put ()</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity)   //如果队列己经满了</span><br><span class="line">                notFull.await();   //等待</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">             notFull.signal();    //通知未中断的线程插入数据</span><br><span class="line">             throw ie; </span><br><span class="line">        &#125;</span><br><span class="line">        insert (e);</span><br><span class="line">        c = count.getAndlncrement();    //更新总数，变量c是count加1前的值 </span><br><span class="line">        <span class="keyword">if</span> (c + 1 &lt; capacity) </span><br><span class="line">            notFull.signal();   //有足够的空间，通知其他线程</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            putLock.unlock();   //释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == 0) signalNotEmpty();  //插入成功后，通知take ()操作取数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过takeLock和putLock两把锁，LinkedBlockingQueue实现了取数据和写数据的分离，使 两者在真正意义上成为可并发的操作。</p><hr><h3 id="1-5锁粗化-—-对应第一个"><a href="#1-5锁粗化-—-对应第一个" class="headerlink" title="1.5锁粗化 —-对应第一个"></a>1.5锁粗化 —-对应第一个</h3><p>通常情况下每个线程持有锁的时间尽量短，用完资源，应该立即释放锁。才能轮到别的线程<br>物极必反<br>同一个锁不停地进行请求、同步和释放，其本 身也会消耗系统宝贵的资源，反而不利于性能的优化。<br>so,<strong>虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时，便会把所有的 锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">demoMethod</span></span>()&#123; </span><br><span class="line">    synchronized(lock) &#123; </span><br><span class="line">    //<span class="keyword">do</span> sth. </span><br><span class="line">    &#125;</span><br><span class="line">    //做其他不需要的同步的工作，但能很快执行完毕 </span><br><span class="line">    synchronized(lock)&#123; </span><br><span class="line">    //<span class="keyword">do</span> sth. </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    会被整合成如下形式:</span><br><span class="line">public void <span class="function"><span class="title">demoMethod</span></span>()&#123; </span><br><span class="line">    //整合成一次锁请求</span><br><span class="line">    synchronized(lock)&#123;</span><br><span class="line">    //<span class="keyword">do</span> sth.</span><br><span class="line">    //做其他不需要的同步的工作，但能很快执行完毕</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尤其当在循环内请求锁时。<br>每次循环都有申请锁和释放锁的操作????废物</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=O;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">     synchronized(lock) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，一种更加合理的做法应该是在外层只请求一次锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock)&#123; </span><br><span class="line">     <span class="keyword">for</span>(int i=O;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：性能优化就是根据运行时的真实情况对各个资源点进行权衡折中的过程。锁粗 化的思想和减少锁持有时间是相反的，但在不同的场合，它们的效果并不相同。 所以大家需要根据实际情况，进行权衡。</p><hr><h2 id="2-虚拟机内部的锁优化"><a href="#2-虚拟机内部的锁优化" class="headerlink" title="2 虚拟机内部的锁优化"></a>2 虚拟机内部的锁优化</h2><h3 id="1锁偏向"><a href="#1锁偏向" class="headerlink" title="1锁偏向"></a>1锁偏向</h3><p>锁偏向:一种针对加锁操作的优化手段。<br>它的核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。<br>这样就节省了大量有关锁申请的操作，从而提高了程序性能。<br>因此，<strong>对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。</strong><br>而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同 的锁。这样偏向模式会失效，因此还不如不启用偏向锁。<br>使用Java虚拟机参数 <code>-XX:+UseBiasedLocking</code> 可以开启偏向锁。</p><h3 id="2轻量级锁"><a href="#2轻量级锁" class="headerlink" title="2轻量级锁"></a>2轻量级锁</h3><p>如果<strong>偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。</strong><br>轻量级锁的操作也很轻便，它只是<strong>简单地将对象头部作为指针，指向持有锁的线程堆栈的内部， 来判断一个线程是否持有对象锁。</strong><br>如果线程获得轻量级锁成功，则可以顺利进入临界区。<br>如果 轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量 级锁。</p><p>其实还有重量锁;<br><img src="/2020/01/22/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E9%94%81%E4%BC%98%E5%8C%96/1.png" alt="1"></p><h3 id="3自旋锁"><a href="#3自旋锁" class="headerlink" title="3自旋锁"></a>3自旋锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起做最后的努力 ——自旋锁。<br>当前线程暂时无法获得锁，但不知道时候可以获得锁。没准很快就可以得到锁。<br>如果这样，粗暴地挂起线程没必要。<br>系统会进行一次赌注：假设很快，线程可以得到这把锁。<br><strong>虚 拟机会让当前线程做几个空循环（这也是自旋的含义）</strong>，在经过若干次循环后，如果可以得到 锁，那么就顺利进入临界区。(此时cpu未必在空转,好像有个参数能控制,有时候也会挂起)<br>如果还不能获得锁，才会真实地将线程在操作系统层面挂起。(不确定)</p><h3 id="4锁消除"><a href="#4锁消除" class="headerlink" title="4锁消除"></a>4锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，<br><strong>去除不可能存在共享资源竞争的锁。(自动无视没用的锁)</strong><br>通过锁消除，可以节省毫无意义的请求锁时间。<br>如果不存在竞争，还为毛加锁？<strong>怕程序员瞎鸡儿加一些没有卵用的锁</strong><br>比如，在一个不可能存在并发竞争的场合使用Vectoro ( 内部使用了 synchronized请求锁)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String[] <span class="function"><span class="title">createStrings</span></span>()&#123;</span><br><span class="line">    Vector&lt;String&gt; v=new Vector&lt;String&gt;(); </span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">        v.add(Integer.toString(i)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> v.toArray(new String[]&#123;&#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量v 只是一个 单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有的数据，因此不可能被其他线 程访问。<br>如果虚拟机检测到 这种情况，就会将这些无用的锁操作去除。<br><strong>锁消除涉及的一项关键技术为逃逸分析。就是观察某一个变量是否会逃出某 一个作用域。</strong><br>虚拟机才 可以大胆地将v内部的加锁操作去除。<br>如果createStrings()返回的不是String数组，而是v本身， 那么就认为变量v 逃逸出了当前函数，也就是说v 有可能被其他线程访问。<br>如果是这样，虚拟 机就不能消除v中的锁操作。<br>逃逸分析必须在<code>-server</code>模式下进行，可以使用<code>-XX:+DoEscapeAnalysis</code>参数打开逃逸分析。 使用<code>-XX:+EliminateLocks</code>参数可以打开锁消除。</p><p><strong>偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。</strong><br>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个<br>线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。<br>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（ 偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。<br>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plsql注册码</title>
      <link href="2020/01/12/plsql%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
      <url>2020/01/12/plsql%E6%B3%A8%E5%86%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>贫穷的备份<br>Product Code：    <code>4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz</code><br>serial Number：    <code>601769</code><br>password：           <code>xs374ca</code></p><p>PLSQL Developer 12.0.7 注册码<br>product code： <code>hh。 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le</code><br>serial Number：<code>226959</code><br>password: <code>xs374ca</code></p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构2-队列,栈</title>
      <link href="2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E9%98%9F%E5%88%97-%E6%A0%88/"/>
      <url>2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E9%98%9F%E5%88%97-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>先进后出,类似吃了吐,队列就是…………………<br>操作受限”的线性表<br>栈既可以用<strong>数组</strong>来实现，也可以用<strong>链表</strong>来实现。<br>用数组实现的栈-顺序栈，用链表实现的栈-链式栈。<br><img src="/2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E9%98%9F%E5%88%97-%E6%A0%88/1.png" alt="1"></p><h2 id="操作系统为什么用栈结构"><a href="#操作系统为什么用栈结构" class="headerlink" title="操作系统为什么用栈结构?"></a>操作系统为什么用栈结构?</h2><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。<br>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><p>假设a函数调用b函数，进入b函数后，将一些临时变量作为一个栈帧入栈，当函数执行完之后，<br>将这个函数对应的所有栈帧出栈，此时b函数的栈帧都在上面是后进来的但会先出去，<br>b函数栈帧都清除后回到a函数。<br>这也正好符合栈这种后进先出的数据结构。</p><h2 id="表达式求值为什么用栈"><a href="#表达式求值为什么用栈" class="headerlink" title="表达式求值为什么用栈?"></a>表达式求值为什么用栈?</h2><p>两个栈实现加减乘除： </p><ol><li>一个栈存储数据，另一个栈存储操作符； </li><li>如果当前操作符的优先级比栈顶的要高，说明这一操作符需要先执行，但是数据还没有准备好，因此先将操作符保存起来，等数据准备好了再执行； </li><li>如果当前操作符的优先级比栈顶的要低，说明栈中的操作符需要先执行，那么先从数据栈中弹出两个数据，从操作符栈中弹出一个操作符，将这个结果先计算，并将计算出来的结果再入栈</li></ol><h2 id="浏览器的前进、后退功能"><a href="#浏览器的前进、后退功能" class="headerlink" title="浏览器的前进、后退功能"></a>浏览器的前进、后退功能</h2><p>使用两个栈X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。<br>还有括号匹配等问题………………….</p><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列:"></a>队列:</h1><p>吃了…..<br>跟栈一样，也是操作受限的线性表数据结构。<br>循环队列、阻塞队列、并发队列、优先队列<br><strong>数组</strong>实现的队列-顺序队列，<strong>链表</strong>实现的队列-链式队列。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在队列基础上增加阻塞操作。在队列为空时，从头取数据会被阻塞。直到队列中有数据了才能返回；<br>如果队列满了，插入数据会被阻塞，直到队列中有空闲位置后再插入，然后再返回。<br><strong>“生产者 - 消费者模型”可以实现</strong></p><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>线程安全的队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，<br>但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。<br>实际上，基于数组的循环队列，利用 <strong>CAS 原子操作</strong>，可以实现非常<strong>高效的并发队列</strong>。</p><p><code>CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化， 如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。</code></p><h2 id="线程池没有空闲线程时线程池该如何处理？各种处理策略又是如何实现的呢？"><a href="#线程池没有空闲线程时线程池该如何处理？各种处理策略又是如何实现的呢？" class="headerlink" title="线程池没有空闲线程时线程池该如何处理？各种处理策略又是如何实现的呢？"></a>线程池没有空闲线程时线程池该如何处理？各种处理策略又是如何实现的呢？</h2><p>第一种是非阻塞的处理方式，直接拒绝任务请求<br>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理–队列</p><p>两种实现方式对于排队请求又有什么区别呢？<br>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），<br>但是可能会导致过多的请求排队等待，响应时间过长。<br>针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，<br>接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。<br>不过，要设置一个合理的队列大小。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源.</p><p><strong>对于大部分资源有限的场景，当没有空闲资源时，基本都能通过“队列”这种数据结构实现请求排队</strong>。<code>消息队列,线程池.连接池</code></p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列:"></a>优先队列:</h2><p>出队顺序是按照优先级来的；在有些情况下，可能需要找到元素集合中的最小或者最大元素，可以利用优先队列ADT来完成操作，优先队列ADT是一种数据结构，它支持插入和删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素）；</p><p>说到底还是一种队列<br>二叉堆只是优先队列的一种是实现方式,还有别的实现比如红黑树treap等<br>所以优先队列和堆不是一个同level的概念<br>PriorityQueue也是基于这个实现的。<br>插入操作不是O(n),退化成了O(logn)</p><p>小键值元素拥有最高的优先级，那么这种优先队列叫作<strong>升序优先队列</strong>（即总是先删除最小的元素）<br>大键值元素拥有最高的优先级，那么这种优先队列叫作<strong>降序优先队列</strong>（即总是先删除最大的元素）</p><hr><h1 id="队列和栈的转化"><a href="#队列和栈的转化" class="headerlink" title="队列和栈的转化"></a>队列和栈的转化</h1><h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><p>1、使用两个栈，一个栈（stackPush）用于元素进栈，一个栈（stackPop）用于元素出栈；<br>2、<code>pop()</code> 或者 <code>peek()</code> 的时候：<br>（1）如果 <code>stackPop</code> 里面有元素，直接从 <code>stackPop</code> 里弹出或者 peek 元素；<br>（2）如果 <code>stackPop</code> 里面没有元素，一次性将 <code>stackPush</code> 里面的所有元素倒入 <code>stackPop。</code><br>为此，可以写一个 <code>shift</code> 辅助方法，一次性将 <code>stackPush</code> 里的元素倒入 <code>stackPop。</code></p><p><code>注意： 一定要保证 `stackPop` 为空的时候，才能把元素从 `stackPush` 里拿到 `stackPop` 中。</code><br><img src="/2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E9%98%9F%E5%88%97-%E6%A0%88/1.gif" alt="1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MyQueue &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; stackPush; //push栈</span><br><span class="line">    private Stack&lt;Integer&gt; stackPop; //pop栈</span><br><span class="line">    </span><br><span class="line">    public <span class="function"><span class="title">MyQueue</span></span>() &#123; //初始化</span><br><span class="line">        stackPush = new Stack&lt;&gt;();</span><br><span class="line">        stackPop = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stackPush.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 辅助方法：一次性将 stackPush 里的所有元素倒入 stackPop</span><br><span class="line">     * 注意：1、该操作只在 stackPop 里为空的时候才操作，否则会破坏出队入队的顺序</span><br><span class="line">     * 2、在 peek 和 pop 操作之前调用该方法</span><br><span class="line">     */</span><br><span class="line">    private void <span class="function"><span class="title">shift</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.isEmpty()) &#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        <span class="built_in">shift</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">return</span> stackPop.pop();  //返回并删除</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(<span class="string">&quot;队列里没有元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">peek</span></span>() &#123;</span><br><span class="line">        <span class="built_in">shift</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">return</span> stackPop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(<span class="string">&quot;队列里没有元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean <span class="function"><span class="title">empty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> stackPush.isEmpty() &amp;&amp; stackPop.isEmpty(); //判断是否为空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h2><p>用两个队列实现栈的操作，其中 <code>queue1</code>用于存储栈内的元素<code>queue2</code>作为入栈操作的辅助队列。</p><p>入栈时，先将元素入队到<code>queue2</code>，<br>然后将 <code>queue1</code>的全部元素依次出队并入队到 <code>queue2</code>，<br>此时 <code>queue2</code>的前端的元素即为新入栈的元素，<br>再将 <code>queue1</code>和 <code>queue2</code>互换，则<code> queue1</code>的元素即为栈内的元素，<br>queue1的前端和后端分别对应栈顶和栈底。</p><p>由于每次入栈操作都确保 <code>queue1</code>的前端元素为栈顶元素，<br>因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除<code> queue1</code>的前端元素并返回即可，<br>获得栈顶元素操作只需要获得 <code>queue1</code>的前端元素并返回即可（不移除元素）。</p><p>由于 <code>queue1</code>用于存储栈内的元素，判断栈是否为空时，只需要判断 <code>queue1</code>是否为空即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">MyStack</span></span>() &#123;</span><br><span class="line">        queue1 = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = new LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    public int <span class="function"><span class="title">top</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    public boolean <span class="function"><span class="title">empty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：入栈操作<code> O(n)</code>，其余操作都是 <code>O(1)</code>。</p><hr><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>栈和队列虽然是比较基础的数据结构,但是有各自的局限性<br>双端队列既可以实现栈的操作也可以实现队列的操作<br>通过addFirst/Last,removeFirst/Last,getFirst/Last等<br>java也推荐使用双端队列deque接口,随便玩<br>毕竟java的stack基本是费代码了,JDK1的失败产物…</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构1-数组,链表</title>
      <link href="2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
      <url>2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组（Array）是一种线性表数据结构。它用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据。<br>1.线性表:线性表上的数据最多只有前和后两个方向。数组，链表、队列、栈等<br>非线性表，如二叉树、堆、图等。在非线性表中，数据之间并不是简单的前后关系。</p><p>2.连续的内存空间和相同类型的数据:“随机访问”牛逼。但删除、插入时，为了保证连续性，要大量的数据搬移。<br><img src="/2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/1.png" alt="1"><br><img src="/2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/2.png" alt="1"></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入:"></a>插入:</h2><p>末尾插入元素，不需要移动数据，这时的时间复杂度为 <code>O(1)</code>。<br>开头插入元素,时间复杂度是<code>O(n)</code>。平均情况时间复杂度为:<code>O(n)</code>。<br>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。</p><p>但<strong>如果数组中存储的数据没有规律</strong>，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，<br>为了避免大规模的数据搬移，** 直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置!!! **。<br>假设数组 a[10]中存储了如下 5 个元素：<code>a，b，c，d，e</code>。现需将元素 <code>x</code> 插入到第 <code>3</code> 个位置。只需将 <code>c</code> 放入到 <code>a[5]</code>，将 <code>a[2]</code>赋值为 <code>x</code> 。<br>最后如下： <code>a，b，x，d，e，c</code>。利用这种处理技巧，在特定场景下，在第 <code>k</code> 个位置插入一个元素的时间复杂度就会降为 <code>O(1)</code>。<br>先把元素插入到数组的最后一个位置，在吧这个元素和你要插入的位置的元素互换</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h2><p>复杂度也为 O(n)。<br>实际上，在某些特殊场景下，不一定非得追求数组中数据的连续性。如果将多次删除操作一起执行，效率是不是高？-<strong>延迟执行，集中执行，使得更加节省资源</strong>。<br>数组 <code>a[10]</code>中存储了 4 个元素：<code>a，b，c，d</code>。现在，要依次删除 <code>a，b，c</code> 三个元素。为避免<code> d</code>数据会被搬移三次，可以先记录下已经删除的数据。<br>每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>JVM 标记清除垃圾回收算法？MySQL的在B+树上的删除也是这么做的。</p><h2 id="和容器比"><a href="#和容器比" class="headerlink" title="和容器比:"></a>和容器比:</h2><p><code>ArrayList</code> 最大的优势就是可以将很多数组操作的细节封装起来。比如插入、删除数据时需要搬移其他数据等。支持动态扩容。<br>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。–ArrayList 也是但是不用手动<br><code>ArrayList</code> 无法存储基本类型，比如<code> int、long</code>，需要封装为<code> Integer、Long</code> 类</p><h2 id="如何实现根据下标随机访问数组元素？为什么从0开始标号"><a href="#如何实现根据下标随机访问数组元素？为什么从0开始标号" class="headerlink" title="如何实现根据下标随机访问数组元素？为什么从0开始标号?"></a>如何实现根据下标随机访问数组元素？为什么从0开始标号?</h2><p>根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址<br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 <code>data_type_size</code> 表示数组元素类型的大小。这个例子里，数组中存储的是 int 类型数据，所以 <code>data_type_size</code> 就为 4 个字节(32位)。<br>“下标”最确切的定义应该是“<strong>偏移（offset）</strong>”。<code>a[0]</code>就是偏移为 <code>0</code> 的位置，也就是首地址，<code>a[k]</code>就表示偏移 <code>k</code> 个 <code>type_size</code> 的位置，<br>但是，如果数组从 1 开始计数，那我们计算数组元素 <code>a[k]</code>的内存地址就会变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br>但是有的语言比如Python还支持负数下标,为什么……..</p><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用<br>单链表、双向链表和循环链表</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表:"></a>单链表:</h2><p>内存块–结点-。<br>后继指针 –next。<br>链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表:"></a>循环链表:</h2><p>尾结点指针是指向链表的头结点</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表:"></a>双向链表:</h2><p>后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。双向链表要比单链表占用更多的内存空间<br>比单链表费空间好在哪了?<br><strong>从链表中删除一个数据无外乎这两种情况：</strong><br>删除结点中“值等于某个给定值”的结点；<br><strong>删除给定指针指向的结点。</strong><br>对于第一种，不管是单链表还是双向链表，都要先遍历再删除,虽然删除是O(1)但是遍历是O(n),总时间复杂度为 O(n)。<br>对于第二种，已经找到了要删除的结点，但要找到被删节点的上一个节点,改变上一个节点的指向，单链表从头结点开始遍历链表，<br>双向链表已经保存了前驱结点的指针，不需要遍历。<strong>单链表删除操作需要 O(n) 的时间复杂度，双向链表只需要 O(1) **<br>同理在链表的某个指定结点前面插入一个结点，双向链表也是O(1)。<br>对于一个有序链表，双向链表的按值查询的效率也要比单链表高–**类似有序数组双指针二分查询</strong><br>所以双向应用更多:LinkedList/LinkedHashMap</p><hr><h1 id="数组链表对比"><a href="#数组链表对比" class="headerlink" title="数组链表对比:"></a>数组链表对比:</h1><p><img src="/2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/3.png" alt="3"><br>数组可以借助 <strong>CPU 的缓存机制</strong>，预读数组中的数据，访问效率更高。<br>链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。<br>数组的缺点是大小固定，如果声明的数组过大，没有足够的连续内存空间分配给它，导致“内存不足（out of memory）<br>如果声明的数组过小，不够用只能再申请一个更大的内存空间，把原数组拷贝进去，费时。<br>链表本身没有大小的限制，<strong>天然地支持动态扩容</strong><br>链表费内存,进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，<strong>容易造成内存碎片</strong>，就有可能会导致<strong>频繁的 GC</strong>（Garbage Collection，垃圾回收）</p><p>“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”?–<strong>错!</strong><br>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。<br>即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。<br>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。对</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-3小垃圾之引用类型</title>
      <link href="2019/12/15/JVM-3%E5%B0%8F%E5%9E%83%E5%9C%BE%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>2019/12/15/JVM-3%E5%B0%8F%E5%9E%83%E5%9C%BE%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>引用分四种:强引用/软引用/弱引用/虚引用</p><h2 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用:"></a>1.强引用:</h2><p>new出来的对象,不会被删除</p><h2 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用:"></a>2.软引用:</h2><p>用来描述一些非必须，但仍有用的对象。内存足够时，软引用对象不会被回收，只有在内存不足时，系统会回收软引用对象，通常用于实现缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Drawable drawable = new BitmapDrawable(bitmap);</span><br><span class="line">SoftReference&lt;Drawable&gt; soft = new SoftReference&lt;Drawable&gt;(drawable);</span><br><span class="line"><span class="keyword">if</span>(soft!=null)&#123;</span><br><span class="line">    view.setImageResource(soft.get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要加载大图时，可以使用软引用，通过get()方法，获取图片对象，如果当前内存不足，则软引用会被回收，避免内存溢出发生。</p><h2 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用:"></a>3.弱引用:</h2><p>随时可能被垃圾回收器回收，无论内存是否足够，只要JVM开始进行垃圾回收，那些被弱引用关联的对象都会被回收。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(<span class="string">&quot;abc&quot;</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><h2 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用:"></a>4.虚引用:</h2><p>虚引用是所有引用类最脆弱的一个，如果一个对象持有虚引用，那么这个对象随时可能被回收，甚至不能通过get方法来获得其指向的对象。虚引用唯一的作用是，当其指向的对象被回收后，自己被加入到引用队列，用做记录该引用指向的对象已被销毁。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-2.事务,分布式锁</title>
      <link href="2019/12/01/redis-2-%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2019/12/01/redis-2-%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis通过<code>MULTI、EXEC、WATCH</code>等命令来实现事务功能。<br><strong>redis的事务就是多个命令一次性、按顺序地执行多个命令的机制,执行期间不会处理别的命令.坚持处理完才行</strong><br>流程:    事务开始—-&gt;命令入队——&gt;事务执行</p><ol><li><strong>开始:</strong><br>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端的flags属性中打开<code>REDIS_MULTI</code>标识来完成的</li><li><strong>命令入队:</strong><br>当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：<br>如果客户端发送的命令为四个<code>EXEC、DISCARD、WATCH、MULTI</code>命令的其中一个，那么服务器立即执行这个命令<br>如果客户端发送的命令是这四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回<code>QUEUED</code>回复<br><img src="/2019/12/01/redis-2-%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/1.png" alt="1"></li><li><strong>事务队列:</strong></li></ol><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面：<br>事务状态包含一个事务队列，以及一个已入队命令的计数器<br>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：<br>事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面<br><img src="/2019/12/01/redis-2-%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/2.png" alt="2"><br>4. <strong>执行事务:</strong><br>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端</p><hr><h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><p>分布式锁一般有三种实现方式：<strong>1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁</strong><br>redis主要是靠<code>setnx</code>和<code>getset</code>方法，这两个方法在<code>redisTemplate</code>分别是<code>setIfAbsent</code>和<code>getAndSet</code>方法,实现线程安全，因为redis是单线程，能保证线程的安全性，而且redis强大的读写能力能提高效率。</p><p><code>setnx key value</code><br>将 key 的值设为 value ，当且仅当 key 不存在。<br>若给定的 key 已经存在，则 SETNX 不做任何动作。<br>setnx  是『<code>SET if Not eXists</code>』(如果不存在，则 SET)的简写。<br>返回值：<br>设置成功，返回 1 。<br>设置失败，返回 0 。</p><p>使用SETNX完成同步锁的流程及事项如下：<br>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功<br>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间<br>释放锁，使用DEL命令将锁数据删除</p><p>分布式锁可用，要同时满足以下三个条件：<br><strong>互斥性</strong>: 在任意时刻，只有一个客户端能持有锁<br><strong>不会发生死锁</strong>: 即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁<br><strong>加锁和解锁必须是同一个客户端</strong>: 客户端自己不能把别人加的锁给解了<br>1.引入jedis依赖<br>2.配置yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedisPool.host&#x3D;127.0.0.1</span><br><span class="line">jedisPool.port&#x3D;6379</span><br></pre></td></tr></table></figure><p>配置config类略<br>3.加锁实现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RedisLock &#123;</span><br><span class="line">    private static final String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    private static final String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    private static final String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取分布式锁</span><br><span class="line">     *</span><br><span class="line">     * @param jedis      Redis客户端</span><br><span class="line">     * @param lockKey    锁标识</span><br><span class="line">     * @param requestId  请求标识</span><br><span class="line">     * @param expireTime 超期时间(秒)</span><br><span class="line">     * @<span class="built_in">return</span> 是否获取成功</span><br><span class="line">     */</span><br><span class="line">    public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime * 1000);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>加锁过程中主要使用的redis命令<code>set key value nx px expireTime</code>，当key不存在或者已经过期时，进行set操作，返回OK；当key存在时，不做任何操作<br>对应的Java代码为：<code>jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime * 1000)</code><br>key：传入锁标识<br>value：传入的是requestId，目的是为了实现加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>nxxx：NX<br>expx：PX<br>time：key的过期时间<br>setnx保证了如果已有key存在，则函数不会调用成功，只有一个客户端能持有锁，满足互斥性<br>设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁<br>将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端<br>4.解锁实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final Long RELEASE_SUCCESS = 1L;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放分布式锁</span><br><span class="line"> *</span><br><span class="line"> * @param jedis     Redis客户端</span><br><span class="line"> * @param lockKey   锁标识</span><br><span class="line"> * @param requestId 请求标识</span><br><span class="line"> * @<span class="built_in">return</span> 是否释放成功</span><br><span class="line"> */</span><br><span class="line">public static boolean releaseLock(Jedis jedis, String lockKey, String requestId) &#123;</span><br><span class="line">    String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。使用<code>eval()</code>方法执行Lua语言来实现可以确保上述操作是原子性的</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-6.count函数解析</title>
      <link href="2019/11/21/mysql-6-count%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>2019/11/21/mysql-6-count%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h1><p>MyISAM 引擎表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；前提 没有where 条件<br>InnoDB 行级锁，所以可能表的行数可能会被并发修改,需要把数据一行一行地从引擎里面读出来，然后累积计数。</p><h2 id="为什么-InnoDB-不跟-MyISAM-一样，也把数字存起来呢？"><a href="#为什么-InnoDB-不跟-MyISAM-一样，也把数字存起来呢？" class="headerlink" title="为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？"></a>为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？</h2><p>即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。<br>假设表 t 中现在有 10000 条记录，我们设计了三个用户并行的会话。<br>会话 A 先启动事务并查询一次表的总行数；<br>会话 B 启动事务，插入一行后记录后，查询表的总行数；<br>会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。<br><img src="/2019/11/21/mysql-6-count%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/1.png" alt="1"><br>三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。<br>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。<br>每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><h2 id="InnoDB对count-操作的时候还是做了优化的"><a href="#InnoDB对count-操作的时候还是做了优化的" class="headerlink" title="InnoDB对count(*) 操作的时候还是做了优化的"></a>InnoDB对count(*) 操作的时候还是做了优化的</h2><p><strong>会优先选择最小的非聚簇索引来扫表</strong><br>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。<br>所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。<br>因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一</strong>。</p><p>*<em><code>show table status</code> 命令有一个 <code>TABLE_ROWS </code>用于显示这个表当前有多少行,能代替count(</em>)吗?**<br>官方文档说**误差可能达到 40% 到 50%**。所以，<code>show table status </code>命令显示的行数也不能直接使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>MyISAM 表虽然 count(<em>) 很快，但是不支持事务；<br>show table status 命令虽然返回很快，但是不准确；<br>InnoDB 表直接 count(</em>) 会遍历全表，虽然结果准确，但会导致性能问题。</p><p><strong>如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？</strong></p><h2 id="自己计数-实现方法"><a href="#自己计数-实现方法" class="headerlink" title="自己计数,实现方法:"></a>自己计数,实现方法:</h2><ol><li><p>用缓存系统保存计数<br>用一个 Redis 服务来保存这个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？<br>没错，缓存系统可能会丢失更新。<br>Redis 的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis 中保存的值也加了 1，然后 Redis 异常重启了，重启后你要从存储 redis 数据的地方把这个值读回来，而刚刚加 1 的这个计数操作却丢失了。<br>当然了，这还是有解的。比如，Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。<br>异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。<br>但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</p></li><li><p>在数据库保存计数<br>把这个计数直接放到数据库里单独的一张计数表<br>首先，这解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。(日志)<br>再看看能不能解决计数不精确的问题<br><img src="/2019/11/21/mysql-6-count%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/2.png" alt="2"><br>虽然会话 B 的读操作仍然是在 T3 执行的，但是因为这时候更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见。<br>因此，会话 B 看到的结果里， 查计数值和“最近 100 条记录”看到的结果，逻辑上就是一致的。<br>从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？<br>应该先插入操作记录，再更新计数表。<br>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少了事务之间的锁等待，提升了并发度。</p></li></ol><h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p>COUNT(<em>) 的统计结果中，包含值为NULL的行数。(count(1)一样,没什么区别)<br>COUNT(列名)的统计结果中，不包含值为NULL的行数<br>COUNT(主键 id)会遍历整张表，判断是不为NULL的累加。<br>COUNT(列名)) &lt; COUNT(主键 id) &lt; COUNT(</em>) =COUNT(1)</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-2小垃圾</title>
      <link href="2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/"/>
      <url>2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一-什么是垃圾"><a href="#一-什么是垃圾" class="headerlink" title="一.什么是垃圾?"></a>一.什么是垃圾?</h1><p>没有引用指向他的时候就是垃圾?——引用计数法的思想<br>引用计数法的问题是:<strong>两个怕死的垃圾互相引用,明明是垃圾还占着内存.而且引用计数器增加了程序的开销</strong><br>所以JVM没有采用这用垃圾算法来识别垃圾(早期jvm用的是)<br>需要一个新的算法来决定你是不是垃圾——可达性分析算法</p><h2 id="可达性分析算法-根搜索算法"><a href="#可达性分析算法-根搜索算法" class="headerlink" title="可达性分析算法:(根搜索算法)"></a>可达性分析算法:(根搜索算法)</h2><p>通过判断对象的引用链是否可达来实现决定他是不是垃圾,<br>通过引入一个GC Roots的对象作为起点,从节点向下搜索,能通的路就是引用链,<br>当一个对象到节点没有能通的引用连就说明你是垃圾,<br><strong>不通下水道的马桶就是堵了,几遍两个马桶互通也</strong>…………</p><h2 id="什么可以做GC-Root"><a href="#什么可以做GC-Root" class="headerlink" title="什么可以做GC Root?"></a>什么可以做GC Root?</h2><p>虚拟机（栈帧中的本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（即一般说的native方法）中引用的对象<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，<br><font color="#ff0000"> </font><br><font color="#ff0000">至少要经历两次标记过程 </font> :如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，<br>那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize（）</code>方法。<br>当对象没有覆盖<code>finalize（）</code>方法，或者<code>finalize（）</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。<br>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫做<font color="#ff0000">F-Queue</font>的队列之中，<br>并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。<br>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，<br>这样做的原因是，如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，<br>甚至导致整个内存回收系统崩溃<br>。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后<strong>GC将对F-Queue中的对象进行第二次小规模的标记</strong>，<br>如果对象要在<code>finalize()</code>中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，<br>譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，<br>那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。下面例子可以看出<code>finalize()</code>被执行，但是它仍然可以存活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line">    public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line">    public void <span class="function"><span class="title">isAlive</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, I am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        SAVE_HOOK = this;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低,所以暂停0.5秒等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //代码和上面的一样 但是这次自救失败</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低,所以暂停0.5秒等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判定对象是否存活都与“<strong>引用</strong>”有关。!!!!!<br>(此处对于引用链相关内容以及对垃圾的定义仍不够具体,需要结合引用类型文档：JVM-3小垃圾之引用类型 )</p><hr><h1 id="二-什么时候回收垃圾"><a href="#二-什么时候回收垃圾" class="headerlink" title="二.什么时候回收垃圾?"></a>二.什么时候回收垃圾?</h1><p>　1cpu祖宗不忙的话自动进行回收<br>　2在堆内存存储满了之后调用回收,努力一下子,要是还不行只能抛异常了<br>　3主动调用System.gc()后尝试进行回收(不建议)</p><hr><h1 id="三-如何保证稳准狠的清理垃圾-垃圾回收算法"><a href="#三-如何保证稳准狠的清理垃圾-垃圾回收算法" class="headerlink" title="三.如何保证稳准狠的清理垃圾?垃圾回收算法"></a>三.如何保证稳准狠的清理垃圾?垃圾回收算法</h1><p>主要有四个:标价-清楚/标记-整理/复制/分代</p><h2 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h2><p><strong>标记</strong>：首先标记所有需要回收的对象<br><strong>清除</strong>：在标记完成后统一回收所有被标记的对象<br><strong>缺点</strong>:</p><ul><li>效率问题，标记和清除两个过程的效率都不高（回收后空间碎片过多，再次回收（即可达性分析时）有时需要遍历整个内存区域）。</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存,而不得不提前触发另一次垃圾收集动作。</li></ul><p><strong>优点</strong>(可忽略)：<br>不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><p><img src="/2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/2.png" alt="2"></p><h2 id="2-标记整理算法"><a href="#2-标记整理算法" class="headerlink" title="2.标记整理算法"></a>2.标记整理算法</h2><p>标记过程和标记清楚算法一样,但是标记完成之后让所有存活的对象向一端移动,然后直接清理掉端边界以外的内存<br><strong>优点：</strong></p><ul><li>经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。</li><li>使用这种方法空闲区域的位置是始终可知的，也<strong>不会再有碎片的问题</strong>了。</li></ul><p><strong>缺点：</strong> <strong>GC暂停的时间会增长</strong>，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址<br><img src="/2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/3.png" alt="3"></p><h2 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3.复制算法"></a>3.复制算法</h2><p>将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，<br>就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p><p><strong>复制算法比较适合于新生代</strong>（短生存期的对象），在老年代（长生存期的对象）中，<br>对象存活率比较高，如果执行较多的复制操作，效率将会变低，<strong>所以老年代一般会选用其他算法</strong>，如标记整理算法。<br>一种典型的基于Coping算法的垃圾回收是<code>stop-and-copy</code>算法，它<strong>将堆分成对象区和空闲区</strong>，在对象区与空闲区的切换过程中，程序暂停执行。<br><strong>优点：</strong><br>标记阶段和复制阶段可以同时进行。<br>每次只对一块内存进行回收，运行高效。<br>只需移动栈顶指针，按顺序分配内存即可，实现简单。<br>内存回收时不用考虑内存片的出现（得活动对象所占的内存空间之间没有空闲间隔）。</p><p><strong>缺点：</strong>需要一块能容纳下所有存活对象的额外的内存空间。因此，<strong>可一次性分配的最大内存缩小了一半</strong>。</p><p>其实现在jvm中并没有在新生代中分两个同样大小的区域….在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden(伊甸园)和两块Survivor(幸存区)，<strong>默认比例为8:1:1</strong>。<br><img src="/2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/4.png" alt="3"><br><img src="/2019/11/04/JVM-2%E5%B0%8F%E5%9E%83%E5%9C%BE/5.png" alt="3"></p><h2 id="4-终极无敌之分代算法"><a href="#4-终极无敌之分代算法" class="headerlink" title="4.终极无敌之分代算法"></a>4.终极无敌之分代算法</h2><p><strong>其实就是对上面的算法灵活应用,新生代的用复制,老年的用标记清楚或者标志整理</strong></p><ol><li>年轻代（Young Generation）<br>几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情下，如果对象年龄达到15岁，就会移动到老年代中。(也不一定,如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于等于该年龄的对象就可以直接进入年代</strong>。)</li></ol><p>若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。新生代大小可以由<code>-Xmn</code>来控制，也可以用<code>-XX:SurvivorRatio</code>来控制Eden和Survivor的比例。<br><strong>新生代GC（Minor GC/Scavenge GC）：发生在新生代的垃圾收集动作。因为Java对象大多都具有朝生夕灭的特性，因此Minor GC非常频繁(不一定等Eden区满了才触发)，一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集。</strong></p><ol start="2"><li>年老代（Old Generation）<br>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储间的对象，最常见的一种大对象就是大数组。比如：<br><code>byte[] data = new byte[4*1024*1024]</code><br>这种一般会直接在老年代分配存储空间。虚拟机提供了一个参数：<code>PretenureSizeThreshold</code>，大于这个参数的对象将直接在老年代分配<br>当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。</li></ol><p>老年代GC（Major GC/Full GC）：发生在老年代的垃圾回收动作。Major GC，经常会伴随至少一次Minor GC。由于老年代中的对象生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行Full GC时，会顺便清理掉Direct Memory中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><p>因为每次Full GC都要整个内存清理,时间很慢所以要尽量减少FUll GC 的次数,许多针对JVM的优化都是通过减少Full GC实现,可能导致FULL CG 的请款有<br>1.年老代（Tenured）被写满;<br>2.持久代（Perm）被写满;(说的是1.8之前的)<br>3.System.gc()被显示调用;<br>4.上一次GC之后Heap的各域分配策略动态变化.</p><ol start="3"><li><p>持久代（Permanent Generation）貌似8以后就没了,成了元空间<br>用于存放静态文件（class类、方法）和常量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。<br>永久代空间在Java SE8特性中已经被移除。取而代之的是元空间（MetaSpace）。因此不会再出现“<code>java.lang.OutOfMemoryError: PermGen error</code>”错误。</p></li><li><p>堆内存分配策略明确以下三点：</p></li></ol><p><strong>（1）对象优先在Eden分配。<br>（2）大对象直接进入老年代。<br>（3）长活期存的对象将进入老年代</strong>。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器:"></a>垃圾收集器:</h1><p>看需求选择<br> 新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge。<br> 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS。<br>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。<br>      G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域。</p><p>G1特点:<br><strong>并行与并发</strong><br>G1能充分利用多CPU、 多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行<br><strong>分代收集</strong><br>与其他收集器一样，分代概念在G1中依然得以保留。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、 熬过多次GC的旧对象以获取更好的收集效果。<br><strong>空间整合</strong><br>从整体上来看是基于“标记-整理”算法实现的，在局部上是基于复制算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br><strong>可预测的停顿</strong><br>这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。<br>G1收集器将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔的了，他们是一部分Region的集合。<br>G1收集器可以有计划地避免在整个Java堆中进行全区域的垃圾收集：跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。<br>在G1收集器中，使用Remembered Set来避免全堆扫描<br>G1收集器的运作大致可划分为以下几个步骤：<br><strong>初始标记（Initial Marking）</strong><br>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。<br><strong>并发标记（Concurrent Marking）</strong><br>从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。<br><strong>最终标记（Final Marking）</strong><br>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。<br><strong>筛选回收（Live Data Counting and Evacuation）</strong><br>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</p><p>传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是 Full GC 所带来的应用暂停。在一些对实时性要求很高的应用场景下，GC 暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内，但是这样有限制了应用本身的处理能力，同样也是不可接受的。<br>分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。<br>G1 可谓博采众家之长，力求到达一种完美。它吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region为单位；同时，它也吸取了 CMS 的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；而且，G1 也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。为了达到对回收时间的可预计性，G1 在扫描了 region 以后，对其中的活跃对象的大小进行排序，首先会收集那些活跃对象小的 region，以便快速回收空间（要复制的活跃对象少了），因为活跃对象小，里面可以认为多数都是垃圾，所以这种方式被称为 Garbage First（G1）的垃圾回收算法，即：垃圾优先的回收。</p><h1 id="减少GC开销非得策略"><a href="#减少GC开销非得策略" class="headerlink" title="减少GC开销非得策略:"></a>减少GC开销非得策略:</h1><p>(1)不要显式调用System.gc()<br>    此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。<br>(2)<strong>尽量减少临时对象的使用</strong><br>    临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。<br>(3)<strong>对象不用时最好显式置为Null</strong><br>    一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。<br>(4)<strong>尽量使用StringBuffer,而不用String来累加字符串</strong><br>    由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。<br>(5)<strong>能用基本类型如Int,Long,就不用Integer,Long对象</strong><br>    基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。<br>(6)<strong>尽量少用静态对象变量</strong><br>    静态变量属于全局变量,不会被GC回收,它们会一直占用内存。<br>(7)<strong>分散对象创建或删除的时间</strong><br>    集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。<br> (8)<strong>避免内存泄漏</strong><br>静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = new Vector();</span><br><span class="line"><span class="keyword">for</span> (int i = 1; i&lt;100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = null;   //尽管对象已经被指控但是引用仍然存在静态集合里面无法被GC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种连接网络连接数据库连接IO连接没有显示调用close,不能被GC回收导致内存泄漏<br>监听器:删除对象没有删除监听器会导致内存泄漏</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据算法以及引用类型证明你是不是个垃圾,就算你是垃圾我也给你一次重新做人机会<br>给脸不要脸就要看你是谁家的垃圾<br>伊甸园的垃圾最惨,因为岁数小,说没就没,伊甸园的活着躲过一次GC就算是幸存者,两个幸存者虽然地方小点但是血腥少,<br>幸存者过了十五岁就走向人生巅峰进入养老区,养老区最大,是整个年轻代的二倍大,相对平安无战乱,还有一种势力可以不用升级直接当养老区的土著,就是大对象,势力庞大,去了新生代太占地方,养老区不打仗则以,一打仗相对规模太大,速度更慢<br>虽然说一共有四种清理方法但是其实就是三个吧最后一个就是整合下前三个</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><h1 id="GC负责的是方法区以及堆-那么栈内存和程序计数器怎么释放内存的"><a href="#GC负责的是方法区以及堆-那么栈内存和程序计数器怎么释放内存的" class="headerlink" title="GC负责的是方法区以及堆,那么栈内存和程序计数器怎么释放内存的?"></a>GC负责的是方法区以及堆,那么栈内存和程序计数器怎么释放内存的?</h1><p>可能,可能可能是:栈内存又众多个栈帧组成,每个线程对应一个栈帧,都是栈的数据结构,先进先出,阅后即焚,线程执行完栈帧陪葬</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毒鸡汤</title>
      <link href="2019/11/03/%E6%AF%92%E9%B8%A1%E6%B1%A4/"/>
      <url>2019/11/03/%E6%AF%92%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<ol><li><p>微信、知乎的文章不要随便收藏。</p></li><li><p>每天早上写下三件「重要」的事情，做完一件就划掉一项，除了能提升工作效率，还能提升成就感、幸福感。</p></li><li><p>降低对他人的期望，你会发现烦恼瞬间少了一大半。</p></li><li><p>时常审视自己，看看过去一段时间，自己做了哪些蠢事，假如你没有意识到，不是你变聪明了，而是说明你几乎没有成长。一个人的成长，就是不断发现自己傻逼的过程。</p></li><li><p>随手带包餐巾纸、湿纸巾</p></li><li><p>越是没什么本事的人，越喜欢炫耀。</p></li><li><p>睡觉前将第二天穿的衣服和物品准备好放在身边</p></li><li><p>在桌子上方一株盆栽，缓解疲劳，快速回血。</p></li><li><p>多站在别人左边，能够给对方带来满满的安全感</p></li><li><p>保持健康的身体，就是在跟医院抢钱。</p></li><li><p>多向大佬学习最省事。千万不要自己一个人摸索</p></li><li><p>刷牙的时候，更重要的是刷舌头</p></li><li><p>努力提升自己的段位,就容易匹配到王者</p></li><li><p>别用你最喜欢的歌做闹铃。</p></li><li><p>别随便把你的目标公开。</p></li><li><p>抖音、刷剧、小说很容易让人上瘾，自律永远是反人性的</p></li><li><p>早点学习理财的人</p></li><li><p>克服拖延的最好方法，就是先做5分钟。</p></li><li><p>你其实没那么多观众。</p></li><li><p>赚钱最有安全感。</p></li><li><p>你之所以能够看穿一个人，是因为在他身上你看到自己的影子。</p></li><li><p>期待结果，快乐不会打折。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 破烂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一顿BB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-1.简介,场景,数据类型,数据结构</title>
      <link href="2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt="1"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h2><p>是一个高性能的(key/value) <strong>分布式内存数据库</strong>，是当前热门的NoSql数据库之一<br><strong>Redis的所有操作都是原子性的</strong>，同时Redis还支持对几个操作合并后的原子性执行–（<strong>事务</strong>）<br>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>丰富的数据类型 – Redis支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。<strong>单个value的最大限制是1GB</strong><br><font color="#ff0000"><strong>Redis运行在内存中但是可以持久化到磁盘</strong></font></p><h2 id="2-为什么快"><a href="#2-为什么快" class="headerlink" title="2.为什么快"></a>2.为什么快</h2><p><strong>完全基于内存</strong>，<strong>使用C语言实现</strong>，<strong>网络层使用epoll解决高并发问题</strong>，<strong>单线程模型避免了不必要的上下文切换及竞争条件</strong>(年底好像出多线程的)<br>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br>如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p><img src="/2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" alt="1"><br>（1）<code>String</code>：可以包含任何数据,比如jpg图片或者序列化的对象,<strong>一个键最大能存储512M。</strong><br>命令：<code>set、get</code>。<br>实现:简单动态字符串（SDS）<br>（2）<code>List</code>：链表(双向链表)，增删快，提供了操作某一段元素的API。<br>适用于：<strong>最新消息排行</strong>等功能；<strong>消息队列</strong>。可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。<br>命令：<code>lpush、rpop</code>。<br>实现:  双向链表<br>（3）<code>Set</code>：无序集合。哈希表实现，元素不重复,添加，删除，查找的复杂度都是O(1)，为集合提供了求交集、并集、差集等操作。<br>适用于：<strong>共同好友</strong>；利用唯一性，统计访问网站的所有独立ip；好友推荐时，根据tag求交集，大于某个阈值就可以推荐。<br>注:因为 <code>Set</code> 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 <code>Set </code>进行去重？<br>因为我们的系统一般都是集群部署，使用 JVM 自带的 <code>Set</code>，比较麻烦，为了一个做一个全局去重，再起一个公共服务?太麻烦了。<br>命令：<code>sadd、scard、sismember</code>。<br>实现: value永远为null的HashMap<br>（4）<code>Hash</code>：字典。键值对集合，即编程语言中的Map类型。适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值。<br>适用于：<strong>存储、读取、修改用户属性</strong>。<br>命令：<code>hset、hget、hmset、hmget、hlen</code>。<br>数据结构:Hash对应的Value内部实际就是一个HashMap，实际有两种不同的实现:<br>  a.  成员较少时，Redis为了节省内存会采用类似一维数组方式存储，对应的value RedisObject的encoding为zipmap，<br>  b.  成员增大时会自动转成真正的HashMap，此时encoding为ht。<br>（5）<code>Sorted Set</code>：有序集合。<br>每个元素都会关联一个double类型的分数(权重参数score)。redis正是通过分数来为集合中的成员进行从小到大排序的。成员是唯一的，<br>但分数(score)却可以重复。元素按权重参数 score有序排列。数据插入集合时，<strong>已经进行天然排序</strong>。<br>命令:<code>zadd,zrange,zrem,zcard</code><br>适用于：<strong>排行榜</strong>；<strong>带权重的消息队列</strong>,<strong>取 TOP N 操作</strong>。<br>实现:跳跃表</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" alt="1"></p><hr><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ol><li><strong>热点数据的缓存</strong><br>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。<br>与MySQL等关系型数据库不同的是，Redis没有命令空间，而且也没有对键名有强制要求，但设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名:对象名:id:[属性]”作为键名。例如MySQL的数据库名为vs，用户表名为user，那么对应的键可以用<code>&quot;vs:user:1&quot;</code>，<code>&quot;vs:user:1:name&quot;</code>来表示，如果当前Redis只被一个业务使用，甚至可以去掉vs。如果键名比较长，例如<code>&quot;user:&#123;uid&#125;:friends:message:&#123;mid&#125;&quot;</code>，可以在能描述含义的前提下适当减少键的长度，例如采用缩写形式，从而减少由于键过长的内存浪费。</li><li><strong>限时业务的运用</strong><br>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</li><li><strong>计数器相关问题</strong><br>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。<pre><code> 典型应用场景：视频播放数计数的基础组件，用户每播放一次视频，相应的视频播放数就会自增1。Redis可以实现快速计数、查询缓存的功能，同时数据可以异步落地到其他数据源。 开发提示：实际上一个真实的计数系统要考虑的问题会很多，防作弊、按照不同维度计数，数据持久化到底层数据源等。</code></pre></li><li><strong>排行榜相关问题</strong><br>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的<code>SortedSet</code>进行热点数据的排序。<br>在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个<code>SortedSet</code>,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过<code>zrangebyscore</code>就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。<br>有序集合比较典型的使用场景就是排行榜系统，例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</li><li><strong>分布式锁</strong><br>这个主要利用redis的<code>setnx</code>命令进行，<code>setnx</code>：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过<code>setnx</code>设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</li><li><strong>延时操作</strong><br>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</li><li><strong>分页、模糊搜索</strong><br>redis的set集合中提供了一个<code>zrangebylex</code>方法，语法如下：<br>Z<code>RANGEBYLEX key min max [LIMIT offset count]</code><br>通过<code>ZRANGEBYLEX zset - + LIMIT 0 10 </code>可以进行分页数据查询，其中- +表示获取全部数据<br><code>zrangebylex key min max </code>这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。<br>前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。<br>集合类型比较典型的使用场景是标签(tag)，例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣就是标签。 开发提示：用户和标签的关系维护应该在一个事物执行，防止部分命令失败造成的数据不一致。</li><li><strong>点赞、好友等相互关系的存储</strong><br>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。<br>这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。</li><li><strong>队列</strong><br>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</li><li><strong>发布/订阅</strong><br><code>Pub/Sub </code>从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。<br>其他</li><li>存分布式session:<br>用户登陆信息，Redis将用户的Session进行集中管理，每次用户更新或查询登陆信息都直接从Redis中集中获取。</li><li>存数学公式,验证码<br>做限流（五秒内最大请求5次）验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。</li><li>削峰（内存标记）</li></ol><p><img src="/2019/11/01/redis-1-%E7%AE%80%E4%BB%8B-%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" alt="5"><br>本质上主要是从性能和并发这两个角度使用redis:</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-5.锁与事务</title>
      <link href="2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
      <url>2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</p><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a>1.全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句</p><p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本</p><p>但是让整个库都只读，可能出现以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</li></ul><p>在可重复读隔离级别下开启一个事务能够拿到一致性视图<br>官方自带的逻辑备份工具是<code> mysqldump</code>。当<code> mysqldump</code>使用参数<code>–single-transaction</code>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的</p><hr><h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL）</p><p>表锁的语法是<code>lock tables … read/write</code>。可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<br><code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p><p>如果在某个线程A中执行<code>lock tables t1 read,t2 wirte;</code>这个语句，则其他线程写t1、读写t2的语句都会被阻塞。<br>同时，线程A在执行<code>unlock tables</code>之前，也只能执行读t1、读写t2的操作。连写t1都不允许</p><p>另一类表级的锁是MDL。MDL不需要显式使用，在访问一个表的时候会被自动加上。<br>MDL的作用是，保证读写的正确性。如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定不行</p><p><strong>在MySQL5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁</strong></p><p><strong>读锁之间不互斥</strong>:  因此可以有多个线程同时对一张表增删改查<br><strong>读写锁之间、写锁之间是互斥的</strong>:  用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行<br>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/1.png" alt="1"><br>session A先启动，这时候会对表t加一个MDL读锁。<br>由于session B需要的也是MDL读锁，因此可以正常执行。<br>之后sesession C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。<br>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。<br>所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了</p><p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</strong></p><p><strong>延伸:</strong></p><ol><li><p>如果安全地给小表加字段？<br>首先要解决长事务，事务不提交，就会一直占着DML锁。在MySQL的<code>information_schema</code>库的<code>innodb_trx</code>表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务</p></li><li><p>如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，该怎么做？<br>在<code>alter table</code>语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程</p></li></ol><hr><h2 id="3-行锁"><a href="#3-行锁" class="headerlink" title="3.行锁"></a>3.行锁</h2><p>行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新</p><h3 id="1-两阶段锁协议"><a href="#1-两阶段锁协议" class="headerlink" title="1. 两阶段锁协议"></a>1. 两阶段锁协议</h3><p><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/2.png" alt="2"><br>事务A持有的两个记录的行锁都是在commit的时候才释放的，事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行<br><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议<br>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong><br>假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：<br>1.从顾客A账户余额中扣除电影票价<br>2.给影院B的账户余额增加这张电影票价<br>3.记录一条交易日志<br><strong>为了保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序呢？</strong><br>如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。<br>因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，所有的操作需要的行锁都是在事务提交的时候才释放的。<br>所以，如果把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。<br>这就最大程度地减少了事务之间的锁等待，提升了并发度</p><h3 id="2-一致性非锁定读"><a href="#2-一致性非锁定读" class="headerlink" title="2. 一致性非锁定读"></a>2. 一致性非锁定读</h3><p>一致性非锁定读是指InnoDB通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或update操作，这时读取操作不会因此去等待行上排它锁的释放。相反地，InnoDB会去读取行的一个快照数据<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/3.png" alt="3"><br>非锁定读机制极大地提高了数据库的并发性。在InnoDB的默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁</p><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录有不止一个快照数据，行多版本的并发控制称为多版本并发控制（MVCC）</p><p>在事务隔离级别为读提交和可重复读下，InnoDB使用非锁定的一致性读。对于快照数据的定义却不相同。在读提交隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在可重复读隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本</p><h3 id="3-一致性锁定读"><a href="#3-一致性锁定读" class="headerlink" title="3. 一致性锁定读"></a>3. 一致性锁定读</h3><p>InnoDB支持两种一致性的锁定读操作：</p><figure class="highlight plain"><figcaption><span>… for update</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select … lock in share mode</span><br></pre></td></tr></table></figure><p><code>select … for update</code>对读取的行记录加一个排它锁，其他事务不能对已锁定的行加上任何锁。<br><code>select … lock in share mode</code>对读取的行记录加一个共享锁，其他事务可以向北锁定的行加共享锁，但是如果加排它锁，则会被阻塞</p><h3 id="4-行锁的3种算法"><a href="#4-行锁的3种算法" class="headerlink" title="4. 行锁的3种算法"></a>4. 行锁的3种算法</h3><p>InnoDB有3种行锁的算法，分别是：<br><strong>Record Lock</strong>：单个行记录上的锁<br><strong>Gap Lock</strong>：间隙锁，锁定一个范围，但不包含记录本身<br><strong>Next-Key Lock</strong>：<code>Gap Lock+Record Lock</code>，锁定一个范围，并且锁定记录本身</p><h2 id="锁的相关问题"><a href="#锁的相关问题" class="headerlink" title="锁的相关问题"></a>锁的相关问题</h2><h3 id="1-幻读问题"><a href="#1-幻读问题" class="headerlink" title="1.幻读问题"></a>1.幻读问题</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行<br>InnoDB默认的事务隔离级别是可重复读，在该隔离级别下采用Next-Key Lock的方式来加锁。而在事务隔离级别为读提交下，仅采用Record Lock<br>订单表中有id为1、2、5的三条数据，当隔离级别为读提交的时候会出现幻读的问题<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/4.png" alt="4"><br>在可重复隔离级别下，select * fromorderwhere id&gt;2 for update锁住的不是id为5的这条记录，而是对(2, +supremum]这个范围加了排它锁。因此任何对于这个范围的插入操作都是不被允许的，操作5将会被阻塞，从而避免了幻读的问题</p><h3 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2.间隙锁"></a>2.间隙锁</h3><p>为了解决幻读问题（在读提交隔离级别下，不存在间隙锁），InnoDB引入了间隙锁，锁的就是两个值之间的空隙<br>给表A插入数据,A的主键a,索引b,最后一个字段是d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/5.png" alt="5"><br>当执行<code>select * from t where d=5 for update</code>的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录<br>行锁分成读锁和写锁<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/6.png" alt="6"><br>跟间隙锁存在冲突关系的是往这个间隙中插入一个记录这个操作间隙锁之间不存在冲突关系<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/7.png" alt="7"></p><p>这里sessionB并不会被堵住。因为表t里面并没有c=7会这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们用共同的目标，保护这个间隙，不允许插入值。但它们之间是不冲突的</p><p>间隙锁和行锁合称Next-Key Lock<br>每个Next-Key Lock是前开后闭区间。表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个Next-Key Lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。因为+∞是开区间，在实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合都是前开后闭区间</p><p>间隙锁和Next-Key Lock的引入，解决了幻读的问题，<br>但同时也带来了一些困扰<br>间隙锁导致的死锁：<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/8.png" alt="8"><br>1.A执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)<br>2.B执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突<br>3.B试图插入一行(9,9,9)，被sessionA的间隙锁挡住了，只好进入等待<br>4.A试图插入一行(9,9,9)，被sessionB的间隙锁挡住了<br>两个session进入互相等待状态，形成了死锁<br><strong>间隙锁的引入可能会导致同样的语句锁住更大的范围，这其实是影响并发度的</strong></p><h3 id="3-Next-Key-Lock加锁规则"><a href="#3-Next-Key-Lock加锁规则" class="headerlink" title="3.Next-Key Lock加锁规则"></a>3.Next-Key Lock加锁规则</h3><p>注:只限于MySQL5.x系列&lt;=5.7.24，8.0系列&lt;=8.0.13<br>原则1：加锁的基本单位是Next-Key Lock，Next-Key Lock是前开后闭区间<br>原则2：查找过程中访问到的对象才会加锁<br>优化1：索引上的等值查询，给唯一索引加锁的时候，Next-Key Lock退化为行锁<br>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，Next-Key Lock退化为间隙锁<br>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</p><h3 id="4-死锁和死锁检测"><a href="#4-死锁和死锁检测" class="headerlink" title="4.死锁和死锁检测"></a>4.死锁和死锁检测</h3><p>在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/9.png" alt="9"><br>事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置<br>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑<br>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的</p><p>正常情况下还是要采用主动死锁检查策略，而且innodb_deadlock_detect的默认值本身就是on。主动死锁监测在发生死锁的时候，是能够快速发现并进行处理的，但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁</p><p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程都要判断会不会由于自己的加入导致死锁，这是一个时间复杂度是O(n)的操作</p><h3 id="5-怎么解决由这种热点行更新导致的性能问题？"><a href="#5-怎么解决由这种热点行更新导致的性能问题？" class="headerlink" title="5.怎么解决由这种热点行更新导致的性能问题？"></a>5.怎么解决由这种热点行更新导致的性能问题？</h3><p>1.如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉<br>2.控制并发度<br>3.将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成员原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗</p><hr><h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><p>ACID<br>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样<br>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏<br>隔离性：数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致<br>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p><hr><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>I，也就是“隔离性”<br>隔离得越严实，效率就会越低</p><p><strong>标准隔离级别:读未提交、读提交、可重复读和串行化:</strong><br>1.读未提交:一个事务还没提交时，它做的变更就能被别的事务看到。<br>2.读提交:一个事务提交之后，它做的变更才会被其他事务看到。<br>3.可重复读:一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。<br>4.串行化:是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p><strong>举例</strong>:<br>假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight plain"><figcaption><span>table T(c int) engine</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure><p><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/10.png" alt="10"></p><p><strong>隔离级别是“读未提交”</strong>    : V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。<br><strong>隔离级别是“读提交”</strong>        : V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。<br><strong>隔离级别是“可重复读”</strong>    : V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。<br><strong>隔离级别是“串行化”</strong>        :在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2<br>值是 1，V3 的值是 2。</p><p><strong>实际据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。<br>在“可重复读”下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。<br>在“读提交”下，这个视图是在每个 SQL 语句开始执行的时候创建的。<br>在“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；<br>在“串行化”下,直接用加锁的方式来避免并行访问。（InnoDB会对每个select语句后自动加上lock in share mode）</strong></p><p>不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数 <code>transaction-isolation </code>的值设置成<code> READ-COMMITTED</code>。你可以用 <code>show variables </code>来查看当前的值。</p><p><code>show variables like &#39;transaction_isolation&#39;;</code><br>+———————–+—————-+<br>|    Variable_name      |      Value     |<br>+———————–+—————-+<br>| transaction_isolation | READ-COMMITTED |<br>+———————–+—————-+</p><p><strong>什么时候需要“可重复读”的场景呢？</strong></p><p>假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><hr><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>“可重复读”。<br>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。<br>记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志(undo log)里面就会有类似下面的记录。<br><img src="/2019/10/24/mysql-5-%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/11.png" alt="10"><br>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。<br>在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的<strong>多版本并发控制（MVCC）</strong>。<br>对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。<br>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p><strong>回滚日志什么时候删除？</strong><br>在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。<br>就是当系统里<strong>没有比这个回滚日志更早的 read-view 的时候。</strong></p><hr><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>MySQL 的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</li><li><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。<br>意味着如果你只执行一个 <code>select</code> 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在<strong>直到你主动执行 commit 或 rollback 语句，或者断开连接</strong></li></ol><p>有些默认连接成功后先执行一个 <code>set autocommit=0</code> 的命令。<br>这就导致接下来的查询都在事务中，如果是长连接，就导致了<strong>意外的长事务</strong>。<br>So,最好使用 <code>set autocommit=1</code>, 通过<strong>显式语句的方式来启动事务</strong>。</p><p>但是对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时省略一次 “begin”，减少了语句的交互次数。<br>如果有这个需求，建议你使用 <code>commit work and chain </code>语法。</p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。<br>如果执行 <code>commit work and chain</code>，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。<br>同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>在 <code>information_schema</code> 库的 <code>innodb_trx</code> 这个表中查询长事务，下面用于查找持续时间超过 60s 的事务示例<br><code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</code></p><h3 id="为什么建议你尽量不要使用长事务。"><a href="#为什么建议你尽量不要使用长事务。" class="headerlink" title="为什么建议你尽量不要使用长事务。"></a>为什么建议你尽量不要使用长事务。</h3><p>长事务有这些潜在风险，尽量避免。其实很多业务长事务是由于误用所致。<br>长事务意味着系统里面会存在很老的事务视图。<br>由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h3 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h3><ol><li>从应用开发端来看：<br>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。<br>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。<br>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li><li>从数据库端来看：<br>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；<br>Percona 的 pt-kill 这个工具不错，推荐使用；<br>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；<br>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol><hr><h2 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题:"></a>生产问题:</h2><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。<br>有个数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库……….</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-4.InnoDB架构简单分析</title>
      <link href="2019/10/15/mysql-4-InnoDB%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
      <url>2019/10/15/mysql-4-InnoDB%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/10/15/mysql-4-InnoDB%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/1.png" alt="1"><br>InnoDB主要包括了内存池、后台线程以及存储文件</p><h1 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h1><p>InnoDB存储引擎是多线程的模型<br>1.Master Thread<br>Master Thread主要负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（Insert Buffer）、undo页的回收等<br>2.IO Thread<br>在InnoDB中大量使用了AIO来处理写IO请求，而IO Thread的工作主要是负责这些IO请求的回调处理。IO Thread分为write、read、insert buffer和log IO thread四种<br>3.Purge Thread<br>事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页<br>4.Page Cleaner Thread<br>Page Cleaner Thread是一个用于协助Master Thread刷新脏页到磁盘的线程</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h2><p>InnoDB存储引擎是基于磁盘存储的，而缓冲池是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响<br>在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页<br>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘</p><p><img src="/2019/10/15/mysql-4-InnoDB%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/2.png" alt="3"><br>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等</p><h2 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h2><h3 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h3><p>InnoDB缓冲池的内存管理使用最近最少使用（LRU）算法并在此基础上做了优化：<br><img src="/2019/10/15/mysql-4-InnoDB%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/3.png" alt="3"><br>在InnoDB实现上，按照5：3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5/8处。也就是说，靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域<br>1.上图中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2<br>2.之后要访问一个新的不存在于当前链表的Pm，但是新插入的数据页Px，是放在LRU_old处<br>3.处于old区域的数据页，每次被访问的时候都要做下面这个判断：</p><p>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部<br>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。默认值是1000，单位是毫秒<br>这个优化策略就是为了处理类似全表扫描的操作量身定制的：</p><p>1.扫描过程中，需要新插入的数据页，都被放到old区域<br>2.一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域<br>3.再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部，很快就会被淘汰出去<br>这个优化策略最大的收益就是在扫描大表的过程中，虽然也用到了缓冲池，但是对young区域完全没有影响，从而保证了缓冲池响应正常业务的查询命中率</p><h3 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h3><p>当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页</p><h3 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h3><p>在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过Checkpoint机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表</p><h3 id="redo-log-buffer（重做日志缓冲）"><a href="#redo-log-buffer（重做日志缓冲）" class="headerlink" title=" redo log buffer（重做日志缓冲）"></a><code> redo log</code> buffer（重做日志缓冲）</h3><p>InnoDB首先将<code> redo log</code>放入到<code> redo log buffer</code>，然后按一定频率将其刷新到<code>redo log file</code></p><p>下列三种情况下会将<code> redo log buffer</code>刷新到<code>redo log file</code>：</p><p>Master Thread每一秒将<code> redo log buffer</code>刷新到<code>redo log file</code><br>每个事务提交时会将<code> redo log buffer</code>刷新到<code>redo log file</code><br>当<code> redo log</code>缓冲池剩余空间小于1/2时，会将<code> redo log</code> buffer刷新到<code>redo log file</code></p><h2 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h2><p>在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象，这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请</p><h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><p>InnoDB对DML操作（Insert、Delete、Update）都进行缓冲，分别是<strong>Insert Buffer、Delete Buffer、Purge Buffer</strong><br>将<code> Change Buffer</code>中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭的过程中，也会执行merge操作<br><code> Change Buffer</code>是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上<br>主键和唯一索引无法使用<code> Change Buffer</code></p><p><strong><code> redo log</code>主要节省的是随机写磁盘的IO消耗（转成顺序写），而<code> Change Buffer</code>主要节省的是随机读磁盘的IO消耗</strong></p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库范式</title>
      <link href="2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
      <url>2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>讲道理其实有八种<br>一般说的就是前三种,正好我也是一般人….</p><p>一般人的总结:<br>第一F: 要拆稀碎,一扒了一个—–&gt;确保每列保持原子性<br>第二F: 主键约束,有人扛大梁—–&gt;确保表中的每列都和主键相关<br>第三F: 外键约束,站好队别装—–&gt;确保每列都和主键列直接相关,而不是间接相关</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>定义：数据库中的所有字段（列）都是单一属性，不可再分的。这个单一属性由基本的数据类型所构成，如整型、浮点型、字符串等。<br>第一范式是为了保证列的原子性。<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/1.jpg" alt="1"><br>上表不满足第一范式，其中的地址列是可以再拆分的，可以拆分成省、市、区等<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/2.jpg" alt="1"><br><strong>该拆就得拆,比如啥都不拆直接一个json存mongo得了还要你干啥</strong></p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>定义：数据库中的表不存在非关键字段对任一关键字字段的部分函数依赖<br>部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况<br>第二范式在满足了第一范式的基础上，消除非主键列对联合主键的部分依赖<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/3.jpg" alt="1"><br>上面这张表中想要设置主键，只能是商品名称和供应商名称一起组成联合主键。但是价格和分类只依赖于商品名称，供应商电话只依赖于供应商名称，所以上面的表不满足第二范式，可以改成如下形式：<br>商品信息表<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/4.jpg" alt="1"><br>供应商信息表<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/5.jpg" alt="1"><br>商品-供应商关联表</p><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>定义：所有非主键属性都只和候选键有相关性，也就是说非主键属性之间应该是独立无关的。<br>第三范式是在满足了第二范式的基础上，消除列与列之间的传递依赖。<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/6.jpg" alt="1"><br>在上面的表中，商品的分类描述依赖分类，而分类依赖商品名称，而不是分类描述直接依赖商品名称。这样就形成了传递依赖，所以不符合第三范式。可以改成如下形式<br>商品表<br>商品分类表<br><img src="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/7.jpg" alt="1"><br><strong>该拆就得拆,比如你一个学生表每个数都加个系主任和系编号好像有病一样</strong></p><h1 id="用啥"><a href="#用啥" class="headerlink" title="用啥"></a>用啥</h1><p>数据库设计时，遵循范式和反范式一直以来是一个颇受争议的问题。<br><strong>遵循范式对数据关系更好的约束性，并且减少数据冗余，可以更好地保证数据一致性。</strong><br><strong>反范式则是为了获得更好地性能。</strong>所以范式还是反范式并没有明确的标准，适合自己业务场景的才是最好的。<br>反范式设计时，需要考虑以下几个问题，分别是插入异常、更新异常和删除异常。<br><strong>插入异常</strong>：如果某个实体随着另一个实体的存在而存在，即缺少某个实体是无法表示这个实体，那么这个表就存在插入异常。<br><strong>更新异常</strong>：如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么就说明这个表存在更新异常<br><strong>删除异常</strong>：如果删除表的某一行来表示某实体实例失效时，导致另一个不同实体实例信息丢失，那么这个表就存在删除异常<br><strong>以违反第二范式的表为例</strong><br>如果可乐第二制造厂这个供应商尚未开始供货，表中就不存在第二条记录，也就无法记录供应商的电话，这样就存在插入异常；如果需要把可乐的价格提高，需要更新表中的多条记录，这样就存在更新异常；如果删除可乐第二制造厂的供货信息，那么该供应商的电话也就丢失了，这样就存在删除异常。<br>一般存在插入异常的表，都会存在更新异常和删除异常。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-1内存模型</title>
      <link href="2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>1.组成:<strong>堆,栈,方法区,本地方法栈,程序计数器</strong><br>2.线程能共享区域:<strong>堆,方法区</strong><br><img src="/2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png" alt="1"><br>上图1.7之前的<br>1.8的,没有方法区永久代,成了元空间,直接存在本地内存里面虽然默认大小是4G但是好像让你能自动扩容,<br>常量池也在这,基本不会出现内存溢出问题(String的常量池在堆中)<br><img src="/2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png" alt="1"></p><hr><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器:"></a>程序计数器:</h1><p>一个较小的内存空间,每个线程都有,里面存的都是当前线程执行的字节码的行号,说白了就是记录当前线程执行到那了.下一条指令到哪也是它说的算,比如异常处理线程回复什么的</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点:"></a><strong>特点</strong>:</h2><ol><li>线程私有的</li><li>生命周期随线程创建而创建,和线程一起死(它本身的作用就是为了线程)</li><li>唯一一个不会出现内存溢出的内存区域</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a><strong>问题</strong>:</h2><p><strong>为什么不会内存溢出</strong>?</p><p>他里面记录的是当前执行的字节码行号,只要变化就覆盖,不会溢出</p><p><strong>为什么线程私有?线程A被挂起,cpu在执行到他的时候怎么知道执行到了哪里</strong>?</p><p>不私有怎么知道记录的是谁的</p><p><strong>如果执行到本地方法怎么办</strong>?</p><p>native修饰的方法比如run方法是c++写得,没有字节码文件所以程序计数器里面的值是空(undefined)</p><hr><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈:"></a>虚拟机栈:</h1><p><strong>虚拟机栈主要存储的是一个个栈帧</strong>，每个栈帧中存储的是<strong>局部变量表，操作数栈，动态链接和方法出口信息</strong>等。<br>其中<strong>局部变量表中存储的是方法中定义的一些局部变量，基本数据类型,对象的引用，参数，和方法的返回地址等</strong>。<br><strong>局部变量表所占用的空间大小在编译期就能确定</strong>，<strong>在方法运行的时候，并不会改变局部变量表的空间大小</strong>，<br>这结合局部变量表存储的内容就很好理解。操作数栈可以理解为对当前操作的数据入出栈，对于64位长度的<code>long</code>和<code>double</code>类型，每个操作数占用2个字宽（slot），其他类型的操作数占用一个字宽（slot）。每个方法调用时都会创建一个栈帧，执行的过程对应的就是一个<strong>栈帧在虚拟机栈中从入栈到出栈的过程</strong>。有关栈帧的内容可以参考：<a href="https://blog.csdn.net/xtayfjpk/article/details/41924283%EF%BC%8C">https://blog.csdn.net/xtayfjpk/article/details/41924283，</a><br>栈帧:<br><img src="/2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png" alt="1"><br>局部变量表所需<strong>内存空间在编译期完成分配</strong>，当进入一个方法时，该方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h2 id="关于虚拟机栈内存溢出有2种情况："><a href="#关于虚拟机栈内存溢出有2种情况：" class="headerlink" title="关于虚拟机栈内存溢出有2种情况："></a>关于虚拟机栈内存溢出有2种情况：</h2><p>1、线程请求的<strong>栈深度 超过了虚拟机允许的深度</strong>，会抛出<code>StackOverflowError</code>，所以当我们在代码中看到这个异常时，就应该想到可能是虚拟机栈出了问题。<br>2、如果虚拟机栈可以动态扩展（当前大部分JVM都可以动态扩展，不过JVM也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时，会抛出<code>OutOfMemoryError</code>异常</p><hr><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>比较简单，本地方法栈和虚拟机栈的功能类似，只不过是<strong>为JVM调用native方法时服务的</strong>，而且JVM对本地方法使用的语言（比如Java调用C语言实现的功能，就需要定义native方法来实现）、使用方式和数据结构都没有强制规定，因此不同的虚拟机可以自由实现。而且<strong>HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机栈类似，本地方法栈也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</p><hr><h1 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区(永久代)"></a>方法区(永久代)</h1><p>方法区是一个比较重要的区域，java虚拟机规范中把方法区描述为堆的一个逻辑部分，但是为了和Heap（堆区）对应，也称Non-Heap（非堆区）。<br>主要存储的是静态变量，常量（包括运行时常量），类加载器信息(classLoader),java编译后的代码,方法的名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性,返回类型、参数类型(按顺序)。<br><strong>这部分空间不需要连续，可以选择固定大小和可扩展，通常在这部分是没有GC的，因为GC回收的都是些静态变量，常量和类的加载信息，这些对象回收效果通常不尽人意，因此可以选择不实现垃圾回收。这块区域也称为永久代，当这块内存不足时，也会报OutOfMemoryError异常。</strong><br><strong>方法信息包括:方法返回类型,方法名,参数数量.顺序,参数类型,方法的修饰符(pblic,.private等</strong></p><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量:"></a>类变量:</h2><ul><li>在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</li><li>在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</li><li>在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, <strong>这时候字符串常量池还在堆, 运行时常量池还在方法区</strong>, 只不过方法区的实现从永久代变成了元空间(Metaspace) (因为永久代经常内存溢出所以取消了)<br>字符串常量池最早投靠堆至今</li></ul><hr><h1 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h1><p>Java堆区是JVM内存中最胖的一块区域，因为这里存储的都是对象的实例和数组对象。这块区域是线程共享的，在JVM启动时就会创建，想想如果这么大的空间是线程私有的，那内存不得爆掉吗？按照java虚拟机规范，堆区的内容可以物理上不连续，只要逻辑上连续即可，在实现时可以是固定大小的，也可以是可扩展的，而且通常都是可扩展的，我们常用的内存参数-Xms和-Xmx就是用来调节堆大小的。<br>java堆区按生命周期不同，分为新生代和老年代。新生代又可以细分为Eden和Survivor区，而Survivor又可以细分为Survivor1和Survivor2，这两者通常只使用其中一块，另一块用来GC时保留存活的对象。大部分的new出来的对象都是存放在Eden区，如果是大对象，比如一个很大的数组或者List对象，可以通过JVM参数-XX:PretenureSizeThreshold将超过指定大小的对象直接存入到老年代，需要注意的是，写程序时应该尽量避免朝生夕死的大对象进入老年代，因为相比年轻代的GC，老年代GC的成本更大。Eden和Survivor的默认大小比值的8:1:1，新生代默认的GC算法是复制算法。老年代的默认GC算法是标记整理法。<br>当堆中没有足够内存时，会抛出OutOfMemoryError异常。关于堆区的内存模型，可以参考下面的图片：<br><img src="/2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.png" alt="1"><br><font color="#ff0000"> 堆内存逻辑上分为三部分：新生+养老+永久(永久在1.8以后好像就没了)</font><br><font color="#ff0000"></font></p><h2 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h2><p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：<br>**伊甸区（Eden Space）和幸存者区(Survivor space)**，所有的类都是在伊甸区被new出来的。幸村区有两个：0区（Survivor 0 space）和1区（Survivor 1space）。<br>当伊甸园的空间用完时，程序又需要创建对象，Jvm的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园区中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError“。<br>如果出现java.lang.OutOfMemoryError:Java heap space异常，说明Java虚拟机的对内存不够。原因有二：<br>　　（1）Java虚拟机的堆内存设置不够，可以通过参数<code>-Xms、Xmx</code>来调整。<br>　　（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<br>Java堆从GC的角度还可以细分为：新生代（Eden区、From Survivor区和To Survivor区）和老年代。<br><font color="#ff0000">MinorGC的过程(复制-&gt;清空-&gt;互换)，其中，Eden：From：To = 8：1：1</font><br>1：eden、SurvivorFrom复制到survivorTo，年龄+1<br>首先，把Eden和SurvivorFrom区域中存活的对象复制到SurvivorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果SurvivorTo不够位置了就放到老年区）<br> 长期存活的对象将进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。<br>2：清空eden、SurvivorFrom<br>然后，清空Eden和SurvivorFrom中的对象<br>3：SurvivorTo和SurvivorFrom互换<br>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时SurvivorFrom区<br>　　<br>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内容区域，它用于存储虚拟机加载的：类信息+普通变量+静态变量+编译器编译后的代码等等，<br><font color="#ff0000">虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</font><br>对于HotSpot虚拟机，很多开发者习惯将方法区称之为”永久代（Parmaneng Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于是一个接口interface）的一个实现，<font color="#ff0000">jdk1.7的版本中，已经将原来放在永久代的字符串常量池移走</font>。<br>　　Java1.8之后将最初的永久代取消了，由元空间取代。<br>　　在Java8中，永久代已经被移除了。被一个称为元空间的区域所取代。元空间的本质和永久代类似。<br>　　元空间与永久代之间最大的区别在于：<br>　　元空间并不在虚拟机中而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据当如native memeory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不在由MaxPermSize控制，而由系统的实际可用空间来控制。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><ol><li><p>为啥分栈和堆啊?类比内存和硬盘?一个是运行时处理数据的一个是存放数据的?<br>基本数据类型和堆中对象的引用…一个对象的大小是不可估计的，或者说是可<br>以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用<br>栈:我并不是真正的爱你,牵你的不是手,只是狗链,手小的人不能抱着十只狗,但是可以牵十只狗链,沾点狗毛不会在乎-基本类型<br>栈是解决如何处理数据,运行时的单位，而堆是解决数据存储,存储的单位<br>不同的线程执行逻辑有所不同，因此需要一个独立的线程栈<br>栈代表了处理逻辑，而堆代表了数据</p></li><li><p>为什么不把基础类型存入堆内存<br>因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本<br>类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义—-脱裤子放屁,狗绳子另一头牵一个还不如绳子重的狗毛<br>的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的<br>一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，<br>因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。</p></li></ol><p><strong>程序计数器</strong>:存的是当前新城字节码执行的位置(存在的意义就是为了线程)<br><strong>虚拟机栈</strong>:局部变量表，操作数栈，动态链接和方法出口信息<br><strong>局部变量表</strong>:局部变量，对象的引用，参数，和方法的返回地址<br>局部变量表包括基本类型变量的值以及各种的引用(各种——-String什么的都是)<br><img src="/2019/10/04/JVM-1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.png" alt="5"><br><strong>方法区:包括常量池</strong>    (JDK 1.7之后在堆内存中????)<br>final修饰的基本类型常量以及String的 “ “ 变量,还有5个包装类(不包括浮点型)范围[-128，127]都存在常量池中<br>意义提高运行速度,减少内存开销,比如十个String的值都是”abcdefghigklmn”,只需开辟一个空间,所有的引用都指向这里就可以了<br>方法区存的是方法的参数类型返回值修饰符类加载器等等等<br><strong>堆内存:栈后面的男人</strong><br>栈风光在外,对象的实际数据他好像都知道像个中介,不知道以为在租的房子都是他的<br>不是堆傻,大堆不屑小栈,再说太嘚瑟的容易夭折(栈生命周期和线程)</p><ol start="3"><li>有个线程堆溢出，别的线程能运行吗？<br>能，堆溢出的线程会被终结，所占资源会被gc，但是gc本身也是一个守护线程，所以可能其他线程性能收到，影响</li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造</title>
      <link href="2019/09/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0/"/>
      <url>2019/09/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul><li><p>创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？<br>类似 创建线程池资源池，参数比较多（有时候有些是必填的有些还不是必填的，这种更费劲）</p></li><li><p>直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？<br>都用构造，好多不是必传的也要传，顺序容易乱，参数容易乱<br>配合set，必填也用set，不在构造里面，无法判断必填是否已经填写，<br>配置项有依赖关系或者约束条件，配置A必须配置BC,或者配置A，B要大于A<br>对象是不可变的，创建后不能改变内部属性</p></li><li><p>建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？<br><strong>工厂模式是用来创建不同但是相关类型的对象</strong>（继承同一父类或者接口的一组子类），<br>由给定的参数来决定创建哪种类型的对象。<br><strong>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象</strong></p><p>利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。<br>通过建造者模式,根据用户选择的不同配料,来制作披萨。各种配料可以定制，比如奶酪、西红柿、起司</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h1 id="链式"><a href="#链式" class="headerlink" title="链式"></a>链式</h1><p>建造者模式一般是链式调用，具体可以参考 StirngBuffer的append()方法，Guava的不可变对象创建，SqlSessionFactoryBuilder的源码</p><h2 id="应用建造者简配置"><a href="#应用建造者简配置" class="headerlink" title="应用建造者简配置"></a>应用建造者简配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动时间 hash :%s_activity_time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String activityTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 各阶段开始结束时间 hash %s stage  :%s_stage_time_%s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String stageTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动各阶段结束时间 sortedSet  :%s_stage_end_time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String stageEndTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 各阶段各轮的开始结束时间  Hash  %s%s stage step   :%s_stage_step_time_%s_%s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String stageStepTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 晋级时间 hash    :%s_delay_queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String delayQueue;</span><br><span class="line">    <span class="comment">//省略........</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActivityConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = builder.id;</span><br><span class="line">        <span class="keyword">this</span>.area = builder.area;</span><br><span class="line">        <span class="keyword">this</span>.activityTime = builder.ACTIVITY_TIME;</span><br><span class="line">        <span class="keyword">this</span>.stageTime = builder.STAGE_TIME;</span><br><span class="line">        <span class="keyword">this</span>.stageEndTime = builder.STAGE_END_TIME;</span><br><span class="line">        <span class="keyword">this</span>.stageStepTime = builder.STAGE_STEP_TIME;</span><br><span class="line">        <span class="keyword">this</span>.delayQueue = builder.DELAY_QUEUE;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id必传</span></span><br><span class="line"><span class="comment">     * 各字段第一个占位符为area</span></span><br><span class="line"><span class="comment">     * 一个地区一个配置文件必传area，</span></span><br><span class="line"><span class="comment">     * 多个地区共用一个配置文件可不传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; mapDataTemplate = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//活动id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">        <span class="comment">//活动地区</span></span><br><span class="line">        <span class="keyword">private</span> String area;</span><br><span class="line">        <span class="comment">//活动时间 hash</span></span><br><span class="line">        <span class="keyword">private</span> String ACTIVITY_TIME = <span class="string">&quot;:%s_activity_time&quot;</span>;</span><br><span class="line">        <span class="comment">//活动各阶段结束时间 sortedSet</span></span><br><span class="line">        <span class="keyword">private</span> String STAGE_END_TIME = <span class="string">&quot;:%s_stage_end_time&quot;</span>;</span><br><span class="line">        <span class="comment">//各阶段开始结束时间 hash %s stage</span></span><br><span class="line">        <span class="keyword">private</span> String STAGE_TIME = <span class="string">&quot;:%s_stage_time_%s&quot;</span>;</span><br><span class="line">        <span class="comment">//各阶段各轮的开始结束时间  Hash  %s%s stage step</span></span><br><span class="line">        <span class="keyword">private</span> String STAGE_STEP_TIME = <span class="string">&quot;:%s_stage_step_time_%s_%s&quot;</span>;</span><br><span class="line">        <span class="comment">//晋级时间 hash</span></span><br><span class="line">        <span class="keyword">private</span> String DELAY_QUEUE = <span class="string">&quot;:%s_delay_queue&quot;</span>;</span><br><span class="line">        <span class="comment">//省略、、、、</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActivityConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;ActivityConfig build 活动id不可为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(area)) &#123;</span><br><span class="line">                <span class="comment">//多个地区共用一个配置文件，不传area</span></span><br><span class="line">                initWithOutArea();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一个配置文件对应一个地区</span></span><br><span class="line">                initWithArea();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActivityConfig(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多个地区一个配置文件时返回：id:%s_key 便于自行拼接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWithOutArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ACTIVITY_TIME = id + ACTIVITY_TIME;</span><br><span class="line">            STAGE_END_TIME = id + STAGE_END_TIME;</span><br><span class="line">            STAGE_TIME = id + STAGE_TIME;</span><br><span class="line">            STAGE_STEP_TIME = id + STAGE_STEP_TIME;</span><br><span class="line">            DELAY_QUEUE = id + DELAY_QUEUE;</span><br><span class="line">            <span class="comment">//省略。。。。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单个地区或各地区配置文件不同时返回： eg: id:area_key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWithArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ACTIVITY_TIME = id + ACTIVITY_TIME.replaceFirst(<span class="string">&quot;%s&quot;</span>, area);</span><br><span class="line">            STAGE_END_TIME = id + STAGE_END_TIME.replaceFirst(<span class="string">&quot;%s&quot;</span>, area);</span><br><span class="line">            STAGE_TIME = id + STAGE_TIME.replaceFirst(<span class="string">&quot;%s&quot;</span>, area);</span><br><span class="line">            STAGE_STEP_TIME = id + STAGE_STEP_TIME.replaceFirst(<span class="string">&quot;%s&quot;</span>, area);</span><br><span class="line">            DELAY_QUEUE = id + DELAY_QUEUE.replaceFirst(<span class="string">&quot;%s&quot;</span>, area);</span><br><span class="line">            <span class="comment">//省略。。。。。。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多地区共用一个配置文件不填：根据业务逻辑手动String.format地区</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setArea</span><span class="params">(String area)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(area)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;ActivityConfig setArea 参数不可为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.area = area;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> activityId = <span class="number">10265L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ActivityConfig config = <span class="keyword">new</span> ActivityConfig.Builder().setId(activityId).build();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-并发常识,常识！</title>
      <link href="2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/"/>
      <url>2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h3 id="在java中守护线程和本地线程区别？"><a href="#在java中守护线程和本地线程区别？" class="headerlink" title="在java中守护线程和本地线程区别？"></a>在java中守护线程和本地线程区别？</h3><p>java中的线程分为两种：守护线程（Daemon）和用户线程（User）。<br><strong>任何线程都可以设置为守护线程和用户线程</strong>，通过方法<code>Thread.setDaemon(boolean)</code>；true则把该线程设置为守护线程，<br>反之则为用户线程。<code>Thread.setDaemon()</code>必须在<code>Thread.start()</code>之前调用，否则运行时会抛出异常。<br>两者的区别：<br>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。<br>也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；<br><strong>比如JVM的垃圾回收线程是一个守护线程</strong>，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。<br>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。</p><h3 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h3><p><strong>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</strong><br>一个程序至少有一个进程,一个进程至少有一个线程。</p><h3 id="什么是多线程中的上下文切换？"><a href="#什么是多线程中的上下文切换？" class="headerlink" title="什么是多线程中的上下文切换？"></a>什么是多线程中的上下文切换？</h3><p>多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，需要轮转使用CPU。<strong>不同的线程切换使用CPU发生的切换数据等就是上下文切换。</strong><br>上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。<br>上下文切换是存储和恢复CPU状态的过程，它是多任务操作系统和多线程环境的基本特征。</p><h3 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h3><p>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。<br>各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.<br>有两种调度模型：分时调度模型和抢占式调度模型。<br>分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。<br>java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p><h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，<br>这个实现是和操作系统相关的(OS dependent)。<strong>我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。</strong><br><strong>线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</strong><br>java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h3 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</h3><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。<br>同上一个问题，线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。<br>时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。</p><h3 id="什么是线程组，为什么在Java中不推荐使用？"><a href="#什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用？"></a>什么是线程组，为什么在Java中不推荐使用？</h3><p><strong>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</strong><br>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。<br>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p><h3 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h3><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，<br>而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。</p><h3 id="为什么使用Executor框架？"><a href="#为什么使用Executor框架？" class="headerlink" title="为什么使用Executor框架？"></a>为什么使用Executor框架？</h3><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。<br>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。</p><h3 id="为什么要使用Executor线程池框架"><a href="#为什么要使用Executor线程池框架" class="headerlink" title="为什么要使用Executor线程池框架 :"></a>为什么要使用Executor线程池框架 :</h3><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。<br><strong>调用 new Thread()创建的线程缺乏管理，被称为野线程</strong>，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。<br><strong>接使用new Thread() 启动的线程不利于扩展</strong>，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p><h3 id="Executor线程池框架的优点"><a href="#Executor线程池框架的优点" class="headerlink" title="Executor线程池框架的优点"></a>Executor线程池框架的优点</h3><p>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。<br>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。<br>框架中已经有定时、定期、单线程、并发数控制等功能。<br>综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。</p><h3 id="在Java中Executor和Executors的区别？"><a href="#在Java中Executor和Executors的区别？" class="headerlink" title="在Java中Executor和Executors的区别？"></a>在Java中Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。<br>Executor 接口对象能执行我们的线程任务。<br>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。<br><strong>使用ThreadPoolExecutor 可以创建自定义线程池。</strong><br>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><h3 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h3><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p><h3 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h3><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。<br>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p><h3 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。<br>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。<br>在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作。</p><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。<br>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。<br>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference<br>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray<br>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater<br>解决ABA问题的原子类：AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）</p><h3 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。<br>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><h3 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h3><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p><h3 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h3><p>读写锁是用来提升并发程序性能的锁分离技术的成果。</p><h3 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>JDK7提供了7个阻塞队列。分别是：<br>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。<br>BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。<br>阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><p>使用共享变量的方式<br>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。<br>使用interrupt方法终止线程<br>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用stop()方法，而是使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p><h3 id="java中有几种方法可以实现一个线程？"><a href="#java中有几种方法可以实现一个线程？" class="headerlink" title="java中有几种方法可以实现一个线程？"></a>java中有几种方法可以实现一个线程？</h3><p>继承 Thread 类<br>实现 Runnable 接口<br>实现 Callable 接口，需要实现的是 call() 方法</p><h3 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h3><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，<br>而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。<br>可以认为是带有回调的Runnable。<br>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><h3 id="什么是FutureTask-使用ExecutorService启动任务。"><a href="#什么是FutureTask-使用ExecutorService启动任务。" class="headerlink" title="什么是FutureTask?使用ExecutorService启动任务。"></a>什么是FutureTask?使用ExecutorService启动任务。</h3><p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。<br>可以通过查看Vector，Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。<br>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p><h3 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。<br>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。<br>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><h3 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a>什么是竞争条件？你怎样发现和解决竞争？</h3><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p><h3 id="如何使用thread-dump？你将如何分析Thread-dump？"><a href="#如何使用thread-dump？你将如何分析Thread-dump？" class="headerlink" title="如何使用thread dump？你将如何分析Thread dump？"></a>如何使用thread dump？你将如何分析Thread dump？</h3><p>新建状态（New）<br>用new语句创建的线程处于新建状态，此时它和其他Java对象一样，仅仅在堆区中被分配了内存。<br>就绪状态（Runnable）<br>当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态，Java虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得CPU的使用权。<br>运行状态（Running）<br>处于这个状态的线程占用CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。<br>阻塞状态（Blocked）<br>阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。<br>阻塞状态可分为以下3种：<br>① 位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：当线程处于运行状态时，如果执行了某个对象的wait()方法，Java虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。<br>② 位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。<br>③ 其他阻塞状态（Otherwise Blocked）：当前线程执行了sleep()方法，或者调用了其他线程的join()方法，或者发出了I/O请求时，就会进入这个状态。<br>死亡状态（Dead）<br>当线程退出run()方法时，就进入死亡状态，该线程结束生命周期。<br>我们运行之前的那个死锁代码SimpleDeadLock.java，然后尝试输出信息(/<em>这是注释，作者自己加的</em>/)：</p><h3 id="在Java中CycliBarriar和CountdownLatch有什么区别？"><a href="#在Java中CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="在Java中CycliBarriar和CountdownLatch有什么区别？"></a>在Java中CycliBarriar和CountdownLatch有什么区别？</h3><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。<br>Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。<br>你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。<br>所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。<br>CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止<br>CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><h3 id="什么是不可变对象，它对写并发应用有什么帮助？"><a href="#什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助？"></a>什么是不可变对象，它对写并发应用有什么帮助？</h3><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。<br>不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。<br>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。<br>不可变对象永远是线程安全的。<br>只有满足如下状态，一个对象才是不可变的；<br>它的状态不能在创建后再被修改；<br>所有域都是final类型；并且，<br>它被正确创建（创建期间没有发生this引用的逸出）。</p><h3 id="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h3><p>如果其他方法没有synchronized的话，其他线程是可以进入的。<br>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><h3 id="SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="SynchronizedMap和ConcurrentHashMap有什么区别？"></a>SynchronizedMap和ConcurrentHashMap有什么区别？</h3><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。<br>ConcurrentHashMap使用分段锁来保证在多线程下的性能。ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。<br>另外ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h3 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>产生死锁的必要条件：<br>互斥条件：所谓互斥就是进程在某一时间内独占资源。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。<br>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。<br>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。<br>Java中导致饥饿的原因：<br>高优先级线程吞噬所有的低优先级线程的CPU时间。<br>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。<br>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。</p><h3 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。<br>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。<br>乐观锁的实现方式：<br>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。<br>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。<br>CAS缺点：<br>ABA问题：<br>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。<br>循环时间长开销大：<br>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。<br>只能保证一个共享变量的原子操作：<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。<br>51、怎么检测一个线程是否拥有锁？<br>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><h3 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h3><p>举例来说明锁的可重入性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class UnReentrant&#123;</span><br><span class="line">    Lock lock = new Lock();</span><br><span class="line">    public void <span class="function"><span class="title">outer</span></span>()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">inner</span></span>()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        //<span class="keyword">do</span> something</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outer中调用了inner，outer先锁住了lock，这样inner就不能再获取lock。其实调用outer的线程已经获取了lock锁，但是不能在inner中重复利用已经获取的锁资源，这种锁即称之为 不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。<br>synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p><h3 id="CopyOnWriteArrayList可以用于什么应用场景？"><a href="#CopyOnWriteArrayList可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList可以用于什么应用场景？"></a>CopyOnWriteArrayList可以用于什么应用场景？</h3><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。<br>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；<br>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；<br>CopyOnWriteArrayList透露的思想<br>读写分离，读和写分开<br>最终一致性<br>使用另外开辟空间的思路，来解决并发冲突</p><h3 id="什么叫线程安全？servlet是线程安全吗"><a href="#什么叫线程安全？servlet是线程安全吗" class="headerlink" title="什么叫线程安全？servlet是线程安全吗?"></a>什么叫线程安全？servlet是线程安全吗?</h3><p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。<br>Servlet不是线程安全的，servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。<br>Struts2的action是多实例多线程的，是线程安全的，每个请求过来都会new一个新的action分配给这个请求，请求完成后销毁。<br>SpringMVC的Controller是线程安全的吗？不是的，和Servlet类似的处理流程<br>Struts2好处是不用考虑线程安全问题；Servlet和SpringMVC需要考虑线程安全问题，但是性能可以提升不用处理太多的gc，可以使用ThreadLocal来处理多线程的问题。<br>38、volatile有什么用？能否用一句话说明下volatile的应用场景？<br>volatile保证内存可见性和禁止指令重排。<br>volatile用于多线程环境下的单次操作(单次读或者单次写)。</p><h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><p>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。<br>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。<br>39、为什么代码会重排序？<br>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<br>在单线程环境下不能改变程序运行的结果；<br>存在数据依赖关系的不允许重排序<br>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p><h3 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h3><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h3 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><h3 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><h3 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h3><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。<br>在JDK8后，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p><h3 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h3><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p><h3 id="Java中interrupted-和-isInterrupted方法的区别？"><a href="#Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="Java中interrupted 和 isInterrupted方法的区别？"></a>Java中interrupted 和 isInterrupted方法的区别？</h3><p>interrupt<br>interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。<br>interrupted<br>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。<br>isInterrupted<br>仅仅是查询当前线程的中断状态</p><h3 id="你如何确保main-方法所在的线程是Java-程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java-程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java 程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java 程序最后结束的线程？</h3><p>我们可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。</p><h3 id="线程之间是如何通信的？"><a href="#线程之间是如何通信的？" class="headerlink" title="线程之间是如何通信的？"></a>线程之间是如何通信的？</h3><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait() otify() otifyAll()方法可以用于线程间通信关于资源的锁的状态。<br>中断和共享变量</p><h3 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h3><p>在两个线程间共享变量即可实现共享。<br>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p><h3 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h3><p><code>kill -3 [java pid] </code><br>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。<br><code>Jstack [java pid] </code><br>这个比较简单，在当前终端显示，也可以重定向到指定文件中。<br><code>-JvisualVM：Thread Dump </code><br>不做说明，打开JvisualVM后，都是界面操作，过程还是很简单的。</p><h3 id="JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的?"></a>JVM中哪个参数是用来控制线程的栈堆栈小的?</h3><p><code>-Xss</code> 每个线程的栈大小</p><h3 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。<br>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p><h3 id="Java中你怎样唤醒一个阻塞的线程？"><a href="#Java中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java中你怎样唤醒一个阻塞的线程？"></a>Java中你怎样唤醒一个阻塞的线程？</h3><p>在Java发展史上曾经使用suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。<br>解决方案可以使用以对象为目标的阻塞，即利用Object类的wait()和notify()方法实现线程阻塞。<br>首先，wait、notify方法是针对对象的，调用任意对象的wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify方法必须在synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用wait、notify方法的对象是同一个，如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行wait阻塞后当前线程就将之前获取的对象锁释放。</p><h3 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p><h3 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？"></a>为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield ()方法是静态的？"></a>为什么Thread类的sleep()和yield ()方法是静态的？</h3><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><h3 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h3><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。<br>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><h3 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h3><p>notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p><h3 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h3><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。<br>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><h3 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h3><p>Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p><h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。<br>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p><h3 id="在java中wait和sleep方法的不同？"><a href="#在java中wait和sleep方法的不同？" class="headerlink" title="在java中wait和sleep方法的不同？"></a>在java中wait和sleep方法的不同？</h3><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。<br>直接了解的深入一点吧：<br><img src="/2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/1.png" alt="1"></p><p>在Java中线程的状态一共被分成6种：<br>初始态：NEW<br>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。<br>运行态：RUNNABLE<br>在Java中，运行态包括就绪态和运行态。<br>就绪态该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中。<br>运行态获得CPU执行权，正在执行的线程。由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。<br>阻塞态<br>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在Java中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。PS：锁、IO、Socket等都资源。<br>等待态<br>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。也有一个等待队列存放所有等待态的线程。线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁）<br>超时等待态<br>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；进入该状态后释放CPU执行权 和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。<br>终止态<br>线程执行结束后的状态。<br>注意：<br>wait()方法会释放CPU执行权 和 占有的锁。<br>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。<br>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。<br>wait和notify必须配套使用，即必须使用同一把锁调用；<br>wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</p><h3 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h3><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。<br>71、同步方法和同步块，哪个是更好的选择？<br>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。<br>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。<br>73、什么是Java Timer 类？如何创建一个有特定时间间隔的任务？<br>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>目前有开源的Qurtz可以用来创建定时任务。</p><p>callable接口 有返回值 runnable接口无返回值<br>做完跳出while循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">While( ! futureTask.isDone )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么用线程池-线程池优势"><a href="#为什么用线程池-线程池优势" class="headerlink" title="为什么用线程池 线程池优势"></a>为什么用线程池 线程池优势</h3><p><img src="/2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/2.png" alt="2"><br>线程池底层 就是ThreadPoolExecutor<br>线程池常用为三种<br><img src="/2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/3.png" alt="2"><br>Executors.newFixedThreadPool(); 一池固定线程数 执行长期的任务<br>Executors.newSingleThreadExecutor();一池一线程 一个任务一个任务执行的场景<br>Executors.newCatchedThreadPool();一池多线程 可扩容 很多短期异步的小程序或者负载较轻的服务<br>底层是ThreadPoolExecutor ，，<br>除catchedThreadPool 底层为synchronousBlockQueue<br>其余两种都为LinkBlockQueue</p><h3 id="线程池的底层原理-7个参数详解"><a href="#线程池的底层原理-7个参数详解" class="headerlink" title="线程池的底层原理 7个参数详解"></a>线程池的底层原理 7个参数详解</h3><p>corePoolSize 核心线程数<br>max 最大线程数<br>keepAliveTime 空闲线程存活时间<br>unit 存活时间单位<br>workQueue 任务对列 一般为阻塞对列 newArrayBlockQueue() newLinkBlockQueue() newSyncronousBlockQueue()<br>threadFactory. 生成工作线程的线程工厂 一般为默认的<br>handler。拒绝策略</p><h3 id="拒绝策略-四种"><a href="#拒绝策略-四种" class="headerlink" title="拒绝策略 四种"></a>拒绝策略 四种</h3><p>拒绝策略：</p><p>最大线程数设置<br>看业务需求 若需求为CPU密集型的设置为核心数<br>如果为IO密集型 1.CPU核心数*2  2.CPU核心数/（1-阻塞系数）阻塞系数一般为0.8～0.9</p><p>对于永久性资源，产生死锁有四个必要条件：<br>互斥条件。一个资源只能被一个进程占用<br>不可剥夺条件。某个进程占用了资源，就只能他自己去释放。<br>请求和保持条件。某个经常之前申请了资源，我还想再申请资源，之前的资源还是我占用着，别人别想动。除非我自己不想用了，释放掉。<br>循环等待条件。一定会有一个环互相等待。</p><p>解决死锁 查看堆栈数据<br>        jps 查看java进程运行状态<br>        jstack 查看进程堆栈数据<br><img src="/2019/09/24/java-%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%AF%86-%E5%B8%B8%E8%AF%86%EF%BC%81/4.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-0类加载</title>
      <link href="2019/09/13/JVM-0%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>2019/09/13/JVM-0%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>java文件是给人看的,二进制是给虚拟机看的,写java-编写,转字节码-编译,然后呢?<br>java文件经过javac编译器生成字节码.class文件,.class说白了就是一个描述java的数据的字节码格式好像是十六进制,一种虚拟机能沟通的格式,他们沟通的过程就是类加载<br>官方点就是:虚拟机把描述类的数据从class文件加载到内存,并对数据进行校验/转换解析和初始化,最终形成可以被虚拟机直接使用的java类型(机器码?)</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>加载-验证-准备-解析-初始化-使用-卸载</p><p><img src="/2019/09/13/JVM-0%E7%B1%BB%E5%8A%A0%E8%BD%BD/1.png" alt="1"><br><img src="/2019/09/13/JVM-0%E7%B1%BB%E5%8A%A0%E8%BD%BD/2.png" alt="1"></p><p>注:解析有时候会在初始化后执行,加载和连接的部分内容也是交叉进行的(如字节码格式验证)</p><h2 id="一-加载"><a href="#一-加载" class="headerlink" title="一:加载"></a>一:加载</h2><p>想加载你的前提是你<font color="#ff0000"> 符合初始化条件</font>,要是符合我就根据你的<font color="#ff0000"> 全限定名找到你的二进制字节流文件</font>,找到了之后把数据转换成<font color="#ff0000"> 方法区运行时的数据结构</font>,然后内存中创建<code>java.lang.Class</code>对象是<strong>找到方法区的这个类的数据的入口</strong><br>(<strong>注意是内存中,没规定一定是java堆中,在HotSpot中Class对象也是放在了方法区中</strong>)<br>官方点就是:<br>1）通过一个类的完全限定名来获取定义此此类的二进制字节流(class/zip/jar/war文件,不是二进制文件)<br>在程序运行过程中,当要访问一个类时,若发现这个类尚未被加载,并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流,开始加载过程<br>2）将这个<font color="#ff0000"> 字节流</font>所代表的静态存储结构转化为<font color="#ff0000">方法区的运行时数据结构</font><br>3）在<strong>内存</strong>生产<code>java.lang.Class</code>对象，作为方法区这个类的各种数据访问入口。</p><p>这里要说一下某些隔路的东西:<strong>数组</strong><br><strong>数组类在1)阶段和别的类不一样,</strong><br>人家都是由类加载器创建,<strong>数组直接由虚拟机创建,而数组中的元素类型由类加载器创建</strong><br>问题:程序启动后偶尔会出现classNotFound异常就是内存中未创建Class对象???</p><h2 id="二-验证"><a href="#二-验证" class="headerlink" title="二:验证"></a>二:验证</h2><p>class是java编译之后生成的,java文件的合理性在编译时由编译器处理了,按理说生成的class也合格,但是作为一个十六进制文件有被十六进制编辑器恶意修改的可能,或者说这个class文件根本就不是由java源码编译而来怎么办?所以一定要验证</p><ol><li>文件格式验证:保证输入的字节流正确的存储于方法区,针对的是二进制字节流,后面的验证都是针对方法区的存储结构<br>例如开头的魔术是0xCAFEBABE/主次版本号在虚拟机处理范围内</li><li>元数据验证:针对类的元数据信息进行语义校验,保证符合java语言规范的元数据信息<br>例如有没有父类,只允许object没有父类/是否继承了final类/重载啥的是否合理<br>问题:这些不是在编译的时候就验证了嘛?内会是java,现在是class,万一偷着改了class呢</li><li>字节码验证:对方法体校验,保证方法运行时不会危害虚拟机<br>例如:跳转指令跳到了方法体以外的字节码指令上/类型转换非法:父类对象赋给子类类型,或者直接赋给八竿子打不着的类型</li><li>符号引用验证:对类自身以外的信息进行匹配性校验(常量池中的各种符号引用)<br>例如:符号引用中的全限定名能否找到类/指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li></ol><p>不是必须的,所有代码要是反复使用过验证过可以在实施阶段使用<code> -Xverify:none</code>关闭验证缩短类加载时间</p><h2 id="三-准备"><a href="#三-准备" class="headerlink" title="三:准备"></a>三:准备</h2><p>为类变量分配内存并初始化,通常情况下是0因为此时尚未执行java中的任何方法包括赋值的符号 =</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static int a = 123; //准备完了是0!!</span><br><span class="line">private final static int c= 123;// final牛逼,是123,因为什么ConstantValue</span><br></pre></td></tr></table></figure><h2 id="四-解析"><a href="#四-解析" class="headerlink" title="四:解析"></a>四:解析</h2><p>将类的二进制数据中的符号引用替换成直接引用。<br>符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。引用的目标不一定加载到内存中.各种虚拟机的符号引用是一致的,明确规范在class文件格式中<br>直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。同一符号引用不同虚拟机翻译出来的直接引用一般不同</p><h2 id="五-初始化"><a href="#五-初始化" class="headerlink" title="五:初始化"></a>五:初始化</h2><p>再此之前的步骤都是虚拟机主导的(选类加载器除外),到现在才开始执行我们自定义的java代码!<br>静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的<br>private static int a = 123; //准备完了是0!!初始化之后是123!!!</p><h2 id="六-类加载时机"><a href="#六-类加载时机" class="headerlink" title="六:类加载时机"></a>六:类加载时机</h2><p>创建类的实例，也就是new一个对象<br>访问某个类或接口的静态变量，或者对该静态变量赋值<br>调用类的静态方法<br>反射（Class.forName(“com.lyj.load”)）<br>初始化一个类的子类（会首先初始化子类的父类）<br>JVM启动时标明的启动类，即文件名和类名相同的那个类<br>       下面几种情形需要特别指出：<br>         对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p><hr><p><font color="#ff0000"> </font></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一:定义"></a>一:定义</h2><p>前面加载阶段那块的1),就是数组比较隔路的地方,数组是由虚拟机直接整的,别的类都是通过类加    载器实现:通过一个类的全限定名来获取描述此类的二进制字节流<br>      类加载器负责加载所有的类(数组除外)<br>其为所有被载入内存中的类生成一个<code>java.lang.Class</code>实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。<font color="#ff0000"> <strong>一个载入JVM的类也有一个唯一的标识</strong></font>。<br>在Java中，一个类用其全限定类名（包括包名和类名）作为标识(如<code>package.aClass</code>)<br>但在JVM中，一个类用其全限定类名+类加载器=唯一标识(如<code>package.aClass.appClassLoader</code>)<br>这意味着两个类加载器加载的同名类：是不同的、它们所加载的类也是完全不同、互不兼容的。<br>如<code>package.aClass.appClassLoader</code> 和<code>package.aClass.ExtClassLoader</code><br>这里的不等包括:<code>equals</code>方法<code>/instanceOf</code>关键字<code>/isInstanceOf()</code>方法等</p><h2 id="二-分类"><a href="#二-分类" class="headerlink" title="二:分类"></a>二:分类</h2><p>1)启动类加载器:BootstrapClassLoader<br>唯一一个由C++实现的加载器所以<font color="#ff0000"> 没有实现<code>javalang.ClassLoader</code></font>,所以也不能被java引用,是虚拟机的一部分<br>负责加载jre/lib/下面的或者是-Xbootclasspath参数指定的(前提虚拟机识别如rt.jar)<br>2)拓展类加载器:ExtensionClassLoader<br>加载jre/lib/ext<br>继承的父类URLClassLoader<br>3)应用程序类加载器:ApplicationClassLoader<br>被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。<br>继承的父类URLClassLoader </p><hr><h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><p>所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。<br><img src="/2019/09/13/JVM-0%E7%B1%BB%E5%8A%A0%E8%BD%BD/3.png" alt="1"><br>注:上面显示的双亲委派的关系,不是继承中的父子关系</p><p>类加载器加载Class大致要经过如下8个步骤：<br>1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。<br>2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。<br>3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。<br>4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。<br>5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。<br>6.从文件中载入Class，成功后跳至第8步。<br>7.抛出ClassNotFountException异常。<br>8.返回对应的java.lang.Class对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Public class Test&#123;</span><br><span class="line">    Public static void main(String[] arg)&#123;</span><br><span class="line">      ClassLoader c  = Test.class.getClassLoader();  //获取Test类的类加载器</span><br><span class="line">      System.out.println(c); //……AppClassLoader……</span><br><span class="line">      ClassLoader c1 = c.getParent();  //获取c的类加载器的父加载器,不是父类</span><br><span class="line">      System.out.println(c1);//……ExtClassLoader……</span><br><span class="line">      ClassLoader c2 = c1.getParent();//</span><br><span class="line">      System.out.println(c2);//Null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExtClassLoader的Parent为 null ，<br>Bootstrap Loader是用C++语言写的，<br>依java的观点来看，逻辑上并不存在Bootstrap Loader的类实体，所以在java程序代码里试图打印出其内容时，我们就会看到输出为null。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器</title>
      <link href="2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>适配适配…….整合适再配</p><h1 id="官方点"><a href="#官方点" class="headerlink" title="官方点"></a>官方点</h1><p>作为两个不兼容的接口之间的桥梁。结构型模式，它结合了两个独立接口的功能。<br>以手机为例子，每一种机型都自带有从电器,你的没带他的带了你用不了,因为你俩不配!<br>谁配?共享充电宝,有三个口,假装他就一个口,他就是谁都配</p><p>两种形式:<br><strong>类的适配</strong><br><strong>对象的适配</strong></p><p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>解决</strong>：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用</strong>：<br>系统需要使用现有的类，而此类的接口不符合系统的需要。<br>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口<br>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决</strong>：继承或依赖（推荐）。</p><p><strong>关键代码</strong>：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>优点</strong>：<br>1、可以让任何两个没有关联的类一起运行。<br>2、提高了类的复用。<br>3、增加了类的透明度。<br>4、灵活性好。</p><p><strong>缺点</strong>：<br>1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。<br>比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。<br>2、由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><hr><h1 id="类的适配："><a href="#类的适配：" class="headerlink" title="类的适配："></a>类的适配：</h1><p>这种适配器由三种角色组成：<br>1、目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。<br>2、源(Adapee)角色：现在需要适配的接口。<br>3、适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。<br>　　<br><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/1.png" alt="1"></p><p>　　故事情景：手机充电用手机充电器充电，耳机用耳机充电器充电，现在要实现给手机充电的同时也能给耳机充电。<br>　　首先来一个IPhone的充电器类(Adaptee角色)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 充电器接口</span><br><span class="line"> */</span><br><span class="line">public interface ICharge &#123;</span><br><span class="line">    void charge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 苹果手机充电器需要适配的角色（Adapee）</span><br><span class="line"> */</span><br><span class="line">public class AppleCharger implements ICharge&#123;</span><br><span class="line">    public void <span class="function"><span class="title">charge</span></span>()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;The ApplePhone is charging ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　现在，要对这个特殊的充电器进行适配，上个适配的接口(Target目标角色)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 要对这个特殊的充电器进行适配,适配器接口(Target角色)</span><br><span class="line"> */</span><br><span class="line">public interface IChargeAdapter &#123;</span><br><span class="line">    void charge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>　　　创建类的适配器：　　</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 多接头充电器，支持一边充手机，一边充耳机（Adaper）</span><br><span class="line"> */</span><br><span class="line">public class MultipleJointsCharger extends AppleCharger implements IChargeAdapter&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">charge</span></span>() &#123;</span><br><span class="line">        super.charge();</span><br><span class="line">        System.out.println(<span class="string">&quot;The Headset is charging ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>　　　启动类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动类</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartClass &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MultipleJointsCharger multipleJointsCharger = new MultipleJointsCharger();</span><br><span class="line">        multipleJointsCharger.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　控制台：<br><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/2.png" alt="1"></p><hr><h1 id="对象的适配："><a href="#对象的适配：" class="headerlink" title="对象的适配："></a>对象的适配：</h1><p> 对象的适配依赖于对象的组合，而不是类适配中的继承。</p><p><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/3.png" alt="1"></p><p>　　故事情景：苹果手机用苹果充电器充电，安卓手机用安卓手机充电，现在需要一个万能充电器能给这两种手机充电。<br>　　创建两个充电器类(Adaptee源角色)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 充电器接口</span><br><span class="line"> */</span><br><span class="line">public interface ICharge &#123;</span><br><span class="line">    void charge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 安卓手机充电器需要适配的角色（Adaptee）</span><br><span class="line"> */</span><br><span class="line">public class AndroidCharger implements ICharge&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">charge</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The AndroidPhone is charging ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 苹果手机充电器需要适配的角色（Adaptee）</span><br><span class="line"> */</span><br><span class="line">public class AppleCharger implements ICharge&#123;</span><br><span class="line">    public void <span class="function"><span class="title">charge</span></span>()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;The ApplePhone is charging ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　　现在，要对这个特殊的充电器进行适配，上个适配的接口(Target目标角色)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 要对这个特殊的充电器进行适配,适配器接口(Target角色)</span><br><span class="line"> */</span><br><span class="line">public interface IChargeAdapter &#123;</span><br><span class="line">    void charge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　　创建类的适配器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 万能充电器,类的适配器(Adaper)</span><br><span class="line"> */</span><br><span class="line">public class UniversalCharger implements IChargeAdapter&#123;</span><br><span class="line">    private ICharge charge;</span><br><span class="line"></span><br><span class="line">    public UniversalCharger(ICharge charge)&#123;</span><br><span class="line">        this.charge = charge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">charge</span></span>() &#123;</span><br><span class="line">        charge.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　启动类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动类</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartClass &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        UniversalCharger universalCharger = new UniversalCharger(new AppleCharger());</span><br><span class="line">        universalCharger.charge();</span><br><span class="line"></span><br><span class="line">        UniversalCharger universalCharger1 = new UniversalCharger(new AndroidCharger());</span><br><span class="line">        universalCharger1.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>　　控制台：<br><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/4.png" alt="1"></p><hr><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。<br>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个包装类，持有原类的一个实例，在包装类的方法中，调用实例的方法就行。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-3.从删除到表文件</title>
      <link href="2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/"/>
      <url>2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>问题: 把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</strong><br>从表结构说起….<br>一个 InnoDB 表包含两部分，即：表结构定义和数据<br>MySQL 8版本以前，表结构是存在以<code>.frm</code> 为后缀的文件里。<br>MySQL 8 版本已经允许把表结构定义放在系统数据表中了。<br>因为表结构定义占用的空间很小，重点是表数据。</p><ul><li>参数 <code>innodb_file_per_table</code>:<br>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的：<br>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；<br>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以<code>.ibd</code>为后缀的文件中。<br>MySQL 5.6.6 版本开始，它的默认值就是 ON 了。<br>建议开启:一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。<br>而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</li></ul><hr><h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p><img src="/2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/1.png" alt="1"><br>假设，我们要删掉 <code>R4 </code>这个记录，InnoDB 引擎只会把<code>R4</code>这个记录标记为删除。<br>如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，<strong>磁盘文件的大小并不会缩小</strong>。<br><strong>InnoDB 的数据是按页存储的，如果删掉了一个数据页上的所有记录，会怎么样？</strong><br>整个数据页就可以被复用了。<br>但是，<strong>数据页的复用跟记录的复用是不同的</strong>。</p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，<code>R4</code> 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置了。<br>而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以图 1 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。<br>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。<br>进一步地，如果我们用 <code> delete</code>命令把整个表的数据删除呢？<br>结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。<br>你现在知道了，<code> delete</code>命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。<br>也就是说，通过 <code> delete</code>命令是<strong>不能回收表空间</strong>的。这些可以复用，而没有被使用的空间，看起来就像是“<strong>空洞</strong>”。</p><p>不止是删除数据会造成空洞，插入数据也会。<br>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是<strong>随机插入的，就可能造成索引的数据页分裂</strong>。</p><p>假设图 1 中 page A 已经满了，这时我要再插入一行数据，会怎样呢？<br><img src="/2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/2.png" alt="1"><br>可以看到，由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的页面 page B 来保存数据了。<br>页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）。<br>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。<br>也就是说，<strong>经过大量增删改的表，都是可能是存在空洞的</strong>。<br>所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。<br>而<strong>重建表</strong>，就可以达到这样的目的。</p><hr><h1 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h1><p><strong>有一个表 A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</strong><br>新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。<br>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p><p><strong>使用 <code>alter table A engine=InnoDB</code> 命令来重建表!!!!</strong><br>  5.5之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。<br><img src="/2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/3.png" alt="3"><br>花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 <code>Online</code> 的。</p><p>MySQL 5.6 版本开始引入的<code> Online DDL</code>，对这个操作流程做了优化。<br>引入了<code> Online DDL</code> 之后，重建表的流程： </p><ol><li>建立一个临时文件，扫描表 A 主键的所有数据页；</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 <code>state2</code> 的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 <code>state3</code> 的状态；</li><li>用临时文件替换表 A 的数据文件。<br><img src="/2019/08/12/mysql-3-%E4%BB%8E%E5%88%A0%E9%99%A4%E5%88%B0%E8%A1%A8%E6%96%87%E4%BB%B6/4.png" alt="4"><br>由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是<code> Online DDL</code> 名字的来源。</li></ol><p>问题:<br><strong>1.DDL 之前是要拿 <code>MDL</code> 写锁的，这样还能叫<code> Online DDL</code> 吗？</strong><br><code>alter</code> 语句在启动的时候需要获取 <code>MDL</code> 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。<br><strong>2.为什么要退化呢？</strong><br>为了实现 Online，MDL 读锁不会阻塞增删改操作。<br><strong>3.为什么不干脆直接解锁呢？</strong><br>为了保护自己，禁止其他线程对这个表同时做 DDL。</p><p>而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。<br>所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p><p>对于很大的表来说，这个操作是<strong>很消耗 IO 和 CPU 资源</strong>的。<br>线上服务，要很小心地控制操作时间。如果想要比较安全的操作的话，可用 GitHub 开源的 gh-ost 来做。</p><h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>在图3，把表 A 中的数据导出来的存放位置叫作 <code>tmp_table</code>。这是一个临时表，是在 server 层创建的。<br>在图4既上图，根据表 A 重建出来的数据是放在<code>tmp_file</code>里的，这个临时文件是 InnoDB 在内部创建出来的。<br>整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“<code> inplace</code>”名称的来源。</p><p>如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 <code> inplace</code> 的 DDL 呢？<br>不能。因为，tmp_file 也是要占用临时空间的。</p><p>我们重建表的这个语句 <code>alter table t engine=InnoDB</code>，其实隐含的意思是：<br><code>alter table t engine=innodb,ALGORITHM=inplace;</code></p><p>跟 <code> inplace</code> 对应的就是拷贝表的方式了，用法是：<br><code>alter table t engine=innodb,ALGORITHM=copy;</code><br>当你使用 <code>ALGORITHM=copy</code> 的时候，表示的是强制拷贝表，对应的流程就是图 3 的操作过程。</p><p><code> inplace</code> 跟 <code>Online</code> 是不是就是一个意思？<br>不是的，只是在重建表这个逻辑中刚好是这样而已。<br>比如，如果我要给 InnoDB 表的一个字段加全文索引，写法是：<br><code>alter table t add FULLTEXT(field_name);</code><br>DDL 过程如果是 <code>Online</code> 的，就一定是 <code> inplace</code> 的；<br>反过来未必，也就是说 <code> inplace</code> 的 DDL，有可能不是 <code>Online</code> 的。<br>截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</p><p><strong>问题:什么时候使用 <code>alter table t engine=InnoDB</code> 会让一个表占用的空间反而变大。</strong><br>这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。又重新执行这个语句,在 DDL 期间，如果刚好有外部的 DML 在执行，这期间可能会引入一些新的空洞。<br>而且在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。<br>将表 t 重建一次；<br>插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；<br>这种情况下，再重建一次表 t，就可能会出现问题中的现象。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-2.从查询看架构,从更新看日志</title>
      <link href="2019/08/03/mysql-2-%E4%BB%8E%E6%9F%A5%E8%AF%A2%E7%9C%8B%E6%9E%B6%E6%9E%84-%E4%BB%8E%E6%9B%B4%E6%96%B0%E7%9C%8B%E6%97%A5%E5%BF%97/"/>
      <url>2019/08/03/mysql-2-%E4%BB%8E%E6%9F%A5%E8%AF%A2%E7%9C%8B%E6%9E%B6%E6%9E%84-%E4%BB%8E%E6%9B%B4%E6%96%B0%E7%9C%8B%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h1><p><img src="/2019/08/03/mysql-2-%E4%BB%8E%E6%9F%A5%E8%AF%A2%E7%9C%8B%E6%9E%B6%E6%9E%84-%E4%BB%8E%E6%9B%B4%E6%96%B0%E7%9C%8B%E6%97%A5%E5%BF%97/1.png" alt="1"><br>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。<br>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。<br>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。<br>你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB<br>不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</p><h2 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：<code>mysql -h$ip -P$port -u$user -p</code></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。<br>怎么解决这个问题呢？你可以考虑以下两种方案。<br>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。<br>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 <code>key-value</code> 对的形式，被直接缓存在内存中。<code>key</code>是查询的语句，<code>value</code> 是查询的结果。如果你的查询能够直接在这个缓存中找到 <code>key</code>，那么这个 <code>value</code> 就会被直接返回给客户端。<br>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。<br>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存</p><p>可以将参数 <code>query_cache_type</code> 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：<br><code>select SQL_CACHE * from T where ID=10；</code><br>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h2 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h2><p>对 SQL 语句做解析。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。<br>MySQL 从你输入的”<code>select</code>“这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><h2 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：<br><code>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</code><br>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。<br>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h2 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h2><p>执行器就会根据表的引擎定义，去使用这个引擎提供的接口。<br>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：<br>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；<br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><hr><h1 id="一条SQL更新语句是如何执行的？"><a href="#一条SQL更新语句是如何执行的？" class="headerlink" title="一条SQL更新语句是如何执行的？"></a>一条SQL更新语句是如何执行的？</h1><p><code>update T set c=c+1 where ID=2;</code><br>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。<br>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用<code>ID</code>这个索引。然后，执行器负责具体执行，找到这一行，然后更新。<br>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程<code>IO</code>成本、查找成本都很高。<br>为了解决这个问题，<code>MySQL</code>的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。<br><font color="#ff0000"><strong>WAL</strong><font> 的全称是<code> Write-Ahead Logging</code>，它的关键点就是<strong>先写日志，再写磁盘</strong></font></font></p><h2 id="1-redo-log-属于InnoDB特有"><a href="#1-redo-log-属于InnoDB特有" class="headerlink" title="1.redo log:属于InnoDB特有"></a>1.redo log:属于InnoDB特有</h2><p>当有一条记录需要更新:<br><code>InnoDB</code> 引擎先把记录写到 <code>redo log</code>（粉板）里面，并更新内存。<br>在系统比较空闲的时候，将这个操作记录更新到磁盘里面<br><code>InnoDB</code> 的 <code>redo log</code> 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写<br><img src="/2019/08/03/mysql-2-%E4%BB%8E%E6%9F%A5%E8%AF%A2%E7%9C%8B%E6%9E%B6%E6%9E%84-%E4%BB%8E%E6%9B%B4%E6%96%B0%E7%9C%8B%E6%97%A5%E5%BF%97/2.png" alt="1"><br>有了 <code>redo log</code>，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <code>crash-safe</code>。</p><h2 id="2-binlog-属于Server-层"><a href="#2-binlog-属于Server-层" class="headerlink" title="2.binlog:属于Server 层"></a>2.binlog:属于Server 层</h2><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 <code>crash-safe</code> 的能力，binlog 日志只能用于归档。<br>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠<code>binlog</code>是没有 <code>crash-safe</code> 能力的，所以 InnoDB 使用另外一套日志系统——也就是 <code>redo log </code>来实现 crash-safe 能力。</p><h2 id="3-重做和归档的区别"><a href="#3-重做和归档的区别" class="headerlink" title="3.重做和归档的区别"></a>3.重做和归档的区别</h2><p><code>redo log</code> 是 InnoDB 引擎特有的；<code>binlog</code> 是 MySQL 的 Server 层实现的，所有引擎都可以使用。<br><code>redo log</code> 是<strong>物理日志</strong>，记录的是“<strong>在某个数据页上做了什么修改</strong>”；<code>binlog</code> 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。<br><code>redo log</code> 是<strong>循环写的</strong>，空间固定会用完；<code>binlog</code> 是可以追加写入的。“追加写”是指 <code>binlog</code> 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p><h2 id="4-InnoDB执行update流程"><a href="#4-InnoDB执行update流程" class="headerlink" title="4.InnoDB执行update流程"></a>4.InnoDB执行update流程</h2><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 <code>redo log</code> 里面，此时 <code>redo log</code> 处于<code>prepare</code>状态。</li><li>然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 <code>binlog</code>，并把 <code>binlog</code> 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 <code>redo log</code> 改成提交（commit）状态，更新完成。<br><img src="/2019/08/03/mysql-2-%E4%BB%8E%E6%9F%A5%E8%AF%A2%E7%9C%8B%E6%9E%B6%E6%9E%84-%E4%BB%8E%E6%9B%B4%E6%96%B0%E7%9C%8B%E6%97%A5%E5%BF%97/3.png" alt="1"><br>浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</li></ol><p>最后三步看上去有点“绕”，将 <code>redo log</code> 的写入拆成了两个步骤：<code>prepare</code> 和 <code>commit</code>，这就是”<strong>两阶段提交</strong>“。</p><h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5.两阶段提交"></a>5.两阶段提交</h2><p>为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？</p><p><code>binlog</code> 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 <code>binlog</code>，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时,有一次误删表，需要找回数据:<br>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；<br>然后，从备份的时间点开始，将备份的 <code>binlog</code> 依次取出来，重放到中午误删表之前的那个时刻。</p><p><strong>为什么日志需要“两阶段提交”</strong>?<br>反证,由于<code>redo log</code>和 <code>binlog</code> 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完<code>redo log</code>再写 <code>binlog</code>，或相反</p><ol><li><p>先写 <code>redo log</code> 后写 <code>binlog</code>:  假设在 <code>redo log</code> 写完，<code>binlog </code>还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于<code>binlog</code>没写完就 crash 了，这时候 <code>binlog</code> 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的<code>binlog</code>里面就没有这条语句。然后你会发现，如果需要用这个 <code>binlog</code> 来恢复临时库的话，由于这个语句的 <code>binlog</code> 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></li><li><p>先写<code>binlog</code>后写 <code>redo log</code>:  如果在<code>binlog</code>写完之后 crash，由于<code>redo log</code>还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是<code>binlog</code>里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用<code>binlog</code>来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p></li></ol><p>可以看到，如果不使用“两阶段提交”，那么<strong>数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong>。</p><p>不只是误操作后需要用这个过程来恢复数据。当你需要<strong>扩容</strong>的时候，多搭建一些<strong>备库</strong>来增加系统的读能力的时候，常见的也是用全量备份加上应用<code>binlog</code>来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，<code>redo log</code>和<code>binlog</code>都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><p><strong>总结:</strong><br>物理日志<code>redo log</code>和逻辑日志 <code>binlog</code>。<br><code>redo log</code> 用于保证 <code>crash-safe</code> 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设成 1 的时候，表示每次事务的<code>redo log</code>都直接持久化到磁盘。以此保证 MySQL 异常重启之后数据不丢失。<br><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的<code>binlog</code>都持久化到磁盘。可以保证 MySQL 异常重启之后<code>binlog</code>不丢失。</p><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p><strong>1.在两阶段提交的不同瞬间，MySQL 如果发生异常重启，是怎么保证数据完整性的？</strong></p><ol><li>上图中时刻 A 的地方，也就是写入<code>redo log</code>处于 prepare 阶段之后、写<code>binlog</code>之前，发生了崩溃（crash），由于此时<code>binlog</code>还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。</li><li>时刻 B，也就是<code>binlog</code>写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？<br>先来看一下崩溃恢复时的判断规则。<br>a. 如果<code>redo log</code>里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；<br>b.  如果<code>redo log</code>里面的事务只有完整的 prepare，则判断对应的事务<code>binlog</code>是否存在并完整：<br> 1). 如果是，则提交事务；<br> 2). 否则，回滚事务。<br>这里，时刻 B 发生 crash 对应的就是 a(1) 的情况，崩溃恢复过程中事务会被提交。</li></ol><p><strong>2.MySQL 怎么知道<code>binlog</code>是完整的?</strong></p><ol><li>一个事务的<code>binlog</code>是有完整格式的：<br>statement 格式的 binlog，最后会有 COMMIT；<br>row 格式的 binlog，最后会有一个 XID event。</li><li>binlog-checksum 参数验证<code>binlog</code>内容的正确性。</li></ol><p><strong>3. <code>redo log</code> 和<code>binlog</code>是怎么关联起来的?</strong><br>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 <code>redo log</code>：<br>如果碰到既有 <code>prepare</code>、又有 commit 的<code> redo log</code>，就直接提交；<br>如果碰到只有 <code>parepare</code>、而没有 commit 的 <code>redo log</code>，就拿着 XID 去<code>binlog</code>找对应的事务。</p><p><strong>4.处于 <code>prepare</code> 阶段的<code>redo log</code>加上完整<code> binlog</code>，重启就能恢复，MySQL 为什么要这么设计?</strong><br>在时刻 B，也就是<code>binlog</code>写完以后 MySQL 发生崩溃，这时候<code>binlog</code>已经写入了，之后就会被从库（或者用这个<code>binlog</code>恢复出来的库）使用。<br>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><p><strong>5.如果这样的话，为什么还要两阶段提交呢？干脆先<code>redo log</code>写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以不一样吗？</strong></p><p>两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。<br>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。<br>对于 InnoDB 引擎来说，如果<code>redo log</code>提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。<br>而如果<code>redo log</code>直接提交，然后<code>binlog</code>写入的时候失败，InnoDB 又回滚不了，数据和<code>binlog</code>日志又不一致了。<br>两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交。</p><p><strong>6.不引入两个日志，也就没有两阶段提交的必要了。只用<code>binlog</code>来支持崩溃恢复，又能支持归档，不就可以了？或者只用 redo log，不要 binlog？</strong></p><p><strong>7.redo log 一般设置多大？</strong><br>redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。<br>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将<code>redo log</code>设置为 4 个文件、每个文件 1GB 吧。</p><p><strong>8.redo log buffer 是什么？是先修改内存，还是先写<code>redo log</code>文件？</strong><br>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到<code>redo log</code>文件里。<br>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。<br>但是，真正把日志写到<code>redo log</code>文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。</p><p><strong>9.执行一个 update 语句后，再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？</strong><br>这可能是因为 WAL 机制的原因。update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p><p><strong>10.为什么<code>binlog</code>cache 是每个线程自己维护的，而<code>redo log</code>buffer 是全局共用的？</strong><br>MySQL 这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的<code>binlog</code>必须连续写，因此要整个事务完成后，再一起写到文件里。而<code>redo log</code>并没有这个要求，中间有生成的日志可以写到<code>redo log</code>buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。<br>事务执行期间，还没到提交阶段，如果发生 crash 的话，redo log 肯定丢了，这会不会导致主备不一致呢？<br>不会。因为这时候<code>binlog</code>也还在<code>binlog</code>cache 里，没发给备库。crash 以后<code>redo log</code>和<code>binlog</code>都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><p><strong>11.MySQL是怎么保证数据不丢的</strong><br>binlog的写入机制<br>redo log的写入机制</p><p><strong>12.如果MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能</strong><br>1.设置<code>binlog_group_commit_sync_delay</code>（延迟多少微妙后才调用fsync）和<code>binlog_group_commit_sync_no_delay_count</code>（积累多少次以后才调用fsync）参数，<strong>减少binlog的写盘次数</strong>。这个方法是基于额外的故意等待来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险<br>2.将<code>sync_binlog</code>设置为大于1的值（每次提交事务都write，但累积N个事务后才fsync）。这样做的风险是，主机掉电的时候会丢binlog日志<br>3.将<code>innodb_flush_log_at_trx_commit</code>设置为2（每次事务提交时都只是把redo log写到<code>page cache</code>）。这样做的风险是，主机掉电的时候会丢数据</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-1.索引相关</title>
      <link href="2019/07/27/mysql-1.%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
      <url>2019/07/27/mysql-1.%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>索引是对数据库中一或多个列值的排序，帮助数据库高效获取数据的数据结构<br>假如我们用类比的方法，数据库中的索引就相当于书籍中的目录一样，当我们想找到书中的摸个知识点，我们可以直接去目录中找而不是在书中每页的找，但是这也抛出了索引的一个缺点，在对数据库修改的时候要修改索引到导致时间变多。<br><strong>一个表最多16个索引</strong></p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li><font color="#008000">从物理存储角度:</font><br> 聚簇索引和非聚簇索引</li><li><font color="#008000">从数据结构角度:</font><br> B+树索引、hash索引、FULLTEXT索引、R-Tree索引</li><li><font color="#008000">从逻辑角度:</font><br> <strong>主键索引</strong>：主键索引是一种特殊的唯一索引，不允许有空值<br> <strong>普通索引</strong>或者单列索引<br> <strong>多列索引</strong>（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合<br> <strong>唯一索引</strong><br> <strong>空间索引</strong>：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是geometry、point、linestring、polygon。</li></ul><hr><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p><code>PRIMARY KEY</code> 一个表只能一个,不允许有空值<br>主键索引不可以删除重建例如:<br><code>alter table T drop primary key;</code><br><code>alter table T add primary key(id)</code>;<br>不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。可以<code>alter table T engine=InnoDB</code>(一条神奇语句,删除操作具体分析)代替</p><h3 id="和非主键索引的区别"><a href="#和非主键索引的区别" class="headerlink" title="和非主键索引的区别"></a>和非主键索引的区别</h3><p>非主键索引的叶子节点存放的是<font color="#FF0000">主键的值</font><br>而主键索引的叶子节点存放的是<font color="#FF0000">整行数据</font>，<br>非主键索引也被称为二级索引/非聚簇索引，而<strong>主键索引也被称为聚簇索引</strong>。<br>注:除了主键索引以外，创建一个非主键索引还是有必要的。相比之下，非聚簇索引要比聚簇索引小很多,而且还有利于count函数<br><code>select * from table where ID = 100</code>,主键查询只需搜索 <code>ID</code> 这棵 B+树。<br><code>select * from table where k = 1</code>，非主键的查询方式先搜索<code>k</code>索引树，得到ID=100(叶子节点存放的不是整行数据),<strong>再到ID索引树搜索一次</strong>，这个过程也被称为<font color="#FF0000"><strong>回表</strong></font>。(EXPLAIN—Using Index不会回表，Using Where需要回表取数据。)<br><strong>基于非主键索引的查询需要多扫描一棵索引树(主键索引树)</strong><br>非主键索引速度比主键索引速度慢主要是因为回表,需要二次查询,通过<strong>覆盖索引可以让非主键索引不需要回表</strong></p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。<br>当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，<strong>这样避免了查到索引后再返回表操作，减少I/O提高效率</strong>。<br>有一个联合索引(a,b)<br>执行如下SQL<code>select a,b from table1</code>在索引上就能找到结果，就不用回表去查询！<br>而你执行的是<code>select a,b,c from table2</code>c列在索引上不存在，就需要回表查询。这也是为什么要*<em>避免SELECT</em>的原因之一**：<br><code>select ＊from table where id＝xx</code><br><code>select id from table where id＝xx</code> 都不需要回表,因为用的是主键,主键和数据都在同一个树中<br>注:覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以<font color="#FF0000">mysql只能用B+ tree索引做覆盖索引</font>。</p><h3 id="建议主键索引自增"><a href="#建议主键索引自增" class="headerlink" title="建议主键索引自增:"></a>建议主键索引自增:</h3><p> B+ 树是有序的，插入中间位置比较耗时，这样就会比较消耗时,插入页满了还要进行页分裂操作，<br>如果主键是自增，每次插入的 ID 都会比前面的大，每次只需要在后面插入就行， <strong>不需要移动位置、分裂等操作，提高性能</strong><br>自增达到最大值时它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。<br>分布式ID（雪花算法生成的ID）生成的索引会比自增长的ID性能低吗？<br>不会,雪花算法生成的ID是越来越大的，但不是逐渐递增,性能一样的，没有一定要“连续”，只要是递增</p><h3 id="什么场景适合用业务字段直接做主键"><a href="#什么场景适合用业务字段直接做主键" class="headerlink" title="什么场景适合用业务字段直接做主键?"></a>什么场景适合用业务字段直接做主键?</h3><p>只有一个索引且该索引必须是唯一索引。就是典型的 <code>KV</code> 场景。<br>由于没有其他索引，就不用考虑<strong>其他索引的叶子节点大小</strong>的问题。<br>优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以<strong>避免每次查询需要搜索两棵树</strong>。</p><hr><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>UNIQUE,允许有空值。如果是组合索引，则列值的组合必须唯一<br><font color="#0000FF">《阿里巴巴JAVA开发规范》:【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</font></p><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，<br>只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p><h3 id="为什么唯一索引的查找速度比普通索引快？"><a href="#为什么唯一索引的查找速度比普通索引快？" class="headerlink" title="为什么唯一索引的查找速度比普通索引快？"></a>为什么唯一索引的查找速度比普通索引快？</h3><p>普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。<br>唯一索引在找到满足条件的第一条记录后，<strong>直接返回</strong>，不用判断下一条记录了。</p><h3 id="为什么唯一索引的插入速度比不上普通索引？"><a href="#为什么唯一索引的插入速度比不上普通索引？" class="headerlink" title="为什么唯一索引的插入速度比不上普通索引？"></a>为什么唯一索引的插入速度比不上普通索引？</h3><p>要从<code>Insert Buffer</code>开始讲，在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入<code>Insert Buffer</code> 中，然后再以一定频率和情况进行<code>Insert Buffer</code>和原数据页合并<code>(merge)</code>操作。<br>这么做的优点:能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。<br>InnoDB 从 1.0.x 版本开始引入了 <code>Change Buffer</code>，算是对<code> Insert Buffer</code> 的升级。从这个版本开始，InnoDB 存储引擎可以对 <strong>insert、delete、update 都进行缓存。</strong><br>唯一速度的插入比普通索引慢的原因就是:<br><strong>唯一索引无法利用<code>Change Buffer</code><br>普通索引可以利用<code>Change Buffer</code></strong></p><h3 id="为什么唯一索引的更新不使用-Change-Buffer？"><a href="#为什么唯一索引的更新不使用-Change-Buffer？" class="headerlink" title="为什么唯一索引的更新不使用 Change Buffer？"></a>为什么唯一索引的更新不使用 Change Buffer？</h3><p>因为唯一索引为了保证唯一性，<font color="#FF0000"><strong>需要将数据页加载进内存才能判断是否违反唯一性约束</strong></font>。但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用<code>Change Buffer</code>。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸:"></a>延伸:</h3><p>主机异常重启，是否会丢失 change buffer 和数据?<br>不会丢失，虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p><hr><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p><code>ALTER TABLE table_name ADD UNIQUE (column1,column2); </code>–唯一索引组合<br><code>ALTER TABLE table_name ADD INDEX index_name(column1,column2, column3);</code>–普通索引组合<br>比如有一条语句：<code>select * from users where A=’beijing’ and B=22;</code><br>如果在A和B上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效<br>率，但是如果在A、B两列上创建复合索引的话将带来更高的效率。<br>如果我们创建了<code>(A, B,C)</code>的复合索引，那么其实相当于创建了<code>(A,B,C)、(A,B)、(A)</code>三个索引，这被称为<font color="#FF0000"><strong>最佳左前缀特性</strong></font>。单独的B和C没有索引,相当于电话本知名不知姓,没用,<code>where C AND A </code>会走 <code>(A)</code>索引,和where后面的条件无关<br>因此我们在创建复合索引时应该将<font color="#FF0000">最常用作限制条件的列放在最左边</font>，依次递减。(<strong>也可以是字符串索引的最左 M 个字符</strong>)</p><p>全文索引 FULLTEXT：也称全文检索，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引：</p><hr><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li><p>索引不会包含有<code>NULL</code>值的列<br>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<code>NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为<code>NULL</code>。</p></li><li><p><code>like</code>语句操作<br>一般情况下不鼓励使用like操作，<code>like “%aaa%”</code> 不会使用索引而<code>like “aaa%”</code>可以使用索引。<br><code>%linux%</code>类的搜索需求，可以使用elasticsearch+mongodb 专门做搜索服务的数据库产品</p></li><li><p>不使用<code>NOT IN</code>和操作<br><code>NOT IN</code>和操作都不会使用索引将进行全表扫描。</p></li><li><p>当只要一行数据时使用<code> limit 1</code><br>查询时如果已知会得到一条数据，这种情况下加上 <code>limit 1</code> 会增加性能。因为 mysql 数据库引擎会在找到一条结果停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕。</p></li><li><p>不建索引或少建索引</p></li></ol><ul><li>经常插入、删除、修改的表<br>对一些经常处理的业务表应在查询允许的情况下尽量减少索引,否则增删改原表的同时还要改索引表</li><li>数据重复且分布平均的表字段<br>例如性别,只有男女且分布均匀</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>数据量少的字段不需要<br>如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，要往返读取数据块两次。而不用索引会将所有的数据一次读出，处理速度显然会比用索引快。</li></ul><ol start="6"><li><p>索引列排序<br>查询只使用一个索引，因此如果<strong>where子句中已经使用了索引的话，那么order by中的列是不会使用索引的</strong>。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要<strong>最好给这些列创建复合索引</strong>。</p></li><li><p><strong>使用短索引</strong><br>对串列进行索引，如果可能应该指定一个前缀长度,比如长度255测char列,如果前几个字符基本就是唯一的话就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_name [col_name data <span class="built_in">type</span>]</span><br><span class="line">[unique|fulltext][index|key]   [index_name] (col_name[length]) [asc|desc]</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-有什么手段可以知道有没有走索引查询呢？"><a href="#1-有什么手段可以知道有没有走索引查询呢？" class="headerlink" title="1. 有什么手段可以知道有没有走索引查询呢？"></a>1. 有什么手段可以知道有没有走索引查询呢？</h2><p>可以通过<strong>explain</strong>查看sql语句的执行计划，通过执行计划来分析索引使用情况<br><code>SHOW STATUS LIKE &#39;Handler_read%&#39;;</code>查看索引的使用情况：</p><h2 id="2-什么情况下明明创建了索引，执行的时候并没有通过索引呢？"><a href="#2-什么情况下明明创建了索引，执行的时候并没有通过索引呢？" class="headerlink" title="2. 什么情况下明明创建了索引，执行的时候并没有通过索引呢？"></a>2. 什么情况下明明创建了索引，执行的时候并没有通过索引呢？</h2><ul><li><p>索引本身失效</p></li><li><p>对小表查询 </p></li><li><p>查询的数量是大表中的大部分数据。应该是25％-30%以上</p></li><li><p>对列使用函数，该列的索引将不起作用。如：substring(字段名,1,2)=’xxx’；</p></li><li><p>对列进行运算(+，-，*，/，! 等)，该列的索引将不起作用。</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> id-1=9;//错误的写法</span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> id=10; //正确的写法 </span><br></pre></td></tr></table></figure></code></pre></li><li><p>前面说的前导模糊查询的LIKE操作和反向条件，该列的索引将不起作用。<br> 如：!=、&lt;&gt;、not in、not exists、not like等(可能走 INDEX FAST FULL SCAN)</p></li><li><p>范围条件查询可以命中索引。范围条件有：<code>&lt;、&lt;=、&gt;、&gt;=、between</code>等。<br> 但是范围查询和等值查询同时存在，优先匹配等值查询列的索引：</p></li><li><p>在WHERE中使用OR时，有一个列没有索引，那么其它列的索引将不起作用,除非全是索引列</p></li><li><p>隐式转换导致索引失效。如索引建立<code>varchar()</code>类型</p><pre><code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> t_number=133; //错误的写法</span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> t_number=<span class="string">&#x27;133&#x27;</span>; //正确的写法 </span><br></pre></td></tr></table></figure></code></pre></li><li><p>当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。 </p></li><li><p><strong>查询优化器</strong>选择不走索引<br>一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过MySQL的查询优化器进行选择，选择执行成本最低的方案。<br>这个成本最低的方案就是所谓的执行计划。优化过程大致如下：<br> 1、根据搜索条件，找出所有可能使用的索引<br> 2、计算全表扫描的代价<br> 3、计算使用不同索引执行查询的代价<br> 4、对比各种执行方案的代价，找出成本最低的那一个</p></li></ul><p><strong>比如最常见的误区</strong>:如果where条件中是OR关系，加索引不起作用<br><code>SELECT * FROM TB WHERE A=1 AND B&gt;2 AND C&lt;3 AND D IN (4,5,6)</code><br>并且在TB表上有这样一个索引：<code>CREATE INDEX INX_TB_ABCD ON TB (A,B,C,D)</code><br>那么这个查询可以用到这个索引<br>如果同样是这个索引，查询换成<br><code>SELECT * FROM TB_ WHERE A=1 OR B&gt;2 OR C&lt;3 OR D IN (4,5,6)</code><br>那么这个查询就用不到上面那个索引，因为结果集是几个条件的并集，最多只能在查找<code>A=1</code>的数据时用索引，其它几个条件都需要表扫描，那优化器就会选择直接走一遍表扫描，所以索引就失效了。</p><p><strong>四个列上各建一个索引的话用OR还是会走索引的</strong></p><p>where 1=1影响性能会导致无法使用索引?放….</p><h2 id="“N叉树”的N值在MySQL中是可以被人工调整的么？"><a href="#“N叉树”的N值在MySQL中是可以被人工调整的么？" class="headerlink" title="“N叉树”的N值在MySQL中是可以被人工调整的么？"></a>“N叉树”的N值在MySQL中是可以被人工调整的么？</h2><p>可以按照调整key的大小的思路来说；<br>5.6以后可以通过page大小来间接控制</p><h2 id="没有主键的表，有一个普通索引。就不会回表了？"><a href="#没有主键的表，有一个普通索引。就不会回表了？" class="headerlink" title="没有主键的表，有一个普通索引。就不会回表了？"></a>没有主键的表，有一个普通索引。就不会回表了？</h2><p>没有主键的表，innodb会给默认创建一个Rowid做主键</p><hr><h1 id="为什么用B"><a href="#为什么用B" class="headerlink" title="为什么用B+"></a>为什么用B+</h1><p>每一张表其实就是多个B+树，<br>普通索引树的叶子结点，key值就是整个索引值，如果是联合索引，就是联合索引排序后的值。value就是主键索引值。<br>主树结点的key值就是某一行的主键，value是该行的其他数据。<br>新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。</p><p>先排除有序数组,插入O(n)内存连续,<br>有序数组索引只适用于静态存储引擎</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引:"></a>哈希索引:</h2><p> o(1)   B+tree log(n)  明显哈希快</p><ol><li><font color="#FF0000">模糊查找</font>:哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，结构是不支持，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</li><li><font color="#FF0000">范围查找</font>:例如查找ID为100 ~ 400的人，多个数据在存储关系上是完全没有任何顺序关系的哈希表同样不支持，只能遍历全表。<br>而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li><li><font color="#FF0000">哈希冲突</font>:大量重复键值严重的话，形成的索引结构将会是一条很长的链表，查找的时间就会大大增加。<br>哈希索引适合<font color="#FF0000">等值查询</font></li></ol><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树:"></a>红黑树:</h2><p><font color="#FF0000">内存</font>:AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将<font color="#FF0000">全部数据全部加载进内存</font>，因此如果采用红黑树，就会造成<strong>频繁IO，效率低下</strong>。<br>B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。<br>以 InnoDB 的一个整数字段索引为例,1200叉树,高度为4时存1200三次方–17亿数据, 10 亿行的表上一个整数字段的索引，查找值最多只需读 3 次磁盘(根的数据块总是在内存中的)。</p><p><font color="#FF0000">磁盘预读</font>:逻辑上很近的节点（父子）物理上可能很远，无法利用局部性,或者说磁盘预读中的很多数据是用不上的数据,B树是为了充分利用磁盘预读功能来而创建的一种数据结构</p><p><strong>局部性原理与磁盘预读：</strong><br>磁盘的存取速度往往是主存的几百分分之一，为了提高效率，要尽量减少磁盘I/O。<br>为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，<br>磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<br><em>当一个数据被用到时，其附近的数据也通常会马上被使用。</em><br>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h2><p>b的特点:</p><ul><li>树内存储数据</li><li>叶子节点上无链表<br><img src="/2019/07/27/mysql-1.%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/1.png" alt="1"><br>B+特点:</li><li>数据只出现在叶子节点</li><li>所有叶子节点增加了一个链指针<br><img src="/2019/07/27/mysql-1.%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/2.png" alt="1"><br>B Tree在提高了磁盘IO性能的同时并没有解决<strong>元素遍历的效率低下</strong>的问题。正是为了解决这个问题，B+ tree应运而生。<br>B+ tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，<br>如果使用B Tree，则<strong>需要做局部的中序遍历，可能要跨层访问，效率太慢。</strong></li></ul><p><strong>延伸</strong>:<br>MongoDB 差哪了为啥就用B树啊,MongoDB 的默认存储引擎 WiredTiger 为什么选择使用 B 树而不是 B+ 树？</p><p>1.MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。 对于遍历数据的需求没有关系型数据库那么强，它追求的是读写单个记录的性能<br>2.Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。</p><p>生产问题:<br>线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G,<br>而他的索引却有30G!!!!!!!<br>是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.<br>只能是重新建表才能重建索引. alter table T engine=InnoDB </p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-责任链</title>
      <link href="2019/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
      <url>2019/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h1><p>有点排队打电话的感觉,接到电话问是不是找我的,不是我就往后传,(做代办那会的)<br>一种对象行为型模式<br>为了避免请求发送者与多个请求处理者<strong>耦合</strong>在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；(有点链表的意思?)<br>当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，(得到head就得到整个链表?)<br>请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</p><p><strong>关键字:解耦!!</strong></p><p><strong>优点</strong>:<br>降低了对象之间的<strong>耦合度</strong>。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>增强了系统的可<strong>扩展性</strong>。可以根据需要增加新的请求处理类，满足开闭原则。<br>增强了给对象指派职责的<strong>灵活性</strong>。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。(链表的增删?)<br>责任链<strong>简化了对象之间的连接</strong>。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。(这个牛逼)<br><strong>责任分担</strong>。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p><p><strong>缺点</strong>:<br>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。**(断了就废?)**<br>对比较长的职责链，请求的处理可能涉及多个处理对象，<strong>系统性能将受到一定影响。</strong>(简化if else的工作其实符合人未必符合机器吧?)<br>职责链建立的合理性要靠客户端来保证，<strong>增加了客户端的复杂性</strong>，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p><hr><h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p><ol><li>模式的结构<br>职责链模式主要包含以下角色。<br>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。<br>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<br>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ol><p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；<br>理解责任链模式应当理解其模式，而不是其具体实现。<br>责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p><p>责任链结构图如</p><p><img src="/2019/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE/1.jpg" alt="1"></p><p>客户端可按下图设置责任链。</p><p><img src="/2019/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE/2.jpg" alt="1"></p><ol><li>模式的实现<br>职责链模式的实现代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package chainOfResponsibility;</span><br><span class="line">public class ChainOfResponsibilityPattern &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //组装责任链</span><br><span class="line">        Handler handler1 = new ConcreteHandler1();</span><br><span class="line">        Handler handler2 = new ConcreteHandler2();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        //提交请求</span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>处理者</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//抽象处理者角色.类似链表的抽象类</span><br><span class="line">abstract class Handler &#123;</span><br><span class="line">    private Handler next;</span><br><span class="line">    public void setNext(Handler next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    public Handler <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理请求的方法</span><br><span class="line">    public abstract void handleRequest(String request);</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者角色1</span><br><span class="line">class ConcreteHandler1 extends Handler &#123;</span><br><span class="line">    public void handleRequest(String request) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者角色2</span><br><span class="line">class ConcreteHandler2 extends Handler &#123;</span><br><span class="line">    public void handleRequest(String request) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：<br>具体处理者2负责处理该请求！</p><p>在上面代码中，我们把消息硬编码为 String 类型，而在真实业务中，消息是具备多样性的，可以是 int、String 或者自定义类型。<br>因此，在上面代码的基础上，可以对消息类型进行抽象 Request，增强了消息的兼容性。</p><hr><h1 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h1><p>【例1】用责任链模式设计一个请假条审批模块。<br>请假小于等于 2 天，班任可以批准；<br>小于或等于 7 天，系主任可以批准；<br>小于或等于 10 天，院长可以批准；<br>其他情况不予批准；这个实例适合使用职责链模式实现。</p><p>首先，定义一个领导类（Leader），它是抽象处理者，包含了一个指向下一位领导的指针 next 和一个处理假条的抽象处理方法 handleRequest(int LeaveDays)；<br>然后，定义班主任类（ClassAdviser）、系主任类（DepartmentHead）和院长类（Dean），<br>它们是抽象处理者的子类，是具体处理者，必须根据自己的权力去实现父类的 handleRequest(int LeaveDays) 方法，<br>如果无权处理就将假条交给下一位具体处理者，直到最后；<br>客户类负责创建处理链，并将假条交给链头的具体处理者</p><p>程序代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package chainOfResponsibility;</span><br><span class="line">public class LeaveApprovalTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //组装责任链</span><br><span class="line">        Leader teacher1 = new ClassAdviser();</span><br><span class="line">        Leader teacher2 = new DepartmentHead();</span><br><span class="line">        Leader teacher3 = new Dean();</span><br><span class="line">        //Leader teacher4=new DeanOfStudies();</span><br><span class="line">        teacher1.setNext(teacher2);</span><br><span class="line">        teacher2.setNext(teacher3);</span><br><span class="line">        //teacher3.setNext(teacher4);</span><br><span class="line">        //提交请求</span><br><span class="line">        teacher1.handleRequest(8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象处理者：领导类</span><br><span class="line">abstract class Leader &#123;</span><br><span class="line">    private Leader next;</span><br><span class="line">    public void setNext(Leader next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    public Leader <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理请求的方法</span><br><span class="line">    public abstract void handleRequest(int LeaveDays);</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者1：班主任类</span><br><span class="line">class ClassAdviser extends Leader &#123;</span><br><span class="line">    public void handleRequest(int LeaveDays) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeaveDays &lt;= 2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;班主任批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者2：系主任类</span><br><span class="line">class DepartmentHead extends Leader &#123;</span><br><span class="line">    public void handleRequest(int LeaveDays) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeaveDays &lt;= 7) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;系主任批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者3：院长类</span><br><span class="line">class Dean extends Leader &#123;</span><br><span class="line">    public void handleRequest(int LeaveDays) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeaveDays &lt;= 10) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;院长批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体处理者4：教务处长类</span><br><span class="line">class DeanOfStudies extends Leader &#123;</span><br><span class="line">    public void handleRequest(int LeaveDays) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeaveDays &lt;= 20) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;教务处长批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：<br>院长批准您请假8天。</p><p>假如增加一个教务处长类，可以批准学生请假 20 天，也非常简单，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//具体处理者4:教务处长类</span><br><span class="line">class DeanOfStudies extends Leader &#123;</span><br><span class="line">    public void handleRequest(int LeaveDays) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeaveDays &lt;= 20) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;教务处长批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != null) &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h1><p>前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用。<br>多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。<br>可动态指定一组对象处理请求，或添加新的处理者。<br>需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</p><h1 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h1><p>职责链模式存在以下两种情况。<br>纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。<br>不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot常用注解</title>
      <link href="2019/06/16/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>2019/06/16/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>@SpringBootApplication</strong>:包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。申明让Spring Boot自动给程序进行必要的配置<br>&nbsp;&nbsp;@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) ,加上exclude注解为排除某自动注入,此例中为取消数据库自动装配,就不会去application中读取配置,需要自己写个@Configuration注解<br><strong>@EnableAutoConfiguration</strong>:自动配置,尝试根据你添加的jar依赖自动配置你的Spring应用。<br>会自动去maven中读取每个starter中的spring.factories文件 该文件里配置了所有需要被创建spring容器中的bean<br><strong>@ComponentScan</strong>:组件扫描，可自动发现和装配一些Bean。默认当前目录下所有,所以一般启动类都是放在最外层<br><strong>@Configuration</strong>:等同于Spring的XML配置文件；使用Java代码可以检查类型安全。<br>Spring 中新的 Java 配置支持的核心就是@Configuration 注解的类。这些类主要包括 @Bean 注解的方法来为 Spring 的 IoC 容器管理的对象定义实例，配置和初始化逻辑。<br>使用@Configuration 来注解类表示类可以被 Spring 的 IoC 容器所使用，作为 bean 定义的资源。该注解本身不能注册成bean!(该类自己没加@Component之类的注解,那他就不是bean)<br><strong>@Component 和 @Configuration对比:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public static class Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBean <span class="function"><span class="title">simpleBean</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBean();&#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBeanConsumer <span class="function"><span class="title">simpleBeanConsumer</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBeanConsumer(simpleBean());&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">public static class Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBean <span class="function"><span class="title">simpleBean</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBean();&#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBeanConsumer <span class="function"><span class="title">simpleBeanConsumer</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBeanConsumer(simpleBean());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个正常，SimpleBeanConsumer会得到一个单例SimpleBean的链接。<br>第二个配置是错误的，Spring会创建一个SimpleBean的单例bean，但是SimpleBeanConsumer将获得另一个SimpleBean实例<br>（也就是相当于直接调用new SimpleBean() ，这个bean是不归Spring管理的），既new  SimpleBean() 实例是Spring上下文控件之外的。<br>原因:使用@ configuration，所有标记为@ bean的方法将被包装成一个CGLIB包装器，它的工作方式就好像是这个方法的第一个调用，那么原始方法的主体将被执行，<br>最终的对象将在spring上下文中注册。所有进一步的调用只返回从上下文检索的bean。<br>在上面的第二个代码块中，新的SimpleBeanConsumer(simpleBean())只调用一个纯java方法。可以改成如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public static class Config &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    SimpleBean simpleBean;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBean <span class="function"><span class="title">simpleBean</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBean();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBeanConsumer <span class="function"><span class="title">simpleBeanConsumer</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SimpleBeanConsumer(simpleBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ConfigurationProperties</strong>:boot的注解,有个参数prefix 为前缀,作用于类上时相当于@Configuration +@Value注解并且配置文件为application,<br>路径为前缀,该类下面的属性对应配置文件下面的同名参数(也支持宽松匹配,比如配置文件中的-转为驼峰)<br>作用于方法上是,需要方法被@bean注释,且类被@Configuration注释<br>@Import:用来导入其他配置类。<br>@ImportResource:用来加载xml配置文件。<br>@Bean:用@Bean标注方法等价于XML中配置的bean。默认方法名<br>@Value:注入Spring boot application.properties配置的属性的值<br>@Inject:@Autowired，只是没有required属性；<br><strong>@Qualifier</strong>:@Autowired默认按照类型注入,但是如果有两个bean实现了同一个bean,且起了自己的名字,需要用这个注解区分,或者直接用java自带的resource注解也行,<br>自带的注解默认的是按照名称区分的<br><strong>@Primary</strong>:情景同上,但是不需要要有自己的bean的名字,其中一个实现添加了@Primary注解,就是告诉spring当不知道注入那个具体实现的时候就选我<br><strong>@PathVariable 和@RequestParam</strong>:获取参数。<br>@PathVariable主要用于接收<a href="http://host:port/path/{参数值}数据。@RequestParam主要用于接收http://host:port/path?参数名=参数值数据，这里后面也可以不跟参数值。">http://host:port/path/{参数值}数据。@RequestParam主要用于接收http://host:port/path?参数名=参数值数据，这里后面也可以不跟参数值。</a><br>@RequestParam和@PathVariable这两者之间区别不大，主要是请求的URL不一样<br>用@RequestParam请求接口时,URL是:<a href="http://www.test.com/user/getUserById?userId=1">http://www.test.com/user/getUserById?userId=1</a><br>用@PathVariable请求接口时,URL是:<a href="http://www.test.com/user/getUserById/2">http://www.test.com/user/getUserById/2</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(<span class="string">&quot;/privilege/function/query/&#123;menuKey&#125;&quot;</span>)</span><br><span class="line">public ResponseDTO&lt;List&lt;PrivilegeFunctionVO&gt;&gt; functionQuery(@PathVariable String menuKey) &#123;</span><br><span class="line">    <span class="built_in">return</span> privilegeService.functionQuery(menuKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ControllerAdvice + @ExceptionHandler:全局异常处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class MyGlobalExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public ModelAndView customException(Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e instanceof HttpRequestMethodNotSupportedException) &#123;</span><br><span class="line">            <span class="built_in">return</span> new HttpRequestMethodNotSupportedException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ControllerAdvice + @MatrixVariable</strong>: 全局数据绑定<br><strong>@ControllerAdvice + @InitBinder</strong>: 全局数据预处理<br>@ResponseBody:<br>@RestController  = ResponseBody + Controller<br>@MapperScan:作用：指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类,简化了原来每个dao上都要添加mapper注解<br>添加位置：是在Springboot启动类上面添加，或者mybatisplus的配置类<br>@Lazy:用于标识bean是否需要延迟加载,加上@Lazy注解则必须在第一次调用的时候才会加载注解的作用主要是减少springIOC容器启动的加载时间,<br><strong>@DependsOn</strong>:spring容器载入bean顺序是不确定的，如果A依赖B(如beanA中有@Autowired B的变量)，那么B将先于A被加载。但如果beanA不直接依赖B，可以<br>@DependsOn(“B”)控制bean的初始化顺序,通常可以和@Lazy互换,比如可以换成在B初始化时加上@Lazy注解,这样B就会在第一次调用时才初始化.<br><strong>@Async</strong>:就是异步,开启新的线程执行<br>@Scheduled:定时任务注解<br>@Transactional<br><strong>@SessionAttribute</strong>:多个方法共享参数<br>@CrossOrigin:解决跨域问题<br>@CookieValue:主要是将请求的Cookie数据，映射到功能处理方法的参数上。<br><strong>@Scope</strong>:作用域注解,默认singleton单例模式,还有prototype原型模式,每次获取Bean的时候会有一个新的实例,request:每一次HTTP请求都会产生一个新的bean同时该bean仅在当前HTTP request内有效,session每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效<br>1、不要在controller中定义成员变量。<br>2、万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式。<br>3、在Controller中使用ThreadLocal变量<br><strong>@PostConstruct</strong>:java注解,构造方法在Auowired注入之前,但是现在要实现创建完对象后立马就用注入的bean,如果构造方法中直接调用肯定是空的,所有再写一个方法,这个方法添加这个注解之后,会在执行完构造函数后立刻执行,可以在这个函数里面写上注入的bean操作,构造函数–&gt;Autowried注入–&gt;@PostConstruct,从而实现在构造函数中初始化注入bean类似的效果,同样还有@PreDestroy注解</p><p><img src="/2019/06/16/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/1.jpg" alt="3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//A类内部</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法,此时B为空= &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    private void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在构造和@Autowired注入B之后自动执行的,此时B已经注入可以实现类似构造中初始化的操作: b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理</title>
      <link href="2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/"/>
      <url>2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>什么是代理模式？<br>代理模式有什么用？<br>spring如何用代理模式实现AOP？</p><hr><p><strong>代理模式: 为其他对象提供一种代理，并以控制对这个对象的访问</strong><br>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。<br>还可以通过给<strong>代理类增加额外的功能来扩展委托类的功能</strong>，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的<strong>开闭原则</strong>。<br>代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。<br>代理模式中的角色：<br>抽象主题角色（Subject）：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。<br>具体主题角色（RealSubject)：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。<br>代理主题角色（Proxy)：也叫委托类、代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。<br> 代理模式又分为<strong>静态代理</strong>和<strong>动态代理</strong>。静态代理是由程序猿创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。动态代理是在程序运行时，通过运用反射机制动态的创建而成。</p><hr><h1 id="JAVA中代理分类"><a href="#JAVA中代理分类" class="headerlink" title="JAVA中代理分类"></a>JAVA中代理分类</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理:"></a>静态代理:</h2><p>客户只需要创建代理角色,代理角色会对真实角色进行创建并操作,且可以按需求添加新的功能do somthing<br><strong>缺点</strong>:1.要写大量代理类2.需要实现同一个接口3.接口新增一个方法,代理和真实角色都要改代码,耦合度太高</p><ol><li>supobject<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SupObject</span><br><span class="line"> &#123;</span><br><span class="line"> void operate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>RealSubject<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RealObject implements SupObject</span><br><span class="line"> &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void operate()</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;operating.....&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>Proxy<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyObject implements Subject  //与真实角色实现同一接口</span><br><span class="line">&#123;</span><br><span class="line">    private SupObject supObject = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operate()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(supObject == null) supObject = new RealObject();</span><br><span class="line">        System.out.print(<span class="string">&quot;do somthing before operate &quot;</span>);</span><br><span class="line">        this.supObject .operate();</span><br><span class="line">        System.out.print(<span class="string">&quot;do somthing after operate &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>test<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SupObject supObject = new Proxy();</span><br><span class="line">supObject .operate();</span><br></pre></td></tr></table></figure></li></ol><h2 id="JDK动代"><a href="#JDK动代" class="headerlink" title="JDK动代:"></a>JDK动代:</h2><p>也叫接口代理<br>和静代比:.代理对象proxy<strong>不需要实现接口</strong>,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>但是<font color="#FF0000">目标对象仍需要实现接口</font><br>利用反射,一个方法三个参数:<code>java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code><br>分别是类加载器,接口类型,和事件处理,执行目标对象的方法时,会触发事件处理器的方法</p><p>SupObject 和RealSubject类同上:增加ProxyFactory方便所有满足条件的代理使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyFactory&#123;</span><br><span class="line">    //维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //给目标对象生成代理对象</span><br><span class="line">    public Object <span class="function"><span class="title">getProxyInstance</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), //获取目标对象(真实对象)类加载器</span><br><span class="line">                target.getClass().getInterfaces(), //获取目标对象接口类型</span><br><span class="line">                new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do some new thing before real mathod&quot;</span>);</span><br><span class="line">                        //执行目标对象方法</span><br><span class="line">                        Object returnObject = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;do some new thing after real mathod&quot;</span>);</span><br><span class="line">                        <span class="built_in">return</span> returnObject ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>以上两种代理都要目标对象实现一个接口,不认干爹不配拥有代理?可以认干儿子~子类代理!<br>Cglib通过字节码技术为一个类创建子类<br>要求:<br>引入cglib的jar文件(spring项目自带,因为AOP中用到了)<br>目标类不能是final,且要代理的方法也不能是final和static…废话</p><p>真实对象RealObject同上(不需要实现sup接口):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Cglib子类代理工厂</span><br><span class="line"> * 对UserDao在内存中动态构建一个子类对象</span><br><span class="line"> */</span><br><span class="line">public class ProxyFactory implements MethodInterceptor&#123;</span><br><span class="line">    //维护目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //给目标对象创建一个代理对象</span><br><span class="line">    public Object <span class="function"><span class="title">getProxyInstance</span></span>()&#123;</span><br><span class="line">        //1.工具类</span><br><span class="line">        Enhancer en = new Enhancer();</span><br><span class="line">        //2.设置父类</span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        //3.设置回调函数</span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        //4.创建子类(代理对象)</span><br><span class="line">        <span class="built_in">return</span> en.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务...&quot;</span>);</span><br><span class="line">        //执行目标对象的方法</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="spring-Aop动代源码"><a href="#spring-Aop动代源码" class="headerlink" title="spring Aop动代源码:"></a>spring Aop动代源码:</h1><p>目标对象有接口就jdk,没有就cglib?为什么?<br>cglib创建的代理调用性能更高,虽然创建的过程比jdk慢,但是单例bean不应该都是用cglib吗?</p><p>创建代理对象过程中，会先创建一个代理工厂，获取到所有的增强器（通知方法），将这些增强器和目标类注入代理工厂，再用代理工厂创建对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line">        <span class="keyword">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)this.beanFactory, beanName, beanClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">        proxyFactory.copyFrom(this);</span><br><span class="line">        <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (this.shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">                proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                this.evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Advisor[] advisors = this.buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line">        proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        this.customizeProxyFactory(proxyFactory);</span><br><span class="line">        proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">        <span class="keyword">if</span> (this.advisorsPreFiltered()) &#123;</span><br><span class="line">            proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> proxyFactory.getProxy(this.getProxyClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代理工厂会选择JdkDynamicAopProxy或者CglibAopProxy，主要通过是否接口和是否配置cglib代理来选择。最终工厂会创建一个代理增强的对象。我们继续完善之前的流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        <span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例</title>
      <link href="2019/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
      <url>2019/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><p>什么是单例?<br>单例有什么用?<br>spring中为什么默认单例?</p><hr><p>单例就是只有一个实例<br>比如网站访问人数,计数器,回收站这种,不管从哪调用一个就够了,多了反而业务问题<br>为了提高性能,每次spring通过反射创建对象都是需要消耗性能,并且创建多了增加垃圾回收的负担,同时如果创建了单例对象之后先存在缓存中,后续直接拿更快了,最重要的是一般情况下也没要多列</p><h1 id="单例的实现方式"><a href="#单例的实现方式" class="headerlink" title="单例的实现方式:"></a>单例的实现方式:</h1><ol><li>饿汉式:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 线程安全</span><br><span class="line"> * 可能在还不需要此实例的时候就已经把实例创建出来了，没起到lazy loading的效果</span><br><span class="line"> */</span><br><span class="line">public static class Singleton &#123;</span><br><span class="line">    private final static Singleton INSTANCE = new Singleton();</span><br><span class="line"> </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>懒汉式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程不安全</span><br><span class="line"> */</span><br><span class="line">public static class Singleton2 &#123;</span><br><span class="line">    private static Singleton2 instance = null;</span><br><span class="line">    private <span class="function"><span class="title">Singleton2</span></span>() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton2 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == null) &#123;</span><br><span class="line">            instance = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 又安全,效率也高,不知道差哪了,待验证</span><br><span class="line"> */</span><br><span class="line">public static class Singleton4 &#123;</span><br><span class="line">    private static Singleton4 instance = null;</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">    private <span class="function"><span class="title">Singleton4</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton4 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态内部类<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 【推荐】感觉和上面的静态代码块没啥区别</span><br><span class="line"> */</span><br><span class="line">public static class Singleton5 &#123;</span><br><span class="line">    private final static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton5 INSTANCE = new Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private <span class="function"><span class="title">Singleton5</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton5 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>枚举类<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用枚举方式，线程安全【推荐】</span><br><span class="line"> * effective java最佳的单例实现模式就是枚举模式,</span><br><span class="line"> * 利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题</span><br><span class="line"> * Singleton6.INSTANCE.whateverMethod()调用</span><br><span class="line"> */</span><br><span class="line">public enum Singleton6 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"> </span><br><span class="line">    public void <span class="function"><span class="title">whateverMethod</span></span>() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>双重锁<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用双重校验锁，线程安全【推荐】</span><br><span class="line"> * volatile 防止指令重排</span><br><span class="line"> */</span><br><span class="line">public static class Singleton7 &#123;</span><br><span class="line">    private volatile static Singleton7 instance = null;</span><br><span class="line"> </span><br><span class="line">    private <span class="function"><span class="title">Singleton7</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton7 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton7.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton7();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h1>spring中bean初始化时使用的<strong>单例注册表</strong><br>简单定义一个map通过bean的name作为key,<br>先判断是不是单例作用域scope,<br>如果是就从map里取值,没有的话再看是不是单例再检测注册表然后再实例化</li></ol>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC执行流程</title>
      <link href="2019/05/04/springMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>2019/05/04/springMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论:"></a>先说结论:</h1><ol><li>一个请求匹配前端控制器<font color="#ff0000">DispatcherServlet </font>  的请求映射路径(在 web.xml中指定), WEB<br>容器将该请求转交给 DispatcherServlet 处理</li><li>DispatcherServlet 接收到请求后, 将根据 <font color="#ff0000">请求信息</font> 交给 处理器映射器 （<font color="#ff0000">HandlerMapping</font>）</li><li><font color="#ff0000">HandlerMapping</font> 根据用户的url请求 查找匹配该url的 <font color="#ff0000">Handler</font>，并返回一个执行链</li><li>DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 <font color="#ff0000"> ModelAndView</font> 给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 请求 <font color="#ff0000">ViewReslover</font>（视图解析器）解析，返回具体 View</li><li>DispatcherServlet 对 View 进行<font color="#ff0000">渲染视图</font>（即将<font color="#ff0000">模型数据</font>填充至视图中）</li><li>DispatcherServlet 将页面响应给用户</li></ol><p><img src="/2019/05/04/springMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1.png" alt="1"></p><h1 id="组件说明："><a href="#组件说明：" class="headerlink" title="组件说明："></a>组件说明：</h1><p><font color="#ff0000">DispatcherServlet：前端控制器</font><br>    用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，<br>    由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p><p><font color="#ff0000">HandlerMapping：处理器映射器</font><br>　　　HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，<br>　　   例如：配置文件方式，实现接口方式，注解方式等。</p><p><font color="#ff0000">Handler：处理器</font><br>　　 Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>        由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p><p><font color="#ff0000">HandlAdapter：处理器适配器</font><br>　　通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p><font color="#ff0000">ViewResolver：视图解析器</font><br>　　View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，<br>　　再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p><p><font color="#ff0000">View：视图 </font><br>　　springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>　　一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>]]></content>
      
      
      <categories>
          
          <category> 正经事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
