<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发笔记-同步控制 | 愿你眉目舒展</title><meta name="keywords" content="Java"><meta name="author" content="凌"><meta name="copyright" content="凌"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="同步控制synchronized关键字就是一种最简单的控制方法。它决定了一个线程是否可以访问临界区资源。同时，Object.wait()和Object.notify() 方法起到了线程等待和通知的作用。这些工具对于实现复杂的多线程协作起到了重要的作用。 重入锁ReentrantLock——–扩展的synchronized用来:递归调用调用同一对象其它synchronized或者有同步锁函数重入锁可">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发笔记-同步控制">
<meta property="og:url" content="http://example.com/2020/01/30/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="愿你眉目舒展">
<meta property="og:description" content="同步控制synchronized关键字就是一种最简单的控制方法。它决定了一个线程是否可以访问临界区资源。同时，Object.wait()和Object.notify() 方法起到了线程等待和通知的作用。这些工具对于实现复杂的多线程协作起到了重要的作用。 重入锁ReentrantLock——–扩展的synchronized用来:递归调用调用同一对象其它synchronized或者有同步锁函数重入锁可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://up.enterdesk.com/edpic_source/78/3f/d7/783fd7b40445e241d4a69e36ec65a764.jpg">
<meta property="article:published_time" content="2020-01-30T08:17:14.000Z">
<meta property="article:modified_time" content="2021-03-14T01:59:14.932Z">
<meta property="article:author" content="凌">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://up.enterdesk.com/edpic_source/78/3f/d7/783fd7b40445e241d4a69e36ec65a764.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2020/01/30/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/%E5%87%8C" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-14 09:59:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/page.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://up.enterdesk.com/edpic_source/78/3f/d7/783fd7b40445e241d4a69e36ec65a764.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">愿你眉目舒展</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java并发笔记-同步控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-01-30T08:17:14.000Z" title="undefined 2020-01-30 16:17:14">2020-01-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%AD%A3%E7%BB%8F%E4%BA%8B/">正经事</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h1><p>synchronized关键字就是一种最简单的控制方法。<br>它决定了一个线程是否可以访问临界区资源。<br>同时，<code>Object.wait()</code>和<code>Object.notify()</code> 方法起到了线程等待和通知的作用。这些工具对于实现复杂的多线程协作起到了重要的作用。</p>
<h1 id="重入锁ReentrantLock——–"><a href="#重入锁ReentrantLock——–" class="headerlink" title="重入锁ReentrantLock——–"></a>重入锁ReentrantLock——–</h1><p><strong>扩展的synchronized</strong><br>用来:<br>递归调用<br>调用同一对象其它synchronized或者有同步锁函数<br>重入锁可以完全替代synchronized关键字(他也是可重入锁)。在JDK5的早期版本中，重入锁的性能远远好于synchronized,但从JDK6.0开始，<br>JDK在synchronized上做了大量的优化，使得两者的性 能差距并不大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ReenterLock implements Runnable&#123;</span><br><span class="line">     public static ReentrantLock lock = new ReentrantLock(); </span><br><span class="line">     public static int i=0;</span><br><span class="line">     ©Override</span><br><span class="line">     public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">         <span class="keyword">for</span>(int j=0;j&lt;10000000;j++)&#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             try&#123;</span><br><span class="line">                i++；</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">          ReenterLock tl=new ReenterLock();</span><br><span class="line">          Thread tl=new Thread(tl);</span><br><span class="line">          Thread t2=new Thread(tl);</span><br><span class="line">          tl.start();t2.start();</span><br><span class="line">          tl. join() ;t2. join ();</span><br><span class="line">          System.out.printin(i);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码第7  —  1 2 行，使用重入锁保护临界区资源i , 确保多线程对i 操作的安全性。从这 段代码可以看到，与<code>synchronized</code>相比，重入锁要显示指定加锁释放锁<br>为什么叫可重入: 一个线程可以多次进入获得同一个锁</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock (); </span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    i++；</span><br><span class="line">&#125;finally!</span><br><span class="line">    lock.unlock(); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不可重入第二次加锁就会成死锁,但是可重入锁就是牛逼<br><strong>注意:多次获得锁，也要释放相同次数。</strong><br>如果释放锁的次数多—IllegalMonitorStateException异常，<br>放锁的次数少，资源被这个线程锁死了。<br><strong>重入锁还有中断响应功能</strong>–<code>lockInterruptibly</code></p>
<p>对于synchronized来说，要么执行要么等到死—-die  or live is not your choice<br>重入锁:在等待锁的过程中，线程自己选择是否继续等锁还是中断—-我命由我不由天,大不了自杀</p>
<p>如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待避免死锁<br>下面的代码产生了一个死锁，但得益于锁中断，我们可以很轻易地解决这个死锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class IntLock implements Runnable &#123;</span><br><span class="line">    public  static  ReentrantLock  lockl  =  new  ReentrantLock(); </span><br><span class="line">    public  static  ReentrantLock  lock2  =  new  ReentrantLock(); </span><br><span class="line">    int lock;</span><br><span class="line">    //控制加锁顺序，方便构造死锁</span><br><span class="line">    public IntLock(int lock) &#123;</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock == 1)   &#123;</span><br><span class="line">               lockl.lockinterruptibly();   //tl先占用lockl,再占用lock2；</span><br><span class="line">               try&#123;</span><br><span class="line">                   Thread.sleep(500);   //防止一下占了两个锁</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockinterruptibly();   //t2先占用lock2,</span><br><span class="line">                try&#123;</span><br><span class="line">                   Thread.sleep(500);</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">                lockl.lockinterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace ();</span><br><span class="line">       .&#125; finally &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockl.isHeldByCurrentThread())</span><br><span class="line">               lockl.unlock();</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">               lock2.unlock();</span><br><span class="line">            System, out. printIn (Thread.currentThread ().getld() +<span class="string">&quot;线程退出&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException   &#123; </span><br><span class="line">        IntLock rl = new IntLock(1);</span><br><span class="line">        IntLock r2 = new IntLock(2)</span><br><span class="line">        Thread tl = new Thread(rl);</span><br><span class="line">        Thread t2 = new Thread(r2);</span><br><span class="line">        tl.start ();t2.start();</span><br><span class="line">        Thread.sleep(1000);  //主线程休眠时间两个线程处于死锁</span><br><span class="line">        t2.interrupt();   //中断其中一个线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lockInterruptibly:   可以对中断进行响应的锁申请,在等待锁的过程中，可以响应中断。</li>
</ul>
<p>主线程main处于休眠时，两个线程处于死锁的状态，<br>由于t 2 线程被中断，故t 2 会放弃对lock1 的申请，同时释放己获得lock2<br> 这个操作导致 tl线程可以顺利得到lock2而继续执行下去。</p>
<p>可以看到，中断后，两个线程双双退出。但真正完成工作的只有tl。而t2线程则放弃其任<br>务直接退出，释放资源。</p>
<p> – <strong>锁申请等待限时</strong>—<code>tryLock()</code>  or  <code>tryLock(int, Time)</code></p>
<p>给定一个等待时间，让线程自动放弃，<br>使用<code>tryLock()</code>方法进行一次限时的等待。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TimeLock implements Runnable&#123;</span><br><span class="line">     public static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">	 ©Override</span><br><span class="line">     public void <span class="function"><span class="title">run</span></span> () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           <span class="keyword">if</span>(lock.tryLock(5, TimeUnit.SECONDS))&#123;  //最多请求5秒的锁</span><br><span class="line">              Thread.sleep (6000);  //睡眠6秒</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              System.out.printin (<span class="string">&quot;nget lock failed&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.<span class="function"><span class="title">isHeldByCurrentThread</span></span>()&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       TimeLock tl=new TimeLock();</span><br><span class="line">       Thread tl=new Thread(tl);</span><br><span class="line">       Thread t2=new Thread(tl);</span><br><span class="line">       tl.start();</span><br><span class="line">       t2.start ();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>tryLock()</code>方法接收两个参数，一个表示等待时长，另外一个表示计时单位。<br>最多等待5秒。如果超过5秒还没有 得到锁，就会返回<code>felse</code>。如果成功获得锁，则返回<code>true</code>。<br>占用锁的线程会持有锁长达6 秒，故另一个线程无法在5 秒的等待时间内 获得锁，因此，请求锁会失败。<br><code>ReentrantLock.tryLock()</code>方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获<br>得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回<code>t r u e</code><br>如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回<code>f a l s e o</code><br>这种模式不会引起线程等待，因此也不会产生死锁。—终归会执行完</p>
<p>– 公平锁 —–new ReentrantLock(true)</p>
<p>一般情况下锁都是非公平的,<br>1请求锁A,2也请求锁A ……给谁?<br>不一定的.系统随便挑个人就给了。因此不能保证其公平性。<br>公平锁，会按照时间的先后顺序，保证先到者先到得后到者后得。不会产生饥饿现象。<br><code>synchronized</code>关键字进行锁控制，那么产生的锁就是非公平的。<br>而重 入锁允许我们对其公平性进行设置。它有一个如下的构造函数：<br><code>public ReentrantLock(boolean fair)</code><br>当参数<code>fair</code>为<code>true</code>时，表示锁是公平的。<br><strong>实现成本比较高，性能相对也非常低下</strong>，因此，默认情况下，锁是非公平的。<br>公平锁和非公平锁在线 程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock implements Runnable &#123;</span><br><span class="line">    //参数设置为<span class="literal">true</span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">	public static ReentrantLock fairLock = new ReentrantLock(<span class="literal">true</span>);</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           try&#123;</span><br><span class="line">               fairLock.lock();</span><br><span class="line">               Syso(Thread.currentThread().getName()+ <span class="string">&quot;获得锁〃)；</span></span><br><span class="line"><span class="string">            &#125;finally&#123;</span></span><br><span class="line"><span class="string">               fairLock.unlock();</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public static void main(String[] args) throws 工nterruptedException &#123;</span></span><br><span class="line"><span class="string">        FairLock rl = new FairLock();</span></span><br><span class="line"><span class="string">        Thread tl=new Thread(rl,&quot;</span>Thread一tl<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        Thread t2=new Thread (rl,&quot;</span>Thread一t2<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        tl.start&#123;);t2.start(&#125;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>构造函数设置为true<br>两个线程tl和t2分别请求这把锁，并且在得到锁后，进行一个控制台的输出，表示自己得到了锁。在公平锁的情况下，得到输出通常如下 所示：</p>
<p>几乎不会发生同一个线程连续多次获得锁的可能，从而公平 性也得到了保证。</p>
<p><strong>重入锁总结</strong><br>•    <code>lock()</code>：获得锁，如果锁己经被占用，则等待。—往死了尽力,不死不休<br>•    <code>locklnterruptibly()</code>:获得锁，优先响应中断(interrupt调用时先处理InterruptedException异常)–尽力但是能拽回来<br>•    <code>tryLock()</code>：获得锁，返回true，没得到返回false。—假装尽力了,不配叫try<br>•    <code>tryLock(long time, TimeUnit unit)</code>：在给定时间内尝试获得锁。—真尽力了,适可而止<br>•    <code>unlock()</code>：释放锁。<br>•    <code>new ReentrantLock(true)</code>: —公平,TMD还是公平</p>
<p>**重入锁实现的三个要素： **<br>一: 是原子状态。原子状态使用CAS操作来存储当前锁的状态,判断锁是否被别的线程占有<br>二: 是等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放<br>锁后，系统就能从等待队列中唤醒一个线程，继续工作。<br>三: 阻塞原语<code>park()</code>和<code>unpark()</code>:来挂起和恢复线程。没得到锁的线程将被挂起(参见LockSupport)</p>
<hr>
<h1 id="重入锁的Condition条件—–"><a href="#重入锁的Condition条件—–" class="headerlink" title="重入锁的Condition条件—–"></a>重入锁的Condition条件—–</h1><p><strong>await( )和single()等</strong><br>理解了 <code>Object.wait()</code>和<code>0bject.notify()</code>方法的话，就能很容易地理解Condition 对象了。<br>它和<code>wait()</code> 和<code>notify( )</code> 方法的作用是大致相同的。但是<code>wait()</code> 和<code>notify() </code>方法是和 <code>synchronized</code>关键字合作使用的<br>而<code>Condition</code>是<strong>与重入锁相关联的</strong>。通过LOCK 接口(重入锁就 实现了这一接口)的<br><code>Condition.newCondition()</code>方法可以<strong>生成一个与当前重入锁绑定的Condition 实例</strong>。<br>利用<code>Condition</code>对象，可以<strong>让线程在合适的时间等待，或者在某一个特定的时刻得 到通知，继续执行</strong>。<br>Condition接口提供的基本方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException; </span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws ZCnterruptedException; </span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException; </span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException; </span><br><span class="line">void signal(); </span><br><span class="line">void signalAll ();</span><br></pre></td></tr></table></figure>
<p><strong>以上方法的含义如下：</strong><br>•  await() 方法—–会使当前线程等待，同时释放当前锁，<strong>当其他线程中使用<code>signal()</code> 或者 <code>signalAll( )</code> 方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等 待。这和<code>0bject.wait()</code>方法很相似。</strong><br>•   awaitUninterruptibly()方法—-与await()方法基本相同，<strong>但是它并不会在等待过程中响应中 断。</strong><br>•   signal() 方法——-用于唤醒一个在等待中的线程。<br>•   signalAll(): 方法会唤醒所有在等待中 的线程。这和<code>0bejct.notify()</code>方法很类似。<br>下面的代码简单地演示了 <code>Condition</code>的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ReenterLockCondition implements Runnable</span><br><span class="line">   public static ReentrantLock lock  = new ReentrantLock(); </span><br><span class="line">   public static Condition condition = lock.newCondition(); //绑定</span><br><span class="line">   @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          lock.lock(); //</span><br><span class="line">          condition.await();   //等待唤醒操作</span><br><span class="line">          System.out.printin(<span class="string">&quot;Thread is going on&quot;</span>); </span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">       &#125;finally&#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public  static  void  main(String[]  args)  throws  InterruptedException  &#123; </span><br><span class="line">       ReenterLockCondition tl=new ReenterLockCondition();</span><br><span class="line">       Thread tl=new Thread(tl);</span><br><span class="line">       tl.start ();</span><br><span class="line">       Thread.sleep(2000);   // 睡眠是让t1先执行,但是他有await,main等会还能拿到锁</span><br><span class="line">       lock.lock();  //ti被await了,现在我可以拿这个锁</span><br><span class="line">       condition.signal(); //唤醒了t1但是他还是不会执行,因为main拿到了锁</span><br><span class="line">       //我释放了锁,t1才能拿到,我不释放,虽然唤醒但他拿不到锁永远不会输出</span><br><span class="line">       lock.unlock(); </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过lock生成一个与之绑定的Condition对象。要求线程在Condition 对象上进行等待。由主线程main发出通知，告知等待在Condition上的线程可以 继续执行了。<br>和<code>Object.wait()</code>和<code>notify()</code>方法一样，<strong>当线程使用<code>Condition.await()</code>时，线程持有相关的 重入锁，在<code>Condition.await()</code>调用后，会释放这把锁。</strong><br><strong>同理，在<code>Condition.signal()</code>方法调用时，线程先获得相关的锁。</strong><br>在<code>signal()</code> 方法调用后，系统会从当前<code>Condition</code>对象的 <strong>等待队列</strong>中，唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成 功获取，就可以继续执行了。<br>在<code>signal()</code> 方法调用之后，一般需要<strong>释放相关的锁，谦让给 被唤醒的线程，让它可以继续执行</strong></p>
<p>JDK中重入锁和Condition对象被广泛地使用：<br><strong>ReentrantLock +Condition 实现ArrayBlockingQueue的put()方法实现如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//在 ArrayBlockingQueue 中的一些定义</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">private final Condition notFull;</span><br><span class="line">lock = new ReentrantLock(fair);</span><br><span class="line">//生成一个与 lock 绑定的Condition</span><br><span class="line">notEmpty = lock. newCondition《)； </span><br><span class="line">notFull = lock.newCondition();</span><br><span class="line">//put () 方法的实现</span><br><span class="line">public void put(E e) throws InterruptedException</span><br><span class="line">    <span class="keyword">if</span> (e = null) throw new NullPointerException ;</span><br><span class="line">    final E[] items = this.items </span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.locklnterruptibly(); //对put方法做同步</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) //如果当前队列己满</span><br><span class="line">                notFull.await(); //等待队列有足够的空间</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">            notFull.signal(); </span><br><span class="line">            throw ie; </span><br><span class="line">        &#125; </span><br><span class="line">    insert(e);  //当notFull被通知时，说明有足够空间</span><br><span class="line">    </span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void insert(E x) &#123; </span><br><span class="line">    items[putlndex] = x; </span><br><span class="line">    putlndex = inc(putlndex); </span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal ();  //通知需要take()的线程，队列己有数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同理，对应take ()方法实现如下:</span><br><span class="line">public E take() throws InterruptedException &#123; </span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.locklnterruptibly () ;   //对take ()方法做同步                     </span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span> (count = 0) //如果队列为空</span><br><span class="line">            notEmpty.await () ; //则消费者队列要等待一个非空的信号          </span><br><span class="line">        &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">            notEmpty.signal();</span><br><span class="line">            throw ie; </span><br><span class="line">       &#125;</span><br><span class="line">       E x = extract(); </span><br><span class="line">       <span class="built_in">return</span> x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private E <span class="function"><span class="title">extract</span></span>() &#123;</span><br><span class="line">    final E[] items = this.items; </span><br><span class="line">    E x = items[takeindex]; </span><br><span class="line">    items[takeindex] = null; </span><br><span class="line">    takeindex = inc(takeindex); </span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal () ;  //通知put ()线程队列己有空闲空间</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="多个线程同时访问：信号量-Semaphore"><a href="#多个线程同时访问：信号量-Semaphore" class="headerlink" title="多个线程同时访问：信号量(Semaphore)"></a>多个线程同时访问：信号量(Semaphore)</h1><p>是对锁的扩展。<br>无论 是内部锁<code>synchronized</code> 还是重入锁<code>reentrantLock</code> , 一次都只允许一个线程访问一个资源，而<strong>信号量却可以指定多个线程，同时访问某一个资源</strong>。<br>信号量主要提供了以下构造函数：<br><code>public Semaphore(int n)  //允许 n个准入数</code><br><code>public Semaphore (int n, boolean fair) //第二个参数可以指定是否公平</code></p>
<p>当每个线 程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。<br>信号量 的主要逻辑方法有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void acquire()  //尝试获得一个准入,没有就等待或者被中断</span><br><span class="line">public void acquireUninterruptibly() //同上,但是不会响应中断</span><br><span class="line">public boolean tryAcquire()  //类似tryLock尝试获得准入</span><br><span class="line">public boolean tryAcquire(long timeout,TimeUnit unit) //类似</span><br><span class="line">public void release()  //线程访问资源结束后，释放一个许可</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemapDemo implements Runnable&#123;</span><br><span class="line">   final Semaphore semp = new Semaphore(5);  //最多五个许可</span><br><span class="line">   @Override</span><br><span class="line">   public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           semp.acquire(); //20个线程进来申请许可</span><br><span class="line">           //模拟耗时操作</span><br><span class="line">           Thread.sleep(2000); //过20秒输出五组</span><br><span class="line">           Syso(Thread.currentThread().getld()+<span class="string">&quot;:done!&quot;</span>);</span><br><span class="line">           semp.release(); //一定要释放信号量</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">	     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       ExecutorService <span class="built_in">exec</span> = Executors.newFixedThreadPool(20);</span><br><span class="line">       final SemapDemo demo=new SemapDemo();</span><br><span class="line">       <span class="keyword">for</span>(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">           exec.submit(demo);//20个线程</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在离幵时，务必使用<code>release()</code>释放信号量。 就像是释放锁。<br>避免信号量的泄露(申请了但没有释放)，不然能进去的线程越来越少</p>
<h1 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h1><p>读写锁允许多个线程同时读<br>写写操作和读写操作间依然是需要相互等待和持有锁的。</p>
<p>•读-读不互斥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">   private static Lock lock=new ReentrantLock();</span><br><span class="line">   private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">   private static Lock readLock = readWriteLock.readLock();</span><br><span class="line">   private static Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">   private int value;</span><br><span class="line">   public Object handleRead(Lock  lock) throws InterruptedException&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">          lock.lock(); //模拟读</span><br><span class="line">          Thread.sleep(1000); //读的时间越多有事越明显</span><br><span class="line">          value=index;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public Object handleWrite(Lock lock,int index) throws InterruptedException&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">          lock.lock(); //模拟写操作</span><br><span class="line">          Thread.sleep(1000); </span><br><span class="line">          value=index;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123; </span><br><span class="line">     final ReadWriteLockDemo demo=new ReadWriteLockDemo(); </span><br><span class="line">     Runnable readRunnale = new <span class="function"><span class="title">Runnable</span></span>()&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            demo.handleRead(readLock);</span><br><span class="line">            //demo.handleRead(lock);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">    Runnable writeRunnale=new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          demo.handleWrite(writeLock,new Random().nextlnt());</span><br><span class="line">          //demo.handleWrite(lock,new Random().nextlnt()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;18;i++)&#123;</span><br><span class="line">       new Thread(readRunnale).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">         new Thread(writeRunnale).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建读锁和写锁。读开启1 8 个读线程,写开启2个写线程。<br>由 于这里使用了读写分离，因此，读线程完全并行，而写会阻塞读，因此，实际上这段代码运行 大约2秒多就能结束(写线程之间是实际串行的)。而如果注释的两行ReentrantLock可重入锁，<br>那么所有的读和写线程 之间都必须相互等待，因此整个程序的执行时间将长达20余秒。</p>
<hr>
<h1 id="倒计时器：CountDownLatch"><a href="#倒计时器：CountDownLatch" class="headerlink" title="倒计时器：CountDownLatch"></a>倒计时器：CountDownLatch</h1><p>CountDownLatch是一个非常实用的多线程控制工具类。<br>把门锁起来，不让里面的线程跑出来。因 此，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。<br>要等检查线程执行完才能执行(或者说前置线程)<br><code>public CountDownLatch(int n)   ----让n个线程执行完之后,再执行</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchDemo implements Runnable &#123;</span><br><span class="line">    static final CountDownLatch end = newCountDownLatch(10);</span><br><span class="line">    static final CountDownLatchDemo demo=new CountDownLatchDemo();</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span> () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //模拟检查任务</span><br><span class="line">          Thread.sleep(new Random().nextlnt(10)*1000);</span><br><span class="line">          System.out.printIn(<span class="string">&quot;check     complete&quot;</span>);</span><br><span class="line">          end.countDown();</span><br><span class="line">        &#125; catch (工nterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       ExecutorService <span class="built_in">exec</span> = Executors.newFixedThreadPool(10);</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">           exec.submit(demo);</span><br><span class="line">        &#125;     </span><br><span class="line">       end.await ();  //等待检查</span><br><span class="line">       System.out.printin (<span class="string">&quot;执行冤比线程&quot;</span>);</span><br><span class="line">       exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成一个<code>CountDownLatch</code>实例。计数数量为10。这表示需要有10个线 程完成任务，等待在<code>CountDownLatch</code>上的线程才能继续执行。<br><code>CountDownLatch.countdown()</code>方法，也就是通知<code>CountDownLatch</code>, 一个线程己经完成了任务， 倒计时器可”以减1啦。<br><code>CountDownLatch.await()</code>方法，要求主线程等待所有10 个检查任务全部完成。待10个任务全部完成后，主线程才能继续执行。<br>主线程在<code>CountDownLatch</code>上等待，当所有检查任务全部完成后，主线程方能继续执行。</p>
<hr>
<h1 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h1><p><code>CyclicBarrier</code>是另外一种多线程并发控制实用工具。和<code>CountDownLatch</code>非常类似，它也可 以实现线程间的计数等待，但它的功能比<code>CountDownLatch</code>更加复杂且强大。<br><code>CyclicBarrier</code>可以理解为循环栅栏。栅栏就是一种障碍物，比如，通常在私人宅邸的周围 就可以围上一圈栅栏，阻止闲杂人等入内。这里当然就是用来阻止线程继续执行，要求线程在 栅栏处等待。前面Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计 数器设置为1 0 , 那么凑齐第一批1 0 个线程后，计数器就会归零，然后接着凑齐下一批1 0 个线 程，这就是循环栅栏内在的含义。<br><code>CyclicBarrier</code>的使用场景也很丰富。比如，司令下达命令，要求1 0 个士兵一起去完成一项 任务。这时，就会要求1 0 个士兵先集合报道，接着，一起雄赳赳气昂昂地去执行任务。当1 0 个士兵把自己手头的任务都执行完成了，那么司令才能对外宣布，任务完成！<br>比CountDownLatch略微强大一些，<code>CyclicBarrier</code>可以接收一个参数作为<code>barrierAction</code>。所 谓<code>barrierAction</code>就是当计数器一次计数完成后，系统会执行的动作。如下构造函数，其中，<code>parties</code> 表示计数总数，也就是参与的线程总数。<br><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><br>下面的示例使用CyclicBarrier演示了上述司令命令士兵完成任务的场景。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">public static class Soldier implements Runnable &#123;</span><br><span class="line">       private String soldier;</span><br><span class="line">       private final CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">       Soldier(CyclicBarrier cyclic, String soldierName) &#123;</span><br><span class="line">           this.cyclic = cyclic;</span><br><span class="line">           this.soldier = soldierName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               //等待所有士兵到齐</span><br><span class="line">               cyclic.await();</span><br><span class="line">               doWork();</span><br><span class="line">               //等待所有士兵完成工作实战Java高并发程序设计</span><br><span class="line">              cyclic.await(); </span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125; catch (BrokenBarrierException e) &#123; </span><br><span class="line">              e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       void <span class="function"><span class="title">doWork</span></span>()  &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep(Math.abs(new Random().nextlnt()%10000)); </span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">          System, out. <span class="built_in">print</span> In (soldier + 〃：任务完成•’ );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public static class BarrierRun implements Runnable &#123; </span><br><span class="line">       boolean flag;</span><br><span class="line">       int N; </span><br><span class="line">       public BarrierRun(boolean flag, int N) &#123;</span><br><span class="line">          this.flag = flag;</span><br><span class="line">          this.N = N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              System, out. <span class="built_in">print</span> In (n 司令：[士兵知+ 〃个，任务完成！ ]H); </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System, out.printin (** 司令：[士兵〃+N + 〃个，集合完毕！]’ ’</span><br><span class="line">              flag = <span class="literal">true</span>;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String args[]) throws InterruptedException &#123; </span><br><span class="line">       final int N = 10;</span><br><span class="line">       Thread[] allSoldier=new Thread[N];</span><br><span class="line">       boolean flag = <span class="literal">false</span>;</span><br><span class="line">CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag,- N))；第3章roK并发包</span><br><span class="line">       //设置屏障点，主要是为了执行这个方法</span><br><span class="line">       System, out .printin (n集合队伍！ 〃)；</span><br><span class="line">       <span class="keyword">for</span> (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">          System, out .printin (n士兵<span class="string">&quot;+i+,,报道！&quot;</span>)；</span><br><span class="line">          allSoldier [i ] =new Thread (new Soldier (cyclic, 〃士兵〃 + i)); </span><br><span class="line">          allSoldier[i].start();</span><br></pre></td></tr></table></figure>
<p>上述代码第5 7 行，创建了<code>CyclicBarrier</code>实例，并将计数器设置为1 0 , 并要求在计数器达 到指标时，执行第4 3 行的r u n ( ) 方法。每一个士兵线程会执行第1 1 行定义的<code>run( )</code> 方法。在第 14行，每一个士兵线程都会等待，直到所有的士兵都集合完毕。集合完毕后，意味着<code>CyclicBarrier</code> 的一次计数完成，当再一次调用<code>CyclicBarrier.await()</code>时，会进行下一次计数。第15行，模拟了 士兵的任务。当一个士兵任务执行完毕后，他就会要求<code>CyclicBarrier</code>开始下一次计数，这次计 数主要目的是监控是否所有的士兵都己经完成了任务。一旦任务全部完成，第3 5 行定义的 <code>BarrierRun</code>就会被调用，打印相关信息。</p>
<p><code>CyclicBarrier.await()</code>方法可能会抛出两个异常。一个是<code>InterruptedException</code>,也就是在等待 过程中，线程被中断，应该说这是一个非常通用的异常。大部分迫使线程等待的方法都可能会 抛出这个异常，使得线程在等待时依然可以响应外部紧急事件。另外一个异常则是CyclicBarrier 特有的BrokenBarrierException。一旦遇到这个异常，则表示当前的CyclicBarrier B经破损了， 可能系统己经没有办法等待所有线程到齐了。如果继续等待，可能就是徒劳无功的，因此，还 是就地散货，打道回府吧！上述代码第18—22行处理了这2种异常。<br>如果我们在上述代码的第63行后，插入以下代码，使得第5个士兵线程产生中断： if(i==5){<br>allSoldier[0].interrupt(); }<br>如果这样做，我们很可能就会得到1个InterruptedException和9个BrokenBarrierExceptiono 这个InterruptedException就是被中断线程抛出的。而其他9个BrokenBarrierException,则是等 待在当前Cy c l ic Ba r ri e r 上的线程抛出的。这个异常可以避免其他9 个线程进行永久的、无谓的 等待(因为其中一个线程已经被中断，等待是没有结果的)。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://up.enterdesk.com/edpic_source/78/3f/d7/783fd7b40445e241d4a69e36ec65a764.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/10/%E5%85%AC%E5%B9%B3%E6%B4%97%E7%89%8C/"><img class="prev-cover" src="https://up.enterdesk.com/edpic_source/bf/c4/80/bfc48058bfc2b1f6720f8e30a942679c.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">公平洗牌</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/22/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0-%E9%94%81%E4%BC%98%E5%8C%96/"><img class="next-cover" src="https://up.enterdesk.com/edpic_source/2f/9e/d5/2f9ed5d2b92a93347a3d3230317229de.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java并发笔记-锁优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02/15/测试标签/" title="测试标签"><img class="cover" src="https://up.enterdesk.com/edpic_source/e0/40/08/e04008d6d6e0875b62932310dbbc97fd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">测试标签</div></div></a></div><div><a href="/2020/08/19/分布式全局唯一ID/" title="分布式全局唯一ID"><img class="cover" src="https://static001.geekbang.org/resource/image/73/2c/73ec27e596b73dba28b36c3ad1cce82c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-19</div><div class="title">分布式全局唯一ID</div></div></a></div><div><a href="/2019/09/13/JVM-0类加载/" title="JVM-0类加载"><img class="cover" src="https://up.enterdesk.com/edpic_source/a6/e0/f0/a6e0f012c5e87e3f240bb99a46654da5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-13</div><div class="title">JVM-0类加载</div></div></a></div><div><a href="/2019/10/04/JVM-1内存模型/" title="JVM-1内存模型"><img class="cover" src="https://up.enterdesk.com/edpic_source/a8/72/30/a872308163d57800d2c77565a484a800.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-04</div><div class="title">JVM-1内存模型</div></div></a></div><div><a href="/2019/12/15/JVM-3小垃圾之引用类型/" title="JVM-3小垃圾之引用类型"><img class="cover" src="https://static001.geekbang.org/resource/image/04/ea/04d395dba61d761ae3c0a2b2d15cd3ea.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-15</div><div class="title">JVM-3小垃圾之引用类型</div></div></a></div><div><a href="/2019/11/04/JVM-2小垃圾/" title="JVM-2小垃圾"><img class="cover" src="https://up.enterdesk.com/edpic_source/e0/40/08/e04008d6d6e0875b62932310dbbc97fd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-04</div><div class="title">JVM-2小垃圾</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/page.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">凌</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="http://www.lingshuo.top"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到凌的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">同步控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">2.</span> <span class="toc-text">重入锁ReentrantLock——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84Condition%E6%9D%A1%E4%BB%B6%E2%80%94%E2%80%93"><span class="toc-number">3.</span> <span class="toc-text">重入锁的Condition条件—–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="toc-number">4.</span> <span class="toc-text">多个线程同时访问：信号量(Semaphore)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">ReadWriteLock 读写锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%9ACountDownLatch"><span class="toc-number">6.</span> <span class="toc-text">倒计时器：CountDownLatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%EF%BC%9ACyclicBarrier"><span class="toc-number">7.</span> <span class="toc-text">循环栅栏：CyclicBarrier</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/" title="分布式全局唯一ID"><img src="https://static001.geekbang.org/resource/image/73/2c/73ec27e596b73dba28b36c3ad1cce82c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式全局唯一ID"/></a><div class="content"><a class="title" href="/2020/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/" title="分布式全局唯一ID">分布式全局唯一ID</a><time datetime="2020-08-19T04:12:10.000Z" title="发表于 2020-08-19 12:12:10">2020-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/15/redis-4-%E5%B8%B8%E8%A7%81%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" title="redis-4.常见生产问题处理"><img src="https://up.enterdesk.com/edpic_source/2b/d0/80/2bd0806475428088f81b5d58f389c18b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-4.常见生产问题处理"/></a><div class="content"><a class="title" href="/2020/06/15/redis-4-%E5%B8%B8%E8%A7%81%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" title="redis-4.常见生产问题处理">redis-4.常见生产问题处理</a><time datetime="2020-06-15T14:36:23.000Z" title="发表于 2020-06-15 22:36:23">2020-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/03/%E9%BE%9F%E5%AD%99D%E9%9F%B3/" title="龟孙D音"><img src="https://up.enterdesk.com/edpic_source/60/bf/27/60bf27c5bfb96e1fc857ae5e8f73f5ed.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="龟孙D音"/></a><div class="content"><a class="title" href="/2020/06/03/%E9%BE%9F%E5%AD%99D%E9%9F%B3/" title="龟孙D音">龟孙D音</a><time datetime="2020-06-03T14:59:56.000Z" title="发表于 2020-06-03 22:59:56">2020-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/01/%E6%9C%89%E6%84%8F%E6%80%9D-2%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%B8%8E%E8%B4%A8%E6%95%B0/" title="有意思-2异位词分组与质数"><img src="https://up.enterdesk.com/edpic_source/c8/c7/3c/c8c73cec80473032e7f9955e3c78f7a3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有意思-2异位词分组与质数"/></a><div class="content"><a class="title" href="/2020/06/01/%E6%9C%89%E6%84%8F%E6%80%9D-2%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%B8%8E%E8%B4%A8%E6%95%B0/" title="有意思-2异位词分组与质数">有意思-2异位词分组与质数</a><time datetime="2020-06-01T04:15:52.000Z" title="发表于 2020-06-01 12:15:52">2020-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/05/25/%E6%9C%89%E6%84%8F%E6%80%9D-0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%BC%82%E6%88%96/" title="有意思-0两数交换与异或"><img src="https://up.enterdesk.com/edpic_source/94/11/58/941158051fb301f29c36fa39da96f7eb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有意思-0两数交换与异或"/></a><div class="content"><a class="title" href="/2020/05/25/%E6%9C%89%E6%84%8F%E6%80%9D-0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%BC%82%E6%88%96/" title="有意思-0两数交换与异或">有意思-0两数交换与异或</a><time datetime="2020-05-25T03:16:09.000Z" title="发表于 2020-05-25 11:16:09">2020-05-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;undefined - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 凌</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideCategory.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>